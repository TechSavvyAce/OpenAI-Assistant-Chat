/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/adm-zip";
exports.ids = ["vendor-chunks/adm-zip"];
exports.modules = {

/***/ "(rsc)/./node_modules/adm-zip/adm-zip.js":
/*!*****************************************!*\
  !*** ./node_modules/adm-zip/adm-zip.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Utils = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/adm-zip/util/index.js\");\nconst pth = __webpack_require__(/*! path */ \"path\");\nconst ZipEntry = __webpack_require__(/*! ./zipEntry */ \"(rsc)/./node_modules/adm-zip/zipEntry.js\");\nconst ZipFile = __webpack_require__(/*! ./zipFile */ \"(rsc)/./node_modules/adm-zip/zipFile.js\");\nconst get_Bool = (val, def)=>typeof val === \"boolean\" ? val : def;\nconst get_Str = (val, def)=>typeof val === \"string\" ? val : def;\nconst defaultOptions = {\n    // option \"noSort\" : if true it disables files sorting\n    noSort: false,\n    // read entries during load (initial loading may be slower)\n    readEntries: false,\n    // default method is none\n    method: Utils.Constants.NONE,\n    // file system\n    fs: null\n};\nmodule.exports = function(/**String*/ input, /** object */ options) {\n    let inBuffer = null;\n    // create object based default options, allowing them to be overwritten\n    const opts = Object.assign(Object.create(null), defaultOptions);\n    // test input variable\n    if (input && \"object\" === typeof input) {\n        // if value is not buffer we accept it to be object with options\n        if (!(input instanceof Uint8Array)) {\n            Object.assign(opts, input);\n            input = opts.input ? opts.input : undefined;\n            if (opts.input) delete opts.input;\n        }\n        // if input is buffer\n        if (Buffer.isBuffer(input)) {\n            inBuffer = input;\n            opts.method = Utils.Constants.BUFFER;\n            input = undefined;\n        }\n    }\n    // assign options\n    Object.assign(opts, options);\n    // instanciate utils filesystem\n    const filetools = new Utils(opts);\n    // if input is file name we retrieve its content\n    if (input && \"string\" === typeof input) {\n        // load zip file\n        if (filetools.fs.existsSync(input)) {\n            opts.method = Utils.Constants.FILE;\n            opts.filename = input;\n            inBuffer = filetools.fs.readFileSync(input);\n        } else {\n            throw new Error(Utils.Errors.INVALID_FILENAME);\n        }\n    }\n    // create variable\n    const _zip = new ZipFile(inBuffer, opts);\n    const { canonical, sanitize } = Utils;\n    function getEntry(/**Object*/ entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\") item = _zip.getEntry(entry);\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n    function fixPath(zipPath) {\n        const { join, normalize, sep } = pth.posix;\n        // convert windows file separators and normalize\n        return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n    }\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param entry ZipEntry object or String with the full path of the entry\n         *\n         * @return Buffer or Null in case of error\n         */ readFile: function(/**Object*/ entry, /*String, Buffer*/ pass) {\n            var item = getEntry(entry);\n            return item && item.getData(pass) || null;\n        },\n        /**\n         * Asynchronous readFile\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         *\n         * @return Buffer or Null in case of error\n         */ readFileAsync: function(/**Object*/ entry, /**Function*/ callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null, \"getEntry failed for:\" + entry);\n            }\n        },\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */ readAsText: function(/**Object*/ entry, /**String=*/ encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n        /**\n         * Asynchronous readAsText\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */ readAsTextAsync: function(/**Object*/ entry, /**Function*/ callback, /**String=*/ encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function(data, err) {\n                    if (err) {\n                        callback(data, err);\n                        return;\n                    }\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                });\n            } else {\n                callback(\"\");\n            }\n        },\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param entry\n         */ deleteFile: function(/**Object*/ entry) {\n            // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param comment\n         */ addZipComment: function(/**String*/ comment) {\n            // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */ getZipComment: function() {\n            return _zip.comment || \"\";\n        },\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param entry\n         * @param comment\n         */ addZipEntryComment: function(/**Object*/ entry, /**String*/ comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param entry\n         * @return String\n         */ getZipEntryComment: function(/**Object*/ entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || \"\";\n            }\n            return \"\";\n        },\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param entry\n         * @param content\n         */ updateFile: function(/**Object*/ entry, /**Buffer*/ content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param localPath File to add to zip\n         * @param zipPath Optional path inside the zip\n         * @param zipName Optional name for the file\n         */ addLocalFile: function(/**String*/ localPath, /**String=*/ zipPath, /**String=*/ zipName, /**String*/ comment) {\n            if (filetools.fs.existsSync(localPath)) {\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n                // p - local file name\n                var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n                // read file attributes\n                const _attr = filetools.fs.statSync(localPath);\n                // add file into zip file\n                this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);\n            } else {\n                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n            }\n        },\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param localPath\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n         */ addLocalFolder: function(/**String*/ localPath, /**String=*/ zipPath, /**=RegExp|Function*/ filter, /**=number|object*/ attr) {\n            // Prepare filter\n            if (filter instanceof RegExp) {\n                // if filter is RegExp wrap it\n                filter = function(rx) {\n                    return function(filename) {\n                        return rx.test(filename);\n                    };\n                }(filter);\n            } else if (\"function\" !== typeof filter) {\n                // if filter is not function we will replace it\n                filter = function() {\n                    return true;\n                };\n            }\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n            if (filetools.fs.existsSync(localPath)) {\n                const items = filetools.findFiles(localPath);\n                const self = this;\n                if (items.length) {\n                    items.forEach(function(filepath) {\n                        var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                        if (filter(p)) {\n                            var stats = filetools.fs.statSync(filepath);\n                            if (stats.isFile()) {\n                                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), \"\", attr ? attr : stats);\n                            } else {\n                                self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", attr ? attr : stats);\n                            }\n                        }\n                    });\n                }\n            } else {\n                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n            }\n        },\n        /**\n         * Asynchronous addLocalFile\n         * @param localPath\n         * @param callback\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         */ addLocalFolderAsync: function(/*String*/ localPath, /*Function*/ callback, /*String*/ zipPath, /*RegExp|Function*/ filter) {\n            if (filter instanceof RegExp) {\n                filter = function(rx) {\n                    return function(filename) {\n                        return rx.test(filename);\n                    };\n                }(filter);\n            } else if (\"function\" !== typeof filter) {\n                filter = function() {\n                    return true;\n                };\n            }\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n            var self = this;\n            filetools.fs.open(localPath, \"r\", function(err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    var items = filetools.findFiles(localPath);\n                    var i = -1;\n                    var next = function() {\n                        i += 1;\n                        if (i < items.length) {\n                            var filepath = items[i];\n                            var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                            p = p.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n                            if (filter(p)) {\n                                filetools.fs.stat(filepath, function(er0, stats) {\n                                    if (er0) callback(undefined, er0);\n                                    if (stats.isFile()) {\n                                        filetools.fs.readFile(filepath, function(er1, data) {\n                                            if (er1) {\n                                                callback(undefined, er1);\n                                            } else {\n                                                self.addFile(zipPath + p, data, \"\", stats);\n                                                next();\n                                            }\n                                        });\n                                    } else {\n                                        self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                                        next();\n                                    }\n                                });\n                            } else {\n                                process.nextTick(()=>{\n                                    next();\n                                });\n                            }\n                        } else {\n                            callback(true, undefined);\n                        }\n                    };\n                    next();\n                }\n            });\n        },\n        /**\n         *\n         * @param {string} localPath - path where files will be extracted\n         * @param {object} props - optional properties\n         * @param {string} props.zipPath - optional path inside zip\n         * @param {regexp, function} props.filter - RegExp or Function if files match will be included.\n         */ addLocalFolderPromise: function(/*String*/ localPath, /* object */ props) {\n            return new Promise((resolve, reject)=>{\n                const { filter, zipPath } = Object.assign({}, props);\n                this.addLocalFolderAsync(localPath, (done, err)=>{\n                    if (err) reject(err);\n                    if (done) resolve(this);\n                }, zipPath, filter);\n            });\n        },\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param {string} entryName\n         * @param {Buffer | string} content - file content as buffer or utf8 coded string\n         * @param {string} comment - file comment\n         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n         */ addFile: function(/**String*/ entryName, /**Buffer*/ content, /**String*/ comment, /**Number*/ attr) {\n            let entry = getEntry(entryName);\n            const update = entry != null;\n            // prepare new entry\n            if (!update) {\n                entry = new ZipEntry();\n                entry.entryName = entryName;\n            }\n            entry.comment = comment || \"\";\n            const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n            // last modification time from file stats\n            if (isStat) {\n                entry.header.time = attr.mtime;\n            }\n            // Set file attribute\n            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n            // extended attributes field for Unix\n            // set file type either S_IFDIR / S_IFREG\n            let unix = entry.isDirectory ? 0x4000 : 0x8000;\n            if (isStat) {\n                // File attributes from file stats\n                unix |= 0xfff & attr.mode;\n            } else if (\"number\" === typeof attr) {\n                // attr from given attr values\n                unix |= 0xfff & attr;\n            } else {\n                // Default values:\n                unix |= entry.isDirectory ? 493 : 420; // permissions (drwxr-xr-x) or (-r-wr--r--)\n            }\n            fileattr = (fileattr | unix << 16) >>> 0; // add attributes\n            entry.attr = fileattr;\n            entry.setData(content);\n            if (!update) _zip.setEntry(entry);\n        },\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @return Array\n         */ getEntries: function() {\n            return _zip ? _zip.entries : [];\n        },\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param name\n         * @return ZipEntry\n         */ getEntry: function(/**String*/ name) {\n            return getEntry(name);\n        },\n        getEntryCount: function() {\n            return _zip.getEntryCount();\n        },\n        forEach: function(callback) {\n            return _zip.forEach(callback);\n        },\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param targetPath Target folder where to write the file\n         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n         *                          will be created in targetPath as well. Default is TRUE\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)\n         *\n         * @return Boolean\n         */ extractEntryTo: function(/**Object*/ entry, /**String*/ targetPath, /**Boolean*/ maintainEntryPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**String**/ outFileName) {\n            overwrite = get_Bool(overwrite, false);\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            maintainEntryPath = get_Bool(maintainEntryPath, true);\n            outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));\n            var item = getEntry(entry);\n            if (!item) {\n                throw new Error(Utils.Errors.NO_ENTRY);\n            }\n            var entryName = canonical(item.entryName);\n            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n            if (item.isDirectory) {\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function(child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                    }\n                    var name = canonical(child.entryName);\n                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n                    // The reverse operation for attr depend on method addFile()\n                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n                    filetools.writeFileTo(childName, content, overwrite, fileAttr);\n                });\n                return true;\n            }\n            var content = item.getData();\n            if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n            if (filetools.fs.existsSync(target) && !overwrite) {\n                throw new Error(Utils.Errors.CANT_OVERRIDE);\n            }\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileTo(target, content, overwrite, fileAttr);\n            return true;\n        },\n        /**\n         * Test the archive\n         *\n         */ test: function(pass) {\n            if (!_zip) {\n                return false;\n            }\n            for(var entry in _zip.entries){\n                try {\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData(pass);\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         */ extractAllTo: function(/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /*String, Buffer*/ pass) {\n            overwrite = get_Bool(overwrite, false);\n            pass = get_Str(keepOriginalPermission, pass);\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            if (!_zip) {\n                throw new Error(Utils.Errors.NO_ZIP);\n            }\n            _zip.entries.forEach(function(entry) {\n                var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));\n                if (entry.isDirectory) {\n                    filetools.makeDir(entryName);\n                    return;\n                }\n                var content = entry.getData(pass);\n                if (!content) {\n                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                }\n                // The reverse operation for attr depend on method addFile()\n                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n                try {\n                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n                } catch (err) {\n                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                }\n            });\n        },\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n         */ extractAllToAsync: function(/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**Function*/ callback) {\n            overwrite = get_Bool(overwrite, false);\n            if (typeof keepOriginalPermission === \"function\" && !callback) callback = keepOriginalPermission;\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            if (!callback) {\n                callback = function(err) {\n                    throw new Error(err);\n                };\n            }\n            if (!_zip) {\n                callback(new Error(Utils.Errors.NO_ZIP));\n                return;\n            }\n            targetPath = pth.resolve(targetPath);\n            // convert entryName to\n            const getPath = (entry)=>sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));\n            const getError = (msg, file)=>new Error(msg + ': \"' + file + '\"');\n            // separate directories from files\n            const dirEntries = [];\n            const fileEntries = new Set();\n            _zip.entries.forEach((e)=>{\n                if (e.isDirectory) {\n                    dirEntries.push(e);\n                } else {\n                    fileEntries.add(e);\n                }\n            });\n            // Create directory entries first synchronously\n            // this prevents race condition and assures folders are there before writing files\n            for (const entry of dirEntries){\n                const dirPath = getPath(entry);\n                // The reverse operation for attr depend on method addFile()\n                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                try {\n                    filetools.makeDir(dirPath);\n                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n                    // in unix timestamp will change if files are later added to folder, but still\n                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n                } catch (er) {\n                    callback(getError(\"Unable to create folder\", dirPath));\n                }\n            }\n            // callback wrapper, for some house keeping\n            const done = ()=>{\n                if (fileEntries.size === 0) {\n                    callback();\n                }\n            };\n            // Extract file entries asynchronously\n            for (const entry of fileEntries.values()){\n                const entryName = pth.normalize(canonical(entry.entryName.toString()));\n                const filePath = sanitize(targetPath, entryName);\n                entry.getDataAsync(function(content, err_1) {\n                    if (err_1) {\n                        callback(new Error(err_1));\n                        return;\n                    }\n                    if (!content) {\n                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n                    } else {\n                        // The reverse operation for attr depend on method addFile()\n                        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                        filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function(succ) {\n                            if (!succ) {\n                                callback(getError(\"Unable to write file\", filePath));\n                                return;\n                            }\n                            filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function(err_2) {\n                                if (err_2) {\n                                    callback(getError(\"Unable to set times\", filePath));\n                                    return;\n                                }\n                                fileEntries.delete(entry);\n                                // call the callback if it was last entry\n                                done();\n                            });\n                        });\n                    }\n                });\n            }\n            // call the callback if fileEntries was empty\n            done();\n        },\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param targetFileName\n         * @param callback\n         */ writeZip: function(/**String*/ targetFileName, /**Function*/ callback) {\n            if (arguments.length === 1) {\n                if (typeof targetFileName === \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n            if (!targetFileName && opts.filename) {\n                targetFileName = opts.filename;\n            }\n            if (!targetFileName) return;\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = filetools.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n            }\n        },\n        writeZipPromise: function(/**String*/ targetFileName, /* object */ props) {\n            const { overwrite, perm } = Object.assign({\n                overwrite: true\n            }, props);\n            return new Promise((resolve, reject)=>{\n                // find file name\n                if (!targetFileName && opts.filename) targetFileName = opts.filename;\n                if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n                this.toBufferPromise().then((zipData)=>{\n                    const ret = (done)=>done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\");\n                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n                }, reject);\n            });\n        },\n        toBufferPromise: function() {\n            return new Promise((resolve, reject)=>{\n                _zip.toAsyncBuffer(resolve, reject);\n            });\n        },\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @return Buffer\n         */ toBuffer: function(/**Function=*/ onSuccess, /**Function=*/ onFail, /**Function=*/ onItemStart, /**Function=*/ onItemEnd) {\n            this.valueOf = 2;\n            if (typeof onSuccess === \"function\") {\n                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer();\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFnQjtRQUNoQztJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25kYXlBc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9hZG0temlwLmpzPzBmODMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgcHRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBaaXBFbnRyeSA9IHJlcXVpcmUoXCIuL3ppcEVudHJ5XCIpO1xuY29uc3QgWmlwRmlsZSA9IHJlcXVpcmUoXCIuL3ppcEZpbGVcIik7XG5cbmNvbnN0IGdldF9Cb29sID0gKHZhbCwgZGVmKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIgPyB2YWwgOiBkZWYpO1xuY29uc3QgZ2V0X1N0ciA9ICh2YWwsIGRlZikgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyB2YWwgOiBkZWYpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBvcHRpb24gXCJub1NvcnRcIiA6IGlmIHRydWUgaXQgZGlzYWJsZXMgZmlsZXMgc29ydGluZ1xuICAgIG5vU29ydDogZmFsc2UsXG4gICAgLy8gcmVhZCBlbnRyaWVzIGR1cmluZyBsb2FkIChpbml0aWFsIGxvYWRpbmcgbWF5IGJlIHNsb3dlcilcbiAgICByZWFkRW50cmllczogZmFsc2UsXG4gICAgLy8gZGVmYXVsdCBtZXRob2QgaXMgbm9uZVxuICAgIG1ldGhvZDogVXRpbHMuQ29uc3RhbnRzLk5PTkUsXG4gICAgLy8gZmlsZSBzeXN0ZW1cbiAgICBmczogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gaW5wdXQsIC8qKiBvYmplY3QgKi8gb3B0aW9ucykge1xuICAgIGxldCBpbkJ1ZmZlciA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgb2JqZWN0IGJhc2VkIGRlZmF1bHQgb3B0aW9ucywgYWxsb3dpbmcgdGhlbSB0byBiZSBvdmVyd3JpdHRlblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRPcHRpb25zKTtcblxuICAgIC8vIHRlc3QgaW5wdXQgdmFyaWFibGVcbiAgICBpZiAoaW5wdXQgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBidWZmZXIgd2UgYWNjZXB0IGl0IHRvIGJlIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBpbnB1dCk7XG4gICAgICAgICAgICBpbnB1dCA9IG9wdHMuaW5wdXQgPyBvcHRzLmlucHV0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG9wdHMuaW5wdXQpIGRlbGV0ZSBvcHRzLmlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaW5wdXQgaXMgYnVmZmVyXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbkJ1ZmZlciA9IGlucHV0O1xuICAgICAgICAgICAgb3B0cy5tZXRob2QgPSBVdGlscy5Db25zdGFudHMuQlVGRkVSO1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3B0aW9uc1xuICAgIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbnN0YW5jaWF0ZSB1dGlscyBmaWxlc3lzdGVtXG4gICAgY29uc3QgZmlsZXRvb2xzID0gbmV3IFV0aWxzKG9wdHMpO1xuXG4gICAgLy8gaWYgaW5wdXQgaXMgZmlsZSBuYW1lIHdlIHJldHJpZXZlIGl0cyBjb250ZW50XG4gICAgaWYgKGlucHV0ICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuICAgICAgICAvLyBsb2FkIHppcCBmaWxlXG4gICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyhpbnB1dCkpIHtcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkZJTEU7XG4gICAgICAgICAgICBvcHRzLmZpbGVuYW1lID0gaW5wdXQ7XG4gICAgICAgICAgICBpbkJ1ZmZlciA9IGZpbGV0b29scy5mcy5yZWFkRmlsZVN5bmMoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5JTlZBTElEX0ZJTEVOQU1FKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB2YXJpYWJsZVxuICAgIGNvbnN0IF96aXAgPSBuZXcgWmlwRmlsZShpbkJ1ZmZlciwgb3B0cyk7XG5cbiAgICBjb25zdCB7IGNhbm9uaWNhbCwgc2FuaXRpemUgfSA9IFV0aWxzO1xuXG4gICAgZnVuY3Rpb24gZ2V0RW50cnkoLyoqT2JqZWN0Ki8gZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ICYmIF96aXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgLy8gSWYgZW50cnkgd2FzIGdpdmVuIGFzIGEgZmlsZSBuYW1lXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiKSBpdGVtID0gX3ppcC5nZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAvLyBpZiBlbnRyeSB3YXMgZ2l2ZW4gYXMgYSBaaXBFbnRyeSBvYmplY3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGVudHJ5LmVudHJ5TmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZW50cnkuaGVhZGVyICE9PSBcInVuZGVmaW5lZFwiKSBpdGVtID0gX3ppcC5nZXRFbnRyeShlbnRyeS5lbnRyeU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFBhdGgoemlwUGF0aCkge1xuICAgICAgICBjb25zdCB7IGpvaW4sIG5vcm1hbGl6ZSwgc2VwIH0gPSBwdGgucG9zaXg7XG4gICAgICAgIC8vIGNvbnZlcnQgd2luZG93cyBmaWxlIHNlcGFyYXRvcnMgYW5kIG5vcm1hbGl6ZVxuICAgICAgICByZXR1cm4gam9pbihcIi5cIiwgbm9ybWFsaXplKHNlcCArIHppcFBhdGguc3BsaXQoXCJcXFxcXCIpLmpvaW4oc2VwKSArIHNlcCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgZnJvbSB0aGUgYXJjaGl2ZSBhbmQgcmV0dXJucyB0aGUgY29udGVudCBhcyBhIEJ1ZmZlciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEJ1ZmZlciBvciBOdWxsIGluIGNhc2Ugb2YgZXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGaWxlOiBmdW5jdGlvbiAoLyoqT2JqZWN0Ki8gZW50cnksIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiAoaXRlbSAmJiBpdGVtLmdldERhdGEocGFzcykpIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzeW5jaHJvbm91cyByZWFkRmlsZVxuICAgICAgICAgKiBAcGFyYW0gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEJ1ZmZlciBvciBOdWxsIGluIGNhc2Ugb2YgZXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIHJlYWRGaWxlQXN5bmM6IGZ1bmN0aW9uICgvKipPYmplY3QqLyBlbnRyeSwgLyoqRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZ2V0RGF0YUFzeW5jKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgXCJnZXRFbnRyeSBmYWlsZWQgZm9yOlwiICsgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRyYWN0cyB0aGUgZ2l2ZW4gZW50cnkgZnJvbSB0aGUgYXJjaGl2ZSBhbmQgcmV0dXJucyB0aGUgY29udGVudCBhcyBwbGFpbiB0ZXh0IGluIHRoZSBnaXZlbiBlbmNvZGluZ1xuICAgICAgICAgKiBAcGFyYW0gZW50cnkgWmlwRW50cnkgb2JqZWN0IG9yIFN0cmluZyB3aXRoIHRoZSBmdWxsIHBhdGggb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSBlbmNvZGluZyBPcHRpb25hbC4gSWYgbm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHV0ZjggaXMgdXNlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVhZEFzVGV4dDogZnVuY3Rpb24gKC8qKk9iamVjdCovIGVudHJ5LCAvKipTdHJpbmc9Ki8gZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGl0ZW0uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKGVuY29kaW5nIHx8IFwidXRmOFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmNocm9ub3VzIHJlYWRBc1RleHRcbiAgICAgICAgICogQHBhcmFtIGVudHJ5IFppcEVudHJ5IG9iamVjdCBvciBTdHJpbmcgd2l0aCB0aGUgZnVsbCBwYXRoIG9mIHRoZSBlbnRyeVxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIGVuY29kaW5nIE9wdGlvbmFsLiBJZiBubyBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdXRmOCBpcyB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICByZWFkQXNUZXh0QXN5bmM6IGZ1bmN0aW9uICgvKipPYmplY3QqLyBlbnRyeSwgLyoqRnVuY3Rpb24qLyBjYWxsYmFjaywgLyoqU3RyaW5nPSovIGVuY29kaW5nKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5nZXREYXRhQXN5bmMoZnVuY3Rpb24gKGRhdGEsIGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEudG9TdHJpbmcoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGZyb20gdGhlIGZpbGUgb3IgdGhlIGVudHJ5IGFuZCBhbGwgaXQncyBuZXN0ZWQgZGlyZWN0b3JpZXMgYW5kIGZpbGVzIGlmIHRoZSBnaXZlbiBlbnRyeSBpcyBhIGRpcmVjdG9yeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW50cnlcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUZpbGU6IGZ1bmN0aW9uICgvKipPYmplY3QqLyBlbnRyeSkge1xuICAgICAgICAgICAgLy8gQFRPRE86IHRlc3QgZGVsZXRlRmlsZVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIF96aXAuZGVsZXRlRW50cnkoaXRlbS5lbnRyeU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29tbWVudCB0byB0aGUgemlwLiBUaGUgemlwIG11c3QgYmUgcmV3cml0dGVuIGFmdGVyIGFkZGluZyB0aGUgY29tbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGFkZFppcENvbW1lbnQ6IGZ1bmN0aW9uICgvKipTdHJpbmcqLyBjb21tZW50KSB7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGVzdCBhZGRaaXBDb21tZW50XG4gICAgICAgICAgICBfemlwLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB6aXAgY29tbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WmlwQ29tbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF96aXAuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY29tbWVudCB0byBhIHNwZWNpZmllZCB6aXBFbnRyeS4gVGhlIHppcCBtdXN0IGJlIHJld3JpdHRlbiBhZnRlciBhZGRpbmcgdGhlIGNvbW1lbnRcbiAgICAgICAgICogVGhlIGNvbW1lbnQgY2Fubm90IGV4Y2VlZCA2NTUzNSBjaGFyYWN0ZXJzIGluIGxlbmd0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZW50cnlcbiAgICAgICAgICogQHBhcmFtIGNvbW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGFkZFppcEVudHJ5Q29tbWVudDogZnVuY3Rpb24gKC8qKk9iamVjdCovIGVudHJ5LCAvKipTdHJpbmcqLyBjb21tZW50KSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29tbWVudCBvZiB0aGUgc3BlY2lmaWVkIGVudHJ5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeVxuICAgICAgICAgKiBAcmV0dXJuIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WmlwRW50cnlDb21tZW50OiBmdW5jdGlvbiAoLyoqT2JqZWN0Ki8gZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY29udGVudCBvZiBhbiBleGlzdGluZyBlbnRyeSBpbnNpZGUgdGhlIGFyY2hpdmUuIFRoZSB6aXAgbXVzdCBiZSByZXdyaXR0ZW4gYWZ0ZXIgdXBkYXRpbmcgdGhlIGNvbnRlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVudHJ5XG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVGaWxlOiBmdW5jdGlvbiAoLyoqT2JqZWN0Ki8gZW50cnksIC8qKkJ1ZmZlciovIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNldERhdGEoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBmaWxlIGZyb20gdGhlIGRpc2sgdG8gdGhlIGFyY2hpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxvY2FsUGF0aCBGaWxlIHRvIGFkZCB0byB6aXBcbiAgICAgICAgICogQHBhcmFtIHppcFBhdGggT3B0aW9uYWwgcGF0aCBpbnNpZGUgdGhlIHppcFxuICAgICAgICAgKiBAcGFyYW0gemlwTmFtZSBPcHRpb25hbCBuYW1lIGZvciB0aGUgZmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGaWxlOiBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gbG9jYWxQYXRoLCAvKipTdHJpbmc9Ki8gemlwUGF0aCwgLyoqU3RyaW5nPSovIHppcE5hbWUsIC8qKlN0cmluZyovIGNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyhsb2NhbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4IFppcFBhdGhcbiAgICAgICAgICAgICAgICB6aXBQYXRoID0gemlwUGF0aCA/IGZpeFBhdGgoemlwUGF0aCkgOiBcIlwiO1xuXG4gICAgICAgICAgICAgICAgLy8gcCAtIGxvY2FsIGZpbGUgbmFtZVxuICAgICAgICAgICAgICAgIHZhciBwID0gbG9jYWxQYXRoLnNwbGl0KFwiXFxcXFwiKS5qb2luKFwiL1wiKS5zcGxpdChcIi9cIikucG9wKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgZmlsZSBuYW1lIGludG8gemlwcGF0aFxuICAgICAgICAgICAgICAgIHppcFBhdGggKz0gemlwTmFtZSA/IHppcE5hbWUgOiBwO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVhZCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBfYXR0ciA9IGZpbGV0b29scy5mcy5zdGF0U3luYyhsb2NhbFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGZpbGUgaW50byB6aXAgZmlsZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZSh6aXBQYXRoLCBmaWxldG9vbHMuZnMucmVhZEZpbGVTeW5jKGxvY2FsUGF0aCksIGNvbW1lbnQsIF9hdHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORC5yZXBsYWNlKFwiJXNcIiwgbG9jYWxQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSBsb2NhbCBkaXJlY3RvcnkgYW5kIGFsbCBpdHMgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB0byB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbG9jYWxQYXRoXG4gICAgICAgICAqIEBwYXJhbSB6aXBQYXRoIG9wdGlvbmFsIHBhdGggaW5zaWRlIHppcFxuICAgICAgICAgKiBAcGFyYW0gZmlsdGVyIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsXG4gICAgICAgICAqICAgICAgICAgICAgICAgYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgb2JqZWN0fSBhdHRyIC0gbnVtYmVyIGFzIHVuaXggZmlsZSBwZXJtaXNzaW9ucywgb2JqZWN0IGFzIGZpbGVzeXN0ZW0gU3RhdHMgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRMb2NhbEZvbGRlcjogZnVuY3Rpb24gKC8qKlN0cmluZyovIGxvY2FsUGF0aCwgLyoqU3RyaW5nPSovIHppcFBhdGgsIC8qKj1SZWdFeHB8RnVuY3Rpb24qLyBmaWx0ZXIsIC8qKj1udW1iZXJ8b2JqZWN0Ki8gYXR0cikge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSBmaWx0ZXJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmaWx0ZXIgaXMgUmVnRXhwIHdyYXAgaXRcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSAoZnVuY3Rpb24gKHJ4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KShmaWx0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmaWx0ZXIgaXMgbm90IGZ1bmN0aW9uIHdlIHdpbGwgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IFppcFBhdGhcbiAgICAgICAgICAgIHppcFBhdGggPSB6aXBQYXRoID8gZml4UGF0aCh6aXBQYXRoKSA6IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgcGF0aCBmaXJzdFxuICAgICAgICAgICAgbG9jYWxQYXRoID0gcHRoLm5vcm1hbGl6ZShsb2NhbFBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoZmlsZXRvb2xzLmZzLmV4aXN0c1N5bmMobG9jYWxQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gZmlsZXRvb2xzLmZpbmRGaWxlcyhsb2NhbFBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwdGgucmVsYXRpdmUobG9jYWxQYXRoLCBmaWxlcGF0aCkuc3BsaXQoXCJcXFxcXCIpLmpvaW4oXCIvXCIpOyAvL3dpbmRvd3MgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRzID0gZmlsZXRvb2xzLmZzLnN0YXRTeW5jKGZpbGVwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGggKyBwLCBmaWxldG9vbHMuZnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoKSwgXCJcIiwgYXR0ciA/IGF0dHIgOiBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlKHppcFBhdGggKyBwICsgXCIvXCIsIEJ1ZmZlci5hbGxvYygwKSwgXCJcIiwgYXR0ciA/IGF0dHIgOiBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuRklMRV9OT1RfRk9VTkQucmVwbGFjZShcIiVzXCIsIGxvY2FsUGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3luY2hyb25vdXMgYWRkTG9jYWxGaWxlXG4gICAgICAgICAqIEBwYXJhbSBsb2NhbFBhdGhcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB6aXBQYXRoIG9wdGlvbmFsIHBhdGggaW5zaWRlIHppcFxuICAgICAgICAgKiBAcGFyYW0gZmlsdGVyIG9wdGlvbmFsIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsXG4gICAgICAgICAqICAgICAgICAgICAgICAgYmUgaW5jbHVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRMb2NhbEZvbGRlckFzeW5jOiBmdW5jdGlvbiAoLypTdHJpbmcqLyBsb2NhbFBhdGgsIC8qRnVuY3Rpb24qLyBjYWxsYmFjaywgLypTdHJpbmcqLyB6aXBQYXRoLCAvKlJlZ0V4cHxGdW5jdGlvbiovIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IChmdW5jdGlvbiAocngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKGZpbHRlcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IFppcFBhdGhcbiAgICAgICAgICAgIHppcFBhdGggPSB6aXBQYXRoID8gZml4UGF0aCh6aXBQYXRoKSA6IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgcGF0aCBmaXJzdFxuICAgICAgICAgICAgbG9jYWxQYXRoID0gcHRoLm5vcm1hbGl6ZShsb2NhbFBhdGgpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBmaWxldG9vbHMuZnMub3Blbihsb2NhbFBhdGgsIFwiclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIFV0aWxzLkVycm9ycy5GSUxFX05PVF9GT1VORC5yZXBsYWNlKFwiJXNcIiwgbG9jYWxQYXRoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGZpbGV0b29scy5maW5kRmlsZXMobG9jYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVwYXRoID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwdGgucmVsYXRpdmUobG9jYWxQYXRoLCBmaWxlcGF0aCkuc3BsaXQoXCJcXFxcXCIpLmpvaW4oXCIvXCIpOyAvL3dpbmRvd3MgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vcm1hbGl6ZShcIk5GRFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teXFx4MjAtXFx4N0VdL2csIFwiXCIpOyAvLyBhY2NlbnQgZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMuc3RhdChmaWxlcGF0aCwgZnVuY3Rpb24gKGVyMCwgc3RhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcjApIGNhbGxiYWNrKHVuZGVmaW5lZCwgZXIwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy5yZWFkRmlsZShmaWxlcGF0aCwgZnVuY3Rpb24gKGVyMSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXIxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIGVyMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCArIHAsIGRhdGEsIFwiXCIsIHN0YXRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZpbGUoemlwUGF0aCArIHAgKyBcIi9cIiwgQnVmZmVyLmFsbG9jKDApLCBcIlwiLCBzdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsUGF0aCAtIHBhdGggd2hlcmUgZmlsZXMgd2lsbCBiZSBleHRyYWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gb3B0aW9uYWwgcHJvcGVydGllc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuemlwUGF0aCAtIG9wdGlvbmFsIHBhdGggaW5zaWRlIHppcFxuICAgICAgICAgKiBAcGFyYW0ge3JlZ2V4cCwgZnVuY3Rpb259IHByb3BzLmZpbHRlciAtIFJlZ0V4cCBvciBGdW5jdGlvbiBpZiBmaWxlcyBtYXRjaCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTG9jYWxGb2xkZXJQcm9taXNlOiBmdW5jdGlvbiAoLypTdHJpbmcqLyBsb2NhbFBhdGgsIC8qIG9iamVjdCAqLyBwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZpbHRlciwgemlwUGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTG9jYWxGb2xkZXJBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXRoLFxuICAgICAgICAgICAgICAgICAgICAoZG9uZSwgZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB6aXBQYXRoLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gY3JlYXRlIGEgZW50cnkgKGZpbGUgb3IgZGlyZWN0b3J5KSBpbiB0aGUgemlwIGZpbGUuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0aGUgZW50cnlOYW1lIG11c3QgZW5kIGluIC8gYW5kIGEgbnVsbCBidWZmZXIgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAgICAgICAgKiBDb21tZW50IGFuZCBhdHRyaWJ1dGVzIGFyZSBvcHRpb25hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7QnVmZmVyIHwgc3RyaW5nfSBjb250ZW50IC0gZmlsZSBjb250ZW50IGFzIGJ1ZmZlciBvciB1dGY4IGNvZGVkIHN0cmluZ1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWVudCAtIGZpbGUgY29tbWVudFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlciB8IG9iamVjdH0gYXR0ciAtIG51bWJlciBhcyB1bml4IGZpbGUgcGVybWlzc2lvbnMsIG9iamVjdCBhcyBmaWxlc3lzdGVtIFN0YXRzIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZTogZnVuY3Rpb24gKC8qKlN0cmluZyovIGVudHJ5TmFtZSwgLyoqQnVmZmVyKi8gY29udGVudCwgLyoqU3RyaW5nKi8gY29tbWVudCwgLyoqTnVtYmVyKi8gYXR0cikge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gZ2V0RW50cnkoZW50cnlOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGVudHJ5ICE9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIHByZXBhcmUgbmV3IGVudHJ5XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IFppcEVudHJ5KCk7XG4gICAgICAgICAgICAgICAgZW50cnkuZW50cnlOYW1lID0gZW50cnlOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkuY29tbWVudCA9IGNvbW1lbnQgfHwgXCJcIjtcblxuICAgICAgICAgICAgY29uc3QgaXNTdGF0ID0gXCJvYmplY3RcIiA9PT0gdHlwZW9mIGF0dHIgJiYgYXR0ciBpbnN0YW5jZW9mIGZpbGV0b29scy5mcy5TdGF0cztcblxuICAgICAgICAgICAgLy8gbGFzdCBtb2RpZmljYXRpb24gdGltZSBmcm9tIGZpbGUgc3RhdHNcbiAgICAgICAgICAgIGlmIChpc1N0YXQpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5oZWFkZXIudGltZSA9IGF0dHIubXRpbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCBmaWxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgdmFyIGZpbGVhdHRyID0gZW50cnkuaXNEaXJlY3RvcnkgPyAweDEwIDogMDsgLy8gKE1TLURPUyBkaXJlY3RvcnkgZmxhZylcblxuICAgICAgICAgICAgLy8gZXh0ZW5kZWQgYXR0cmlidXRlcyBmaWVsZCBmb3IgVW5peFxuICAgICAgICAgICAgLy8gc2V0IGZpbGUgdHlwZSBlaXRoZXIgU19JRkRJUiAvIFNfSUZSRUdcbiAgICAgICAgICAgIGxldCB1bml4ID0gZW50cnkuaXNEaXJlY3RvcnkgPyAweDQwMDAgOiAweDgwMDA7XG5cbiAgICAgICAgICAgIGlmIChpc1N0YXQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxlIGF0dHJpYnV0ZXMgZnJvbSBmaWxlIHN0YXRzXG4gICAgICAgICAgICAgICAgdW5peCB8PSAweGZmZiAmIGF0dHIubW9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRyIGZyb20gZ2l2ZW4gYXR0ciB2YWx1ZXNcbiAgICAgICAgICAgICAgICB1bml4IHw9IDB4ZmZmICYgYXR0cjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXM6XG4gICAgICAgICAgICAgICAgdW5peCB8PSBlbnRyeS5pc0RpcmVjdG9yeSA/IDBvNzU1IDogMG82NDQ7IC8vIHBlcm1pc3Npb25zIChkcnd4ci14ci14KSBvciAoLXItd3ItLXItLSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsZWF0dHIgPSAoZmlsZWF0dHIgfCAodW5peCA8PCAxNikpID4+PiAwOyAvLyBhZGQgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICBlbnRyeS5hdHRyID0gZmlsZWF0dHI7XG5cbiAgICAgICAgICAgIGVudHJ5LnNldERhdGEoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZSkgX3ppcC5zZXRFbnRyeShlbnRyeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgWmlwRW50cnkgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIGluc2lkZSB0aGUgYXJjaGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcCA/IF96aXAuZW50cmllcyA6IFtdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgWmlwRW50cnkgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZmlsZSBvciBmb2xkZXIgc3BlY2lmaWVkIGJ5IGBgbmFtZWBgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIFppcEVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKC8qKlN0cmluZyovIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyeShuYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFbnRyeUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5nZXRFbnRyeUNvdW50KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIGdpdmVuIGVudHJ5IHRvIHRoZSBnaXZlbiB0YXJnZXRQYXRoXG4gICAgICAgICAqIElmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSBpbnNpZGUgdGhlIGFyY2hpdmUsIHRoZSBlbnRpcmUgZGlyZWN0b3J5IGFuZCBpdCdzIHN1YmRpcmVjdG9yaWVzIHdpbGwgYmUgZXh0cmFjdGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeSBaaXBFbnRyeSBvYmplY3Qgb3IgU3RyaW5nIHdpdGggdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZW50cnlcbiAgICAgICAgICogQHBhcmFtIHRhcmdldFBhdGggVGFyZ2V0IGZvbGRlciB3aGVyZSB0byB3cml0ZSB0aGUgZmlsZVxuICAgICAgICAgKiBAcGFyYW0gbWFpbnRhaW5FbnRyeVBhdGggSWYgbWFpbnRhaW5FbnRyeVBhdGggaXMgdHJ1ZSBhbmQgdGhlIGVudHJ5IGlzIGluc2lkZSBhIGZvbGRlciwgdGhlIGVudHJ5IGZvbGRlclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBjcmVhdGVkIGluIHRhcmdldFBhdGggYXMgd2VsbC4gRGVmYXVsdCBpcyBUUlVFXG4gICAgICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdGhlIGZpbGUgYWxyZWFkeSBleGlzdHMgYXQgdGhlIHRhcmdldCBwYXRoLCB0aGUgZmlsZSB3aWxsIGJlIG92ZXJ3cml0ZW4gaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gVGhlIGZpbGUgd2lsbCBiZSBzZXQgYXMgdGhlIHBlcm1pc3Npb24gZnJvbSB0aGUgZW50cnkgaWYgdGhpcyBpcyB0cnVlLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgRkFMU0VcbiAgICAgICAgICogQHBhcmFtIG91dEZpbGVOYW1lIFN0cmluZyBJZiBzZXQgd2lsbCBvdmVycmlkZSB0aGUgZmlsZW5hbWUgb2YgdGhlIGV4dHJhY3RlZCBmaWxlIChPbmx5IHdvcmtzIGlmIHRoZSBlbnRyeSBpcyBhIGZpbGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIC8qKk9iamVjdCovIGVudHJ5LFxuICAgICAgICAgICAgLyoqU3RyaW5nKi8gdGFyZ2V0UGF0aCxcbiAgICAgICAgICAgIC8qKkJvb2xlYW4qLyBtYWludGFpbkVudHJ5UGF0aCxcbiAgICAgICAgICAgIC8qKkJvb2xlYW4qLyBvdmVyd3JpdGUsXG4gICAgICAgICAgICAvKipCb29sZWFuKi8ga2VlcE9yaWdpbmFsUGVybWlzc2lvbixcbiAgICAgICAgICAgIC8qKlN0cmluZyoqLyBvdXRGaWxlTmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG92ZXJ3cml0ZSA9IGdldF9Cb29sKG92ZXJ3cml0ZSwgZmFsc2UpO1xuICAgICAgICAgICAga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA9IGdldF9Cb29sKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIGZhbHNlKTtcbiAgICAgICAgICAgIG1haW50YWluRW50cnlQYXRoID0gZ2V0X0Jvb2wobWFpbnRhaW5FbnRyeVBhdGgsIHRydWUpO1xuICAgICAgICAgICAgb3V0RmlsZU5hbWUgPSBnZXRfU3RyKG91dEZpbGVOYW1lLCBnZXRfU3RyKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIHVuZGVmaW5lZCkpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdldEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuTk9fRU5UUlkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW50cnlOYW1lID0gY2Fub25pY2FsKGl0ZW0uZW50cnlOYW1lKTtcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNhbml0aXplKHRhcmdldFBhdGgsIG91dEZpbGVOYW1lICYmICFpdGVtLmlzRGlyZWN0b3J5ID8gb3V0RmlsZU5hbWUgOiBtYWludGFpbkVudHJ5UGF0aCA/IGVudHJ5TmFtZSA6IHB0aC5iYXNlbmFtZShlbnRyeU5hbWUpKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0uaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfemlwLmdldEVudHJ5Q2hpbGRyZW4oaXRlbSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzRGlyZWN0b3J5KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gY2hpbGQuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY2Fub25pY2FsKGNoaWxkLmVudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBzYW5pdGl6ZSh0YXJnZXRQYXRoLCBtYWludGFpbkVudHJ5UGF0aCA/IG5hbWUgOiBwdGguYmFzZW5hbWUobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZUF0dHIgPSBrZWVwT3JpZ2luYWxQZXJtaXNzaW9uID8gY2hpbGQuaGVhZGVyLmZpbGVBdHRyIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG8oY2hpbGROYW1lLCBjb250ZW50LCBvdmVyd3JpdGUsIGZpbGVBdHRyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBpdGVtLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmICghY29udGVudCkgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSk7XG5cbiAgICAgICAgICAgIGlmIChmaWxldG9vbHMuZnMuZXhpc3RzU3luYyh0YXJnZXQpICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHMuRXJyb3JzLkNBTlRfT1ZFUlJJREUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG8odGFyZ2V0LCBjb250ZW50LCBvdmVyd3JpdGUsIGZpbGVBdHRyKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3QgdGhlIGFyY2hpdmVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChwYXNzKSB7XG4gICAgICAgICAgICBpZiAoIV96aXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGVudHJ5IGluIF96aXAuZW50cmllcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBfemlwLmVudHJpZXNbZW50cnldLmdldERhdGEocGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0cmFjdHMgdGhlIGVudGlyZSBhcmNoaXZlIHRvIHRoZSBnaXZlbiBsb2NhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0UGF0aCBUYXJnZXQgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIG92ZXJ3cml0ZSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKiBAcGFyYW0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiBUaGUgZmlsZSB3aWxsIGJlIHNldCBhcyB0aGUgcGVybWlzc2lvbiBmcm9tIHRoZSBlbnRyeSBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEFsbFRvOiBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gdGFyZ2V0UGF0aCwgLyoqQm9vbGVhbiovIG92ZXJ3cml0ZSwgLyoqQm9vbGVhbiovIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG4gICAgICAgICAgICBvdmVyd3JpdGUgPSBnZXRfQm9vbChvdmVyd3JpdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhc3MgPSBnZXRfU3RyKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIHBhc3MpO1xuICAgICAgICAgICAga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA9IGdldF9Cb29sKGtlZXBPcmlnaW5hbFBlcm1pc3Npb24sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICghX3ppcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuTk9fWklQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF96aXAuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeU5hbWUgPSBzYW5pdGl6ZSh0YXJnZXRQYXRoLCBjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLm1ha2VEaXIoZW50cnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGVudHJ5LmdldERhdGEocGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuQ0FOVF9FWFRSQUNUX0ZJTEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZmlsZXRvb2xzLndyaXRlRmlsZVRvKGVudHJ5TmFtZSwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0cik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXRvb2xzLmZzLnV0aW1lc1N5bmMoZW50cnlOYW1lLCBlbnRyeS5oZWFkZXIudGltZSwgZW50cnkuaGVhZGVyLnRpbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHMuRXJyb3JzLkNBTlRfRVhUUkFDVF9GSUxFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXN5bmNocm9ub3VzIGV4dHJhY3RBbGxUb1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0UGF0aCBUYXJnZXQgbG9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIG92ZXJ3cml0ZSBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBhdCB0aGUgdGFyZ2V0IHBhdGgsIHRoZSBmaWxlIHdpbGwgYmUgb3ZlcndyaXRlbiBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKiBAcGFyYW0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiBUaGUgZmlsZSB3aWxsIGJlIHNldCBhcyB0aGUgcGVybWlzc2lvbiBmcm9tIHRoZSBlbnRyeSBpZiB0aGlzIGlzIHRydWUuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBGQUxTRVxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhbGwgZW50cmllcyBhcmUgZXh0cmFjdGVkIHN1Y2Nlc3NmdWxseSBvciBhbnkgZXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdEFsbFRvQXN5bmM6IGZ1bmN0aW9uICgvKipTdHJpbmcqLyB0YXJnZXRQYXRoLCAvKipCb29sZWFuKi8gb3ZlcndyaXRlLCAvKipCb29sZWFuKi8ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiwgLyoqRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgb3ZlcndyaXRlID0gZ2V0X0Jvb2wob3ZlcndyaXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPT09IFwiZnVuY3Rpb25cIiAmJiAhY2FsbGJhY2spIGNhbGxiYWNrID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbjtcbiAgICAgICAgICAgIGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPSBnZXRfQm9vbChrZWVwT3JpZ2luYWxQZXJtaXNzaW9uLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV96aXApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoVXRpbHMuRXJyb3JzLk5PX1pJUCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0UGF0aCA9IHB0aC5yZXNvbHZlKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgLy8gY29udmVydCBlbnRyeU5hbWUgdG9cbiAgICAgICAgICAgIGNvbnN0IGdldFBhdGggPSAoZW50cnkpID0+IHNhbml0aXplKHRhcmdldFBhdGgsIHB0aC5ub3JtYWxpemUoY2Fub25pY2FsKGVudHJ5LmVudHJ5TmFtZS50b1N0cmluZygpKSkpO1xuICAgICAgICAgICAgY29uc3QgZ2V0RXJyb3IgPSAobXNnLCBmaWxlKSA9PiBuZXcgRXJyb3IobXNnICsgJzogXCInICsgZmlsZSArICdcIicpO1xuXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBkaXJlY3RvcmllcyBmcm9tIGZpbGVzXG4gICAgICAgICAgICBjb25zdCBkaXJFbnRyaWVzID0gW107XG4gICAgICAgICAgICBjb25zdCBmaWxlRW50cmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF96aXAuZW50cmllcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyRW50cmllcy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVFbnRyaWVzLmFkZChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBlbnRyaWVzIGZpcnN0IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIC8vIHRoaXMgcHJldmVudHMgcmFjZSBjb25kaXRpb24gYW5kIGFzc3VyZXMgZm9sZGVycyBhcmUgdGhlcmUgYmVmb3JlIHdyaXRpbmcgZmlsZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGlyRW50cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpclBhdGggPSBnZXRQYXRoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmV2ZXJzZSBvcGVyYXRpb24gZm9yIGF0dHIgZGVwZW5kIG9uIG1ldGhvZCBhZGRGaWxlKClcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJBdHRyID0ga2VlcE9yaWdpbmFsUGVybWlzc2lvbiA/IGVudHJ5LmhlYWRlci5maWxlQXR0ciA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMubWFrZURpcihkaXJQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpckF0dHIpIGZpbGV0b29scy5mcy5jaG1vZFN5bmMoZGlyUGF0aCwgZGlyQXR0cik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHVuaXggdGltZXN0YW1wIHdpbGwgY2hhbmdlIGlmIGZpbGVzIGFyZSBsYXRlciBhZGRlZCB0byBmb2xkZXIsIGJ1dCBzdGlsbFxuICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMuZnMudXRpbWVzU3luYyhkaXJQYXRoLCBlbnRyeS5oZWFkZXIudGltZSwgZW50cnkuaGVhZGVyLnRpbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGdldEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBmb2xkZXJcIiwgZGlyUGF0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgd3JhcHBlciwgZm9yIHNvbWUgaG91c2Uga2VlcGluZ1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUVudHJpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZmlsZSBlbnRyaWVzIGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGZpbGVFbnRyaWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnlOYW1lID0gcHRoLm5vcm1hbGl6ZShjYW5vbmljYWwoZW50cnkuZW50cnlOYW1lLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHNhbml0aXplKHRhcmdldFBhdGgsIGVudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgZW50cnkuZ2V0RGF0YUFzeW5jKGZ1bmN0aW9uIChjb250ZW50LCBlcnJfMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihlcnJfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFV0aWxzLkVycm9ycy5DQU5UX0VYVFJBQ1RfRklMRSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJldmVyc2Ugb3BlcmF0aW9uIGZvciBhdHRyIGRlcGVuZCBvbiBtZXRob2QgYWRkRmlsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlQXR0ciA9IGtlZXBPcmlnaW5hbFBlcm1pc3Npb24gPyBlbnRyeS5oZWFkZXIuZmlsZUF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxldG9vbHMud3JpdGVGaWxlVG9Bc3luYyhmaWxlUGF0aCwgY29udGVudCwgb3ZlcndyaXRlLCBmaWxlQXR0ciwgZnVuY3Rpb24gKHN1Y2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZ2V0RXJyb3IoXCJVbmFibGUgdG8gd3JpdGUgZmlsZVwiLCBmaWxlUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy5mcy51dGltZXMoZmlsZVBhdGgsIGVudHJ5LmhlYWRlci50aW1lLCBlbnRyeS5oZWFkZXIudGltZSwgZnVuY3Rpb24gKGVycl8yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJfMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZ2V0RXJyb3IoXCJVbmFibGUgdG8gc2V0IHRpbWVzXCIsIGZpbGVQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUVudHJpZXMuZGVsZXRlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgaWYgaXQgd2FzIGxhc3QgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIGlmIGZpbGVFbnRyaWVzIHdhcyBlbXB0eVxuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZXMgdGhlIG5ld2x5IGNyZWF0ZWQgemlwIGZpbGUgdG8gZGlzayBhdCB0aGUgc3BlY2lmaWVkIGxvY2F0aW9uIG9yIGlmIGEgemlwIHdhcyBvcGVuZWQgYW5kIG5vIGBgdGFyZ2V0RmlsZU5hbWVgYCBpcyBwcm92aWRlZCwgaXQgd2lsbCBvdmVyd3JpdGUgdGhlIG9wZW5lZCB6aXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRhcmdldEZpbGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgd3JpdGVaaXA6IGZ1bmN0aW9uICgvKipTdHJpbmcqLyB0YXJnZXRGaWxlTmFtZSwgLyoqRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldEZpbGVOYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXJnZXRGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RmlsZU5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSAmJiBvcHRzLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RmlsZU5hbWUgPSBvcHRzLmZpbGVuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgemlwRGF0YSA9IF96aXAuY29tcHJlc3NUb0J1ZmZlcigpO1xuICAgICAgICAgICAgaWYgKHppcERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2sgPSBmaWxldG9vbHMud3JpdGVGaWxlVG8odGFyZ2V0RmlsZU5hbWUsIHppcERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2soIW9rID8gbmV3IEVycm9yKFwiZmFpbGVkXCIpIDogbnVsbCwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JpdGVaaXBQcm9taXNlOiBmdW5jdGlvbiAoLyoqU3RyaW5nKi8gdGFyZ2V0RmlsZU5hbWUsIC8qIG9iamVjdCAqLyBwcm9wcykge1xuICAgICAgICAgICAgY29uc3QgeyBvdmVyd3JpdGUsIHBlcm0gfSA9IE9iamVjdC5hc3NpZ24oeyBvdmVyd3JpdGU6IHRydWUgfSwgcHJvcHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlsZSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSAmJiBvcHRzLmZpbGVuYW1lKSB0YXJnZXRGaWxlTmFtZSA9IG9wdHMuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRGaWxlTmFtZSkgcmVqZWN0KFwiQURNLVpJUDogWklQIEZpbGUgTmFtZSBNaXNzaW5nXCIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy50b0J1ZmZlclByb21pc2UoKS50aGVuKCh6aXBEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IChkb25lKSA9PiAoZG9uZSA/IHJlc29sdmUoZG9uZSkgOiByZWplY3QoXCJBRE0tWklQOiBXYXNuJ3QgYWJsZSB0byB3cml0ZSB6aXAgZmlsZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGV0b29scy53cml0ZUZpbGVUb0FzeW5jKHRhcmdldEZpbGVOYW1lLCB6aXBEYXRhLCBvdmVyd3JpdGUsIHBlcm0sIHJldCk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvQnVmZmVyUHJvbWlzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBfemlwLnRvQXN5bmNCdWZmZXIocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBlbnRpcmUgemlwIGZpbGUgYXMgYSBCdWZmZXIgb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyXG4gICAgICAgICAqL1xuICAgICAgICB0b0J1ZmZlcjogZnVuY3Rpb24gKC8qKkZ1bmN0aW9uPSovIG9uU3VjY2VzcywgLyoqRnVuY3Rpb249Ki8gb25GYWlsLCAvKipGdW5jdGlvbj0qLyBvbkl0ZW1TdGFydCwgLyoqRnVuY3Rpb249Ki8gb25JdGVtRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIF96aXAudG9Bc3luY0J1ZmZlcihvblN1Y2Nlc3MsIG9uRmFpbCwgb25JdGVtU3RhcnQsIG9uSXRlbUVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3ppcC5jb21wcmVzc1RvQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJVdGlscyIsInJlcXVpcmUiLCJwdGgiLCJaaXBFbnRyeSIsIlppcEZpbGUiLCJnZXRfQm9vbCIsInZhbCIsImRlZiIsImdldF9TdHIiLCJkZWZhdWx0T3B0aW9ucyIsIm5vU29ydCIsInJlYWRFbnRyaWVzIiwibWV0aG9kIiwiQ29uc3RhbnRzIiwiTk9ORSIsImZzIiwibW9kdWxlIiwiZXhwb3J0cyIsImlucHV0Iiwib3B0aW9ucyIsImluQnVmZmVyIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsIlVpbnQ4QXJyYXkiLCJ1bmRlZmluZWQiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkJVRkZFUiIsImZpbGV0b29scyIsImV4aXN0c1N5bmMiLCJGSUxFIiwiZmlsZW5hbWUiLCJyZWFkRmlsZVN5bmMiLCJFcnJvciIsIkVycm9ycyIsIklOVkFMSURfRklMRU5BTUUiLCJfemlwIiwiY2Fub25pY2FsIiwic2FuaXRpemUiLCJnZXRFbnRyeSIsImVudHJ5IiwiaXRlbSIsImVudHJ5TmFtZSIsImhlYWRlciIsImZpeFBhdGgiLCJ6aXBQYXRoIiwiam9pbiIsIm5vcm1hbGl6ZSIsInNlcCIsInBvc2l4Iiwic3BsaXQiLCJyZWFkRmlsZSIsInBhc3MiLCJnZXREYXRhIiwicmVhZEZpbGVBc3luYyIsImNhbGxiYWNrIiwiZ2V0RGF0YUFzeW5jIiwicmVhZEFzVGV4dCIsImVuY29kaW5nIiwiZGF0YSIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVhZEFzVGV4dEFzeW5jIiwiZXJyIiwiZGVsZXRlRmlsZSIsImRlbGV0ZUVudHJ5IiwiYWRkWmlwQ29tbWVudCIsImNvbW1lbnQiLCJnZXRaaXBDb21tZW50IiwiYWRkWmlwRW50cnlDb21tZW50IiwiZ2V0WmlwRW50cnlDb21tZW50IiwidXBkYXRlRmlsZSIsImNvbnRlbnQiLCJzZXREYXRhIiwiYWRkTG9jYWxGaWxlIiwibG9jYWxQYXRoIiwiemlwTmFtZSIsInAiLCJwb3AiLCJfYXR0ciIsInN0YXRTeW5jIiwiYWRkRmlsZSIsIkZJTEVfTk9UX0ZPVU5EIiwicmVwbGFjZSIsImFkZExvY2FsRm9sZGVyIiwiZmlsdGVyIiwiYXR0ciIsIlJlZ0V4cCIsInJ4IiwidGVzdCIsIml0ZW1zIiwiZmluZEZpbGVzIiwic2VsZiIsImZvckVhY2giLCJmaWxlcGF0aCIsInJlbGF0aXZlIiwic3RhdHMiLCJpc0ZpbGUiLCJhbGxvYyIsImFkZExvY2FsRm9sZGVyQXN5bmMiLCJvcGVuIiwiY29kZSIsImkiLCJuZXh0Iiwic3RhdCIsImVyMCIsImVyMSIsInByb2Nlc3MiLCJuZXh0VGljayIsImFkZExvY2FsRm9sZGVyUHJvbWlzZSIsInByb3BzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkb25lIiwidXBkYXRlIiwiaXNTdGF0IiwiU3RhdHMiLCJ0aW1lIiwibXRpbWUiLCJmaWxlYXR0ciIsImlzRGlyZWN0b3J5IiwidW5peCIsIm1vZGUiLCJzZXRFbnRyeSIsImdldEVudHJpZXMiLCJlbnRyaWVzIiwibmFtZSIsImdldEVudHJ5Q291bnQiLCJleHRyYWN0RW50cnlUbyIsInRhcmdldFBhdGgiLCJtYWludGFpbkVudHJ5UGF0aCIsIm92ZXJ3cml0ZSIsImtlZXBPcmlnaW5hbFBlcm1pc3Npb24iLCJvdXRGaWxlTmFtZSIsIk5PX0VOVFJZIiwidGFyZ2V0IiwiYmFzZW5hbWUiLCJjaGlsZHJlbiIsImdldEVudHJ5Q2hpbGRyZW4iLCJjaGlsZCIsIkNBTlRfRVhUUkFDVF9GSUxFIiwiY2hpbGROYW1lIiwiZmlsZUF0dHIiLCJ3cml0ZUZpbGVUbyIsIkNBTlRfT1ZFUlJJREUiLCJleHRyYWN0QWxsVG8iLCJOT19aSVAiLCJtYWtlRGlyIiwidXRpbWVzU3luYyIsImV4dHJhY3RBbGxUb0FzeW5jIiwiZ2V0UGF0aCIsImdldEVycm9yIiwibXNnIiwiZmlsZSIsImRpckVudHJpZXMiLCJmaWxlRW50cmllcyIsIlNldCIsImUiLCJwdXNoIiwiYWRkIiwiZGlyUGF0aCIsImRpckF0dHIiLCJjaG1vZFN5bmMiLCJlciIsInNpemUiLCJ2YWx1ZXMiLCJmaWxlUGF0aCIsImVycl8xIiwid3JpdGVGaWxlVG9Bc3luYyIsInN1Y2MiLCJ1dGltZXMiLCJlcnJfMiIsImRlbGV0ZSIsIndyaXRlWmlwIiwidGFyZ2V0RmlsZU5hbWUiLCJhcmd1bWVudHMiLCJ6aXBEYXRhIiwiY29tcHJlc3NUb0J1ZmZlciIsIm9rIiwid3JpdGVaaXBQcm9taXNlIiwicGVybSIsInRvQnVmZmVyUHJvbWlzZSIsInRoZW4iLCJyZXQiLCJ0b0FzeW5jQnVmZmVyIiwidG9CdWZmZXIiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJvbkl0ZW1TdGFydCIsIm9uSXRlbUVuZCIsInZhbHVlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/adm-zip.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/headers/entryHeader.js":
/*!*****************************************************!*\
  !*** ./node_modules/adm-zip/headers/entryHeader.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Utils = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/adm-zip/util/index.js\"), Constants = Utils.Constants;\n/* The central directory file header */ module.exports = function() {\n    var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;\n    _verMade |= Utils.isWin ? 0x0a00 : 0x0300;\n    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.\n    // Without it file names may be corrupted for other apps when file names use unicode chars\n    _flags |= Constants.FLG_EFS;\n    var _dataHeader = {};\n    function setTime(val1) {\n        val1 = new Date(val1);\n        _time = (val1.getFullYear() - 1980 & 0x7f) << 25 | // b09-16 years from 1980\n        val1.getMonth() + 1 << 21 | // b05-08 month\n        val1.getDate() << 16 | // b00-04 hour\n        // 2 bytes time\n        val1.getHours() << 11 | // b11-15 hour\n        val1.getMinutes() << 5 | // b05-10 minute\n        val1.getSeconds() >> 1; // b00-04 seconds divided by 2\n    }\n    setTime(+new Date());\n    return {\n        get made () {\n            return _verMade;\n        },\n        set made (val){\n            _verMade = val;\n        },\n        get version () {\n            return _version;\n        },\n        set version (val){\n            _version = val;\n        },\n        get flags () {\n            return _flags;\n        },\n        set flags (val){\n            _flags = val;\n        },\n        get method () {\n            return _method;\n        },\n        set method (val){\n            switch(val){\n                case Constants.STORED:\n                    this.version = 10;\n                case Constants.DEFLATED:\n                default:\n                    this.version = 20;\n            }\n            _method = val;\n        },\n        get time () {\n            return new Date((_time >> 25 & 0x7f) + 1980, (_time >> 21 & 0x0f) - 1, _time >> 16 & 0x1f, _time >> 11 & 0x1f, _time >> 5 & 0x3f, (_time & 0x1f) << 1);\n        },\n        set time (val){\n            setTime(val);\n        },\n        get crc () {\n            return _crc;\n        },\n        set crc (val){\n            _crc = Math.max(0, val) >>> 0;\n        },\n        get compressedSize () {\n            return _compressedSize;\n        },\n        set compressedSize (val){\n            _compressedSize = Math.max(0, val) >>> 0;\n        },\n        get size () {\n            return _size;\n        },\n        set size (val){\n            _size = Math.max(0, val) >>> 0;\n        },\n        get fileNameLength () {\n            return _fnameLen;\n        },\n        set fileNameLength (val){\n            _fnameLen = val;\n        },\n        get extraLength () {\n            return _extraLen;\n        },\n        set extraLength (val){\n            _extraLen = val;\n        },\n        get commentLength () {\n            return _comLen;\n        },\n        set commentLength (val){\n            _comLen = val;\n        },\n        get diskNumStart () {\n            return _diskStart;\n        },\n        set diskNumStart (val){\n            _diskStart = Math.max(0, val) >>> 0;\n        },\n        get inAttr () {\n            return _inattr;\n        },\n        set inAttr (val){\n            _inattr = Math.max(0, val) >>> 0;\n        },\n        get attr () {\n            return _attr;\n        },\n        set attr (val){\n            _attr = Math.max(0, val) >>> 0;\n        },\n        // get Unix file permissions\n        get fileAttr () {\n            return _attr ? (_attr >>> 0 | 0) >> 16 & 0xfff : 0;\n        },\n        get offset () {\n            return _offset;\n        },\n        set offset (val){\n            _offset = Math.max(0, val) >>> 0;\n        },\n        get encripted () {\n            return (_flags & 1) === 1;\n        },\n        get entryHeaderSize () {\n            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n        },\n        get realDataOffset () {\n            return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;\n        },\n        get dataHeader () {\n            return _dataHeader;\n        },\n        loadDataHeaderFromBinary: function(/*Buffer*/ input) {\n            var data = input.slice(_offset, _offset + Constants.LOCHDR);\n            // 30 bytes and should start with \"PK\\003\\004\"\n            if (data.readUInt32LE(0) !== Constants.LOCSIG) {\n                throw new Error(Utils.Errors.INVALID_LOC);\n            }\n            _dataHeader = {\n                // version needed to extract\n                version: data.readUInt16LE(Constants.LOCVER),\n                // general purpose bit flag\n                flags: data.readUInt16LE(Constants.LOCFLG),\n                // compression method\n                method: data.readUInt16LE(Constants.LOCHOW),\n                // modification time (2 bytes time, 2 bytes date)\n                time: data.readUInt32LE(Constants.LOCTIM),\n                // uncompressed file crc-32 value\n                crc: data.readUInt32LE(Constants.LOCCRC),\n                // compressed size\n                compressedSize: data.readUInt32LE(Constants.LOCSIZ),\n                // uncompressed size\n                size: data.readUInt32LE(Constants.LOCLEN),\n                // filename length\n                fnameLen: data.readUInt16LE(Constants.LOCNAM),\n                // extra field length\n                extraLen: data.readUInt16LE(Constants.LOCEXT)\n            };\n        },\n        loadFromBinary: function(/*Buffer*/ data) {\n            // data should be 46 bytes and start with \"PK 01 02\"\n            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {\n                throw new Error(Utils.Errors.INVALID_CEN);\n            }\n            // version made by\n            _verMade = data.readUInt16LE(Constants.CENVEM);\n            // version needed to extract\n            _version = data.readUInt16LE(Constants.CENVER);\n            // encrypt, decrypt flags\n            _flags = data.readUInt16LE(Constants.CENFLG);\n            // compression method\n            _method = data.readUInt16LE(Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            _time = data.readUInt32LE(Constants.CENTIM);\n            // uncompressed file crc-32 value\n            _crc = data.readUInt32LE(Constants.CENCRC);\n            // compressed size\n            _compressedSize = data.readUInt32LE(Constants.CENSIZ);\n            // uncompressed size\n            _size = data.readUInt32LE(Constants.CENLEN);\n            // filename length\n            _fnameLen = data.readUInt16LE(Constants.CENNAM);\n            // extra field length\n            _extraLen = data.readUInt16LE(Constants.CENEXT);\n            // file comment length\n            _comLen = data.readUInt16LE(Constants.CENCOM);\n            // volume number start\n            _diskStart = data.readUInt16LE(Constants.CENDSK);\n            // internal file attributes\n            _inattr = data.readUInt16LE(Constants.CENATT);\n            // external file attributes\n            _attr = data.readUInt32LE(Constants.CENATX);\n            // LOC header offset\n            _offset = data.readUInt32LE(Constants.CENOFF);\n        },\n        dataHeaderToBinary: function() {\n            // LOC header size (30 bytes)\n            var data = Buffer.alloc(Constants.LOCHDR);\n            // \"PK\\003\\004\"\n            data.writeUInt32LE(Constants.LOCSIG, 0);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.LOCVER);\n            // general purpose bit flag\n            data.writeUInt16LE(_flags, Constants.LOCFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.LOCHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.LOCTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.LOCCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.LOCLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);\n            // extra field length\n            data.writeUInt16LE(_extraLen, Constants.LOCEXT);\n            return data;\n        },\n        entryHeaderToBinary: function() {\n            // CEN header size (46 bytes)\n            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);\n            // \"PK\\001\\002\"\n            data.writeUInt32LE(Constants.CENSIG, 0);\n            // version made by\n            data.writeUInt16LE(_verMade, Constants.CENVEM);\n            // version needed to extract\n            data.writeUInt16LE(_version, Constants.CENVER);\n            // encrypt, decrypt flags\n            data.writeUInt16LE(_flags, Constants.CENFLG);\n            // compression method\n            data.writeUInt16LE(_method, Constants.CENHOW);\n            // modification time (2 bytes time, 2 bytes date)\n            data.writeUInt32LE(_time, Constants.CENTIM);\n            // uncompressed file crc-32 value\n            data.writeUInt32LE(_crc, Constants.CENCRC);\n            // compressed size\n            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);\n            // uncompressed size\n            data.writeUInt32LE(_size, Constants.CENLEN);\n            // filename length\n            data.writeUInt16LE(_fnameLen, Constants.CENNAM);\n            // extra field length\n            data.writeUInt16LE(_extraLen, Constants.CENEXT);\n            // file comment length\n            data.writeUInt16LE(_comLen, Constants.CENCOM);\n            // volume number start\n            data.writeUInt16LE(_diskStart, Constants.CENDSK);\n            // internal file attributes\n            data.writeUInt16LE(_inattr, Constants.CENATT);\n            // external file attributes\n            data.writeUInt32LE(_attr, Constants.CENATX);\n            // LOC header offset\n            data.writeUInt32LE(_offset, Constants.CENOFF);\n            // fill all with\n            data.fill(0x00, Constants.CENHDR);\n            return data;\n        },\n        toJSON: function() {\n            const bytes = function(nr) {\n                return nr + \" bytes\";\n            };\n            return {\n                made: _verMade,\n                version: _version,\n                flags: _flags,\n                method: Utils.methodToString(_method),\n                time: this.time,\n                crc: \"0x\" + _crc.toString(16).toUpperCase(),\n                compressedSize: bytes(_compressedSize),\n                size: bytes(_size),\n                fileNameLength: bytes(_fnameLen),\n                extraLength: bytes(_extraLen),\n                commentLength: bytes(_comLen),\n                diskNumStart: _diskStart,\n                inAttr: _inattr,\n                attr: _attr,\n                offset: _offset,\n                entryHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)\n            };\n        },\n        toString: function() {\n            return JSON.stringify(this.toJSON(), null, \"\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL2VudHJ5SGVhZGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQywyREFBUyxHQUN6QkMsWUFBWUYsTUFBTUUsU0FBUztBQUUvQixxQ0FBcUMsR0FDckNDLE9BQU9DLE9BQU8sR0FBRztJQUNiLElBQUlDLFdBQVcsSUFDWEMsV0FBVyxJQUNYQyxTQUFTLEdBQ1RDLFVBQVUsR0FDVkMsUUFBUSxHQUNSQyxPQUFPLEdBQ1BDLGtCQUFrQixHQUNsQkMsUUFBUSxHQUNSQyxZQUFZLEdBQ1pDLFlBQVksR0FDWkMsVUFBVSxHQUNWQyxhQUFhLEdBQ2JDLFVBQVUsR0FDVkMsUUFBUSxHQUNSQyxVQUFVO0lBRWRkLFlBQVlMLE1BQU1vQixLQUFLLEdBQUcsU0FBUztJQUVuQyx5RkFBeUY7SUFDekYsMEZBQTBGO0lBQzFGYixVQUFVTCxVQUFVbUIsT0FBTztJQUUzQixJQUFJQyxjQUFjLENBQUM7SUFFbkIsU0FBU0MsUUFBUUMsSUFBRztRQUNoQkEsT0FBTSxJQUFJQyxLQUFLRDtRQUNmZixRQUNJLENBQUUsS0FBS2lCLFdBQVcsS0FBSyxPQUFRLElBQUcsS0FBTSxLQUFNLHlCQUF5QjtRQUNyRUYsS0FBSUcsUUFBUSxLQUFLLEtBQU0sS0FBTSxlQUFlO1FBQzdDSCxLQUFJSSxPQUFPLE1BQU0sS0FBTSxjQUFjO1FBQ3RDLGVBQWU7UUFDZEosS0FBSUssUUFBUSxNQUFNLEtBQU0sY0FBYztRQUN0Q0wsS0FBSU0sVUFBVSxNQUFNLElBQUssZ0JBQWdCO1FBQ3pDTixLQUFJTyxVQUFVLE1BQU0sR0FBSSw4QkFBOEI7SUFDL0Q7SUFFQVIsUUFBUSxDQUFDLElBQUlFO0lBRWIsT0FBTztRQUNILElBQUlPLFFBQU87WUFDUCxPQUFPM0I7UUFDWDtRQUNBLElBQUkyQixNQUFLUixJQUFLO1lBQ1ZuQixXQUFXbUI7UUFDZjtRQUVBLElBQUlTLFdBQVU7WUFDVixPQUFPM0I7UUFDWDtR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QUksQ0FBQyxNQUFNdEcsVUFBVW9ELE1BQU07WUFDaEMsT0FBT1E7UUFDWDtRQUVBMkMsUUFBUTtZQUNKLE1BQU1DLFFBQVEsU0FBVUMsRUFBRTtnQkFDdEIsT0FBT0EsS0FBSztZQUNoQjtZQUVBLE9BQU87Z0JBQ0gzRSxNQUFNM0I7Z0JBQ040QixTQUFTM0I7Z0JBQ1Q0QixPQUFPM0I7Z0JBQ1A0QixRQUFRbkMsTUFBTTRHLGNBQWMsQ0FBQ3BHO2dCQUM3QjhCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmQyxLQUFLLE9BQU83QixLQUFLbUcsUUFBUSxDQUFDLElBQUlDLFdBQVc7Z0JBQ3pDcEUsZ0JBQWdCZ0UsTUFBTS9GO2dCQUN0QmdDLE1BQU0rRCxNQUFNOUY7Z0JBQ1pnQyxnQkFBZ0I4RCxNQUFNN0Y7Z0JBQ3RCZ0MsYUFBYTZELE1BQU01RjtnQkFDbkJnQyxlQUFlNEQsTUFBTTNGO2dCQUNyQmdDLGNBQWMvQjtnQkFDZGdDLFFBQVEvQjtnQkFDUmdDLE1BQU0vQjtnQkFDTmlDLFFBQVFoQztnQkFDUmtDLGlCQUFpQnFELE1BQU14RyxVQUFVb0QsTUFBTSxHQUFHekMsWUFBWUMsWUFBWUM7WUFDdEU7UUFDSjtRQUVBOEYsVUFBVTtZQUNOLE9BQU9FLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUNQLE1BQU0sSUFBSSxNQUFNO1FBQy9DO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmRheUFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9hZG0temlwL2hlYWRlcnMvZW50cnlIZWFkZXIuanM/YzdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBDb25zdGFudHMgPSBVdGlscy5Db25zdGFudHM7XG5cbi8qIFRoZSBjZW50cmFsIGRpcmVjdG9yeSBmaWxlIGhlYWRlciAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJNYWRlID0gMjAsIC8vIHYyLjBcbiAgICAgICAgX3ZlcnNpb24gPSAxMCwgLy8gdjEuMFxuICAgICAgICBfZmxhZ3MgPSAwLFxuICAgICAgICBfbWV0aG9kID0gMCxcbiAgICAgICAgX3RpbWUgPSAwLFxuICAgICAgICBfY3JjID0gMCxcbiAgICAgICAgX2NvbXByZXNzZWRTaXplID0gMCxcbiAgICAgICAgX3NpemUgPSAwLFxuICAgICAgICBfZm5hbWVMZW4gPSAwLFxuICAgICAgICBfZXh0cmFMZW4gPSAwLFxuICAgICAgICBfY29tTGVuID0gMCxcbiAgICAgICAgX2Rpc2tTdGFydCA9IDAsXG4gICAgICAgIF9pbmF0dHIgPSAwLFxuICAgICAgICBfYXR0ciA9IDAsXG4gICAgICAgIF9vZmZzZXQgPSAwO1xuXG4gICAgX3Zlck1hZGUgfD0gVXRpbHMuaXNXaW4gPyAweDBhMDAgOiAweDAzMDA7XG5cbiAgICAvLyBTZXQgRUZTIGZsYWcgc2luY2UgZmlsZW5hbWUgYW5kIGNvbW1lbnQgZmllbGRzIGFyZSBhbGwgYnkgZGVmYXVsdCBlbmNvZGVkIHVzaW5nIFVURi04LlxuICAgIC8vIFdpdGhvdXQgaXQgZmlsZSBuYW1lcyBtYXkgYmUgY29ycnVwdGVkIGZvciBvdGhlciBhcHBzIHdoZW4gZmlsZSBuYW1lcyB1c2UgdW5pY29kZSBjaGFyc1xuICAgIF9mbGFncyB8PSBDb25zdGFudHMuRkxHX0VGUztcblxuICAgIHZhciBfZGF0YUhlYWRlciA9IHt9O1xuXG4gICAgZnVuY3Rpb24gc2V0VGltZSh2YWwpIHtcbiAgICAgICAgdmFsID0gbmV3IERhdGUodmFsKTtcbiAgICAgICAgX3RpbWUgPVxuICAgICAgICAgICAgKCgodmFsLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSAmIDB4N2YpIDw8IDI1KSB8IC8vIGIwOS0xNiB5ZWFycyBmcm9tIDE5ODBcbiAgICAgICAgICAgICgodmFsLmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAvLyBiMDUtMDggbW9udGhcbiAgICAgICAgICAgICh2YWwuZ2V0RGF0ZSgpIDw8IDE2KSB8IC8vIGIwMC0wNCBob3VyXG4gICAgICAgICAgICAvLyAyIGJ5dGVzIHRpbWVcbiAgICAgICAgICAgICh2YWwuZ2V0SG91cnMoKSA8PCAxMSkgfCAvLyBiMTEtMTUgaG91clxuICAgICAgICAgICAgKHZhbC5nZXRNaW51dGVzKCkgPDwgNSkgfCAvLyBiMDUtMTAgbWludXRlXG4gICAgICAgICAgICAodmFsLmdldFNlY29uZHMoKSA+PiAxKTsgLy8gYjAwLTA0IHNlY29uZHMgZGl2aWRlZCBieSAyXG4gICAgfVxuXG4gICAgc2V0VGltZSgrbmV3IERhdGUoKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgbWFkZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdmVyTWFkZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG1hZGUodmFsKSB7XG4gICAgICAgICAgICBfdmVyTWFkZSA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZlcnNpb24odmFsKSB7XG4gICAgICAgICAgICBfdmVyc2lvbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZmxhZ3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYWdzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZmxhZ3ModmFsKSB7XG4gICAgICAgICAgICBfZmxhZ3MgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWV0aG9kO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgbWV0aG9kKHZhbCkge1xuICAgICAgICAgICAgc3dpdGNoICh2YWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5TVE9SRUQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IDEwO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IDIwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21ldGhvZCA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgoKF90aW1lID4+IDI1KSAmIDB4N2YpICsgMTk4MCwgKChfdGltZSA+PiAyMSkgJiAweDBmKSAtIDEsIChfdGltZSA+PiAxNikgJiAweDFmLCAoX3RpbWUgPj4gMTEpICYgMHgxZiwgKF90aW1lID4+IDUpICYgMHgzZiwgKF90aW1lICYgMHgxZikgPDwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aW1lKHZhbCkge1xuICAgICAgICAgICAgc2V0VGltZSh2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjcmMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNyYyh2YWwpIHtcbiAgICAgICAgICAgIF9jcmMgPSBNYXRoLm1heCgwLCB2YWwpID4+PiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBjb21wcmVzc2VkU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcHJlc3NlZFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21wcmVzc2VkU2l6ZSh2YWwpIHtcbiAgICAgICAgICAgIF9jb21wcmVzc2VkU2l6ZSA9IE1hdGgubWF4KDAsIHZhbCkgPj4+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBzaXplKHZhbCkge1xuICAgICAgICAgICAgX3NpemUgPSBNYXRoLm1heCgwLCB2YWwpID4+PiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBmaWxlTmFtZUxlbmd0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZm5hbWVMZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmaWxlTmFtZUxlbmd0aCh2YWwpIHtcbiAgICAgICAgICAgIF9mbmFtZUxlbiA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZXh0cmFMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dHJhTGVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZXh0cmFMZW5ndGgodmFsKSB7XG4gICAgICAgICAgICBfZXh0cmFMZW4gPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGNvbW1lbnRMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbUxlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbW1lbnRMZW5ndGgodmFsKSB7XG4gICAgICAgICAgICBfY29tTGVuID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBkaXNrTnVtU3RhcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Rpc2tTdGFydDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGRpc2tOdW1TdGFydCh2YWwpIHtcbiAgICAgICAgICAgIF9kaXNrU3RhcnQgPSBNYXRoLm1heCgwLCB2YWwpID4+PiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBpbkF0dHIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2luYXR0cjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGluQXR0cih2YWwpIHtcbiAgICAgICAgICAgIF9pbmF0dHIgPSBNYXRoLm1heCgwLCB2YWwpID4+PiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBhdHRyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9hdHRyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgYXR0cih2YWwpIHtcbiAgICAgICAgICAgIF9hdHRyID0gTWF0aC5tYXgoMCwgdmFsKSA+Pj4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBnZXQgVW5peCBmaWxlIHBlcm1pc3Npb25zXG4gICAgICAgIGdldCBmaWxlQXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXR0ciA/ICgoKF9hdHRyID4+PiAwKSB8IDApID4+IDE2KSAmIDB4ZmZmIDogMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBvZmZzZXQodmFsKSB7XG4gICAgICAgICAgICBfb2Zmc2V0ID0gTWF0aC5tYXgoMCwgdmFsKSA+Pj4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZW5jcmlwdGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfZmxhZ3MgJiAxKSA9PT0gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgZW50cnlIZWFkZXJTaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50cy5DRU5IRFIgKyBfZm5hbWVMZW4gKyBfZXh0cmFMZW4gKyBfY29tTGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCByZWFsRGF0YU9mZnNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUiArIF9kYXRhSGVhZGVyLmZuYW1lTGVuICsgX2RhdGFIZWFkZXIuZXh0cmFMZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGRhdGFIZWFkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RhdGFIZWFkZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZERhdGFIZWFkZXJGcm9tQmluYXJ5OiBmdW5jdGlvbiAoLypCdWZmZXIqLyBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBpbnB1dC5zbGljZShfb2Zmc2V0LCBfb2Zmc2V0ICsgQ29uc3RhbnRzLkxPQ0hEUik7XG4gICAgICAgICAgICAvLyAzMCBieXRlcyBhbmQgc2hvdWxkIHN0YXJ0IHdpdGggXCJQS1xcMDAzXFwwMDRcIlxuICAgICAgICAgICAgaWYgKGRhdGEucmVhZFVJbnQzMkxFKDApICE9PSBDb25zdGFudHMuTE9DU0lHKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5JTlZBTElEX0xPQyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGF0YUhlYWRlciA9IHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ1ZFUiksXG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5MT0NGTEcpLFxuICAgICAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkxPQ0hPVyksXG4gICAgICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgICAgICAgICAgICAgIHRpbWU6IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NUSU0pLFxuICAgICAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgICAgICAgICAgICAgIGNyYzogZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkxPQ0NSQyksXG4gICAgICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZFNpemU6IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5MT0NTSVopLFxuICAgICAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICAgICAgc2l6ZTogZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkxPQ0xFTiksXG4gICAgICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgZm5hbWVMZW46IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5MT0NOQU0pLFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgICAgIGV4dHJhTGVuOiBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuTE9DRVhUKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkRnJvbUJpbmFyeTogZnVuY3Rpb24gKC8qQnVmZmVyKi8gZGF0YSkge1xuICAgICAgICAgICAgLy8gZGF0YSBzaG91bGQgYmUgNDYgYnl0ZXMgYW5kIHN0YXJ0IHdpdGggXCJQSyAwMSAwMlwiXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IENvbnN0YW50cy5DRU5IRFIgfHwgZGF0YS5yZWFkVUludDMyTEUoMCkgIT09IENvbnN0YW50cy5DRU5TSUcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHMuRXJyb3JzLklOVkFMSURfQ0VOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcnNpb24gbWFkZSBieVxuICAgICAgICAgICAgX3Zlck1hZGUgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOVkVNKTtcbiAgICAgICAgICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICAgICAgICAgIF92ZXJzaW9uID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTlZFUik7XG4gICAgICAgICAgICAvLyBlbmNyeXB0LCBkZWNyeXB0IGZsYWdzXG4gICAgICAgICAgICBfZmxhZ3MgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VORkxHKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgICAgICAgICAgX21ldGhvZCA9IGRhdGEucmVhZFVJbnQxNkxFKENvbnN0YW50cy5DRU5IT1cpO1xuICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgICAgICAgICAgX3RpbWUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOVElNKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgICAgICAgICAgX2NyYyA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5DUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfY29tcHJlc3NlZFNpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBfc2l6ZSA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5DRU5MRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBfZm5hbWVMZW4gPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgX2V4dHJhTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkVYVCk7XG4gICAgICAgICAgICAvLyBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICBfY29tTGVuID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkNPTSk7XG4gICAgICAgICAgICAvLyB2b2x1bWUgbnVtYmVyIHN0YXJ0XG4gICAgICAgICAgICBfZGlza1N0YXJ0ID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkNFTkRTSyk7XG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIF9pbmF0dHIgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuQ0VOQVRUKTtcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgX2F0dHIgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuQ0VOQVRYKTtcbiAgICAgICAgICAgIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG4gICAgICAgICAgICBfb2Zmc2V0ID0gZGF0YS5yZWFkVUludDMyTEUoQ29uc3RhbnRzLkNFTk9GRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YUhlYWRlclRvQmluYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBMT0MgaGVhZGVyIHNpemUgKDMwIGJ5dGVzKVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkxPQ0hEUik7XG4gICAgICAgICAgICAvLyBcIlBLXFwwMDNcXDAwNFwiXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoQ29uc3RhbnRzLkxPQ1NJRywgMCk7XG4gICAgICAgICAgICAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX3ZlcnNpb24sIENvbnN0YW50cy5MT0NWRVIpO1xuICAgICAgICAgICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2ZsYWdzLCBDb25zdGFudHMuTE9DRkxHKTtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9tZXRob2QsIENvbnN0YW50cy5MT0NIT1cpO1xuICAgICAgICAgICAgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF90aW1lLCBDb25zdGFudHMuTE9DVElNKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKF9jcmMsIENvbnN0YW50cy5MT0NDUkMpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NvbXByZXNzZWRTaXplLCBDb25zdGFudHMuTE9DU0laKTtcbiAgICAgICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX3NpemUsIENvbnN0YW50cy5MT0NMRU4pO1xuICAgICAgICAgICAgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2ZuYW1lTGVuLCBDb25zdGFudHMuTE9DTkFNKTtcbiAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9leHRyYUxlbiwgQ29uc3RhbnRzLkxPQ0VYVCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbnRyeUhlYWRlclRvQmluYXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDRU4gaGVhZGVyIHNpemUgKDQ2IGJ5dGVzKVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoQ29uc3RhbnRzLkNFTkhEUiArIF9mbmFtZUxlbiArIF9leHRyYUxlbiArIF9jb21MZW4pO1xuICAgICAgICAgICAgLy8gXCJQS1xcMDAxXFwwMDJcIlxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkxFKENvbnN0YW50cy5DRU5TSUcsIDApO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX3Zlck1hZGUsIENvbnN0YW50cy5DRU5WRU0pO1xuICAgICAgICAgICAgLy8gdmVyc2lvbiBuZWVkZWQgdG8gZXh0cmFjdFxuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF92ZXJzaW9uLCBDb25zdGFudHMuQ0VOVkVSKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHQsIGRlY3J5cHQgZmxhZ3NcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZmxhZ3MsIENvbnN0YW50cy5DRU5GTEcpO1xuICAgICAgICAgICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX21ldGhvZCwgQ29uc3RhbnRzLkNFTkhPVyk7XG4gICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdGltZSAoMiBieXRlcyB0aW1lLCAyIGJ5dGVzIGRhdGUpXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX3RpbWUsIENvbnN0YW50cy5DRU5USU0pO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2NyYywgQ29uc3RhbnRzLkNFTkNSQyk7XG4gICAgICAgICAgICAvLyBjb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfY29tcHJlc3NlZFNpemUsIENvbnN0YW50cy5DRU5TSVopO1xuICAgICAgICAgICAgLy8gdW5jb21wcmVzc2VkIHNpemVcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfc2l6ZSwgQ29uc3RhbnRzLkNFTkxFTik7XG4gICAgICAgICAgICAvLyBmaWxlbmFtZSBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZm5hbWVMZW4sIENvbnN0YW50cy5DRU5OQU0pO1xuICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDE2TEUoX2V4dHJhTGVuLCBDb25zdGFudHMuQ0VORVhUKTtcbiAgICAgICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfY29tTGVuLCBDb25zdGFudHMuQ0VOQ09NKTtcbiAgICAgICAgICAgIC8vIHZvbHVtZSBudW1iZXIgc3RhcnRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MTZMRShfZGlza1N0YXJ0LCBDb25zdGFudHMuQ0VORFNLKTtcbiAgICAgICAgICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQxNkxFKF9pbmF0dHIsIENvbnN0YW50cy5DRU5BVFQpO1xuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyTEUoX2F0dHIsIENvbnN0YW50cy5DRU5BVFgpO1xuICAgICAgICAgICAgLy8gTE9DIGhlYWRlciBvZmZzZXRcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJMRShfb2Zmc2V0LCBDb25zdGFudHMuQ0VOT0ZGKTtcbiAgICAgICAgICAgIC8vIGZpbGwgYWxsIHdpdGhcbiAgICAgICAgICAgIGRhdGEuZmlsbCgweDAwLCBDb25zdGFudHMuQ0VOSERSKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBmdW5jdGlvbiAobnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnIgKyBcIiBieXRlc1wiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYWRlOiBfdmVyTWFkZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBfdmVyc2lvbixcbiAgICAgICAgICAgICAgICBmbGFnczogX2ZsYWdzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogVXRpbHMubWV0aG9kVG9TdHJpbmcoX21ldGhvZCksXG4gICAgICAgICAgICAgICAgdGltZTogdGhpcy50aW1lLFxuICAgICAgICAgICAgICAgIGNyYzogXCIweFwiICsgX2NyYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkU2l6ZTogYnl0ZXMoX2NvbXByZXNzZWRTaXplKSxcbiAgICAgICAgICAgICAgICBzaXplOiBieXRlcyhfc2l6ZSksXG4gICAgICAgICAgICAgICAgZmlsZU5hbWVMZW5ndGg6IGJ5dGVzKF9mbmFtZUxlbiksXG4gICAgICAgICAgICAgICAgZXh0cmFMZW5ndGg6IGJ5dGVzKF9leHRyYUxlbiksXG4gICAgICAgICAgICAgICAgY29tbWVudExlbmd0aDogYnl0ZXMoX2NvbUxlbiksXG4gICAgICAgICAgICAgICAgZGlza051bVN0YXJ0OiBfZGlza1N0YXJ0LFxuICAgICAgICAgICAgICAgIGluQXR0cjogX2luYXR0cixcbiAgICAgICAgICAgICAgICBhdHRyOiBfYXR0cixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW50cnlIZWFkZXJTaXplOiBieXRlcyhDb25zdGFudHMuQ0VOSERSICsgX2ZuYW1lTGVuICsgX2V4dHJhTGVuICsgX2NvbUxlbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCBcIlxcdFwiKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIlV0aWxzIiwicmVxdWlyZSIsIkNvbnN0YW50cyIsIm1vZHVsZSIsImV4cG9ydHMiLCJfdmVyTWFkZSIsIl92ZXJzaW9uIiwiX2ZsYWdzIiwiX21ldGhvZCIsIl90aW1lIiwiX2NyYyIsIl9jb21wcmVzc2VkU2l6ZSIsIl9zaXplIiwiX2ZuYW1lTGVuIiwiX2V4dHJhTGVuIiwiX2NvbUxlbiIsIl9kaXNrU3RhcnQiLCJfaW5hdHRyIiwiX2F0dHIiLCJfb2Zmc2V0IiwiaXNXaW4iLCJGTEdfRUZTIiwiX2RhdGFIZWFkZXIiLCJzZXRUaW1lIiwidmFsIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsIm1hZGUiLCJ2ZXJzaW9uIiwiZmxhZ3MiLCJtZXRob2QiLCJTVE9SRUQiLCJERUZMQVRFRCIsInRpbWUiLCJjcmMiLCJNYXRoIiwibWF4IiwiY29tcHJlc3NlZFNpemUiLCJzaXplIiwiZmlsZU5hbWVMZW5ndGgiLCJleHRyYUxlbmd0aCIsImNvbW1lbnRMZW5ndGgiLCJkaXNrTnVtU3RhcnQiLCJpbkF0dHIiLCJhdHRyIiwiZmlsZUF0dHIiLCJvZmZzZXQiLCJlbmNyaXB0ZWQiLCJlbnRyeUhlYWRlclNpemUiLCJDRU5IRFIiLCJyZWFsRGF0YU9mZnNldCIsIkxPQ0hEUiIsImZuYW1lTGVuIiwiZXh0cmFMZW4iLCJkYXRhSGVhZGVyIiwibG9hZERhdGFIZWFkZXJGcm9tQmluYXJ5IiwiaW5wdXQiLCJkYXRhIiwic2xpY2UiLCJyZWFkVUludDMyTEUiLCJMT0NTSUciLCJFcnJvciIsIkVycm9ycyIsIklOVkFMSURfTE9DIiwicmVhZFVJbnQxNkxFIiwiTE9DVkVSIiwiTE9DRkxHIiwiTE9DSE9XIiwiTE9DVElNIiwiTE9DQ1JDIiwiTE9DU0laIiwiTE9DTEVOIiwiTE9DTkFNIiwiTE9DRVhUIiwibG9hZEZyb21CaW5hcnkiLCJsZW5ndGgiLCJDRU5TSUciLCJJTlZBTElEX0NFTiIsIkNFTlZFTSIsIkNFTlZFUiIsIkNFTkZMRyIsIkNFTkhPVyIsIkNFTlRJTSIsIkNFTkNSQyIsIkNFTlNJWiIsIkNFTkxFTiIsIkNFTk5BTSIsIkNFTkVYVCIsIkNFTkNPTSIsIkNFTkRTSyIsIkNFTkFUVCIsIkNFTkFUWCIsIkNFTk9GRiIsImRhdGFIZWFkZXJUb0JpbmFyeSIsIkJ1ZmZlciIsImFsbG9jIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDE2TEUiLCJlbnRyeUhlYWRlclRvQmluYXJ5IiwiZmlsbCIsInRvSlNPTiIsImJ5dGVzIiwibnIiLCJtZXRob2RUb1N0cmluZyIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/headers/entryHeader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/headers/index.js":
/*!***********************************************!*\
  !*** ./node_modules/adm-zip/headers/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.EntryHeader = __webpack_require__(/*! ./entryHeader */ \"(rsc)/./node_modules/adm-zip/headers/entryHeader.js\");\nexports.MainHeader = __webpack_require__(/*! ./mainHeader */ \"(rsc)/./node_modules/adm-zip/headers/mainHeader.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBQSxxSEFBOEM7QUFDOUNBLGtIQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmRheUFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9hZG0temlwL2hlYWRlcnMvaW5kZXguanM/OTFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLkVudHJ5SGVhZGVyID0gcmVxdWlyZShcIi4vZW50cnlIZWFkZXJcIik7XG5leHBvcnRzLk1haW5IZWFkZXIgPSByZXF1aXJlKFwiLi9tYWluSGVhZGVyXCIpO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJFbnRyeUhlYWRlciIsInJlcXVpcmUiLCJNYWluSGVhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/headers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/headers/mainHeader.js":
/*!****************************************************!*\
  !*** ./node_modules/adm-zip/headers/mainHeader.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Utils = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/adm-zip/util/index.js\"), Constants = Utils.Constants;\n/* The entries in the end of central directory */ module.exports = function() {\n    var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;\n    return {\n        get diskEntries () {\n            return _volumeEntries;\n        },\n        set diskEntries (/*Number*/ val){\n            _volumeEntries = _totalEntries = val;\n        },\n        get totalEntries () {\n            return _totalEntries;\n        },\n        set totalEntries (/*Number*/ val){\n            _totalEntries = _volumeEntries = val;\n        },\n        get size () {\n            return _size;\n        },\n        set size (/*Number*/ val){\n            _size = val;\n        },\n        get offset () {\n            return _offset;\n        },\n        set offset (/*Number*/ val){\n            _offset = val;\n        },\n        get commentLength () {\n            return _commentLength;\n        },\n        set commentLength (/*Number*/ val){\n            _commentLength = val;\n        },\n        get mainHeaderSize () {\n            return Constants.ENDHDR + _commentLength;\n        },\n        loadFromBinary: function(/*Buffer*/ data) {\n            // data should be 22 bytes and start with \"PK 05 06\"\n            // or be 56+ bytes and start with \"PK 06 06\" for Zip64\n            if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {\n                throw new Error(Utils.Errors.INVALID_END);\n            }\n            if (data.readUInt32LE(0) === Constants.ENDSIG) {\n                // number of entries on this volume\n                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);\n                // total number of entries\n                _totalEntries = data.readUInt16LE(Constants.ENDTOT);\n                // central directory size in bytes\n                _size = data.readUInt32LE(Constants.ENDSIZ);\n                // offset of first CEN header\n                _offset = data.readUInt32LE(Constants.ENDOFF);\n                // zip file comment length\n                _commentLength = data.readUInt16LE(Constants.ENDCOM);\n            } else {\n                // number of entries on this volume\n                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);\n                // total number of entries\n                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);\n                // central directory size in bytes\n                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);\n                // offset of first CEN header\n                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);\n                _commentLength = 0;\n            }\n        },\n        toBinary: function() {\n            var b = Buffer.alloc(Constants.ENDHDR + _commentLength);\n            // \"PK 05 06\" signature\n            b.writeUInt32LE(Constants.ENDSIG, 0);\n            b.writeUInt32LE(0, 4);\n            // number of entries on this volume\n            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);\n            // total number of entries\n            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);\n            // central directory size in bytes\n            b.writeUInt32LE(_size, Constants.ENDSIZ);\n            // offset of first CEN header\n            b.writeUInt32LE(_offset, Constants.ENDOFF);\n            // zip file comment length\n            b.writeUInt16LE(_commentLength, Constants.ENDCOM);\n            // fill comment memory with spaces so no garbage is left there\n            b.fill(\" \", Constants.ENDHDR);\n            return b;\n        },\n        toJSON: function() {\n            // creates 0x0000 style output\n            const offset = function(nr, len) {\n                let offs = nr.toString(16).toUpperCase();\n                while(offs.length < len)offs = \"0\" + offs;\n                return \"0x\" + offs;\n            };\n            return {\n                diskEntries: _volumeEntries,\n                totalEntries: _totalEntries,\n                size: _size + \" bytes\",\n                offset: offset(_offset, 4),\n                commentLength: _commentLength\n            };\n        },\n        toString: function() {\n            return JSON.stringify(this.toJSON(), null, \"\t\");\n        }\n    };\n}; // Misspelled \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9oZWFkZXJzL21haW5IZWFkZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDLDJEQUFTLEdBQ3pCQyxZQUFZRixNQUFNRSxTQUFTO0FBRS9CLCtDQUErQyxHQUMvQ0MsT0FBT0MsT0FBTyxHQUFHO0lBQ2IsSUFBSUMsaUJBQWlCLEdBQ2pCQyxnQkFBZ0IsR0FDaEJDLFFBQVEsR0FDUkMsVUFBVSxHQUNWQyxpQkFBaUI7SUFFckIsT0FBTztRQUNILElBQUlDLGVBQWM7WUFDZCxPQUFPTDtRQUNYO1FBQ0EsSUFBSUssYUFBWSxRQUFRLEdBQUdDLElBQUs7WUFDNUJOLGlCQUFpQkMsZ0JBQWdCSztRQUNyQztRQUVBLElBQUlDLGdCQUFlO1lBQ2YsT0FBT047UUFDWDtRQUNBLElBQUlNLGNBQWEsUUFBUSxHQUFHRCxJQUFLO1lBQzdCTCxnQkFBZ0JELGlCQUFpQk07UUFDckM7UUFFQSxJQUFJRSxRQUFPO1lBQ1AsT0FBT047UUFDWDtRQUNBLElBQUlNLE1BQUssUUFBUSxHQUFHRixJQUFLO1lBQ3JCSixRQUFRSTtRQUNaO1FBRUEsSUFBSUcsVUFBUztZQUNULE9BQU9OO1FBQ1g7UUFDQSxJQUFJTSxRQUFPLFFBQVEsR0FBR0gsSUFBSztZQUN2QkgsVUFBVUc7UUFDZDtRQUVBLElBQUlJLGlCQUFnQjtZQUNoQixPQUFPTjtRQUNYO1FBQ0EsSUFBSU0sZUFBYyxRQUFRLEdBQUdKLElBQUs7WUFDOUJGLGlCQUFpQkU7UUFDckI7UUFFQSxJQUFJSyxrQkFBaUI7WUFDakIsT0FBT2QsVUFBVWUsTUFBTSxHQUFHUjtRQUM5QjtRQUVBUyxnQkFBZ0IsU0FBVSxRQUFRLEdBQUdDLElBQUk7WUFDckMsb0RBQW9EO1lBQ3BELHNEQUFzRDtZQUN0RCxJQUNJLENBQUNBLEtBQUtDLE1BQU0sS0FBS2xCLFVBQVVlLE1BQU0sSUFBSUUsS0FBS0UsWUFBWSxDQUFDLE9BQU9uQixVQUFVb0IsTUFBTSxLQUM3RUgsQ0FBQUEsS0FBS0MsTUFBTSxHQUFHbEIsVUFBVXFCLFFBQVEsSUFBSUosS0FBS0UsWUFBWSxDQUFDLE9BQU9uQixVQUFVc0IsUUFBUSxHQUNsRjtnQkFDRSxNQUFNLElBQUlDLE1BQU16QixNQUFNMEIsTUFBTSxDQUFDQyxXQUFXO1lBQzVDO1lBRUEsSUFBSVIsS0FBS0UsWUFBWSxDQUFDLE9BQU9uQixVQUFVb0IsTUFBTSxFQUFFO2dCQUMzQyxtQ0FBbUM7Z0JBQ25DakIsaUJBQWlCYyxLQUFLUyxZQUFZLENBQUMxQixVQUFVMkIsTUFBTTtnQkFDbkQsMEJBQTBCO2dCQUMxQnZCLGdCQUFnQmEsS0FBS1MsWUFBWSxDQUFDMUIsVUFBVTRCLE1BQU07Z0JBQ2xELGtDQUFrQztnQkFDbEN2QixRQUFRWSxLQUFLRSxZQUFZLENBQUNuQixVQUFVNkIsTUFBTTtnQkFDMUMsNkJBQTZCO2dCQUM3QnZCLFVBQVVXLEtBQUtFLFlBQVksQ0FBQ25CLFVBQVU4QixNQUFNO2dCQUM1QywwQkFBMEI7Z0JBQzFCdkIsaUJBQWlCVSxLQUFLUyxZQUFZLENBQUMxQixVQUFVK0IsTUFBTTtZQUN2RCxPQUFPO2dCQUNILG1DQUFtQztnQkFDbkM1QixpQkFBaUJMLE1BQU1rQyxlQUFlLENBQUNmLE1BQU1qQixVQUFVaUMsUUFBUTtnQkFDL0QsMEJBQTBCO2dCQUMxQjdCLGdCQUFnQk4sTUFBTWtDLGVBQWUsQ0FBQ2YsTUFBTWpCLFVBQVVrQyxRQUFRO2dCQUM5RCxrQ0FBa0M7Z0JBQ2xDN0IsUUFBUVAsTUFBTWtDLGVBQWUsQ0FBQ2YsTUFBTWpCLFVBQVVtQyxTQUFTO2dCQUN2RCw2QkFBNkI7Z0JBQzdCN0IsVUFBVVIsTUFBTWtDLGVBQWUsQ0FBQ2YsTUFBTWpCLFVBQVVvQyxRQUFRO2dCQUV4RDdCLGlCQUFpQjtZQUNyQjtRQUNKO1FBRUE4QixVQUFVO1lBQ04sSUFBSUMsSUFBSUMsT0FBT0MsS0FBSyxDQUFDeEMsVUFBVWUsTUFBTSxHQUFHUjtZQUN4Qyx1QkFBdUI7WUFDdkIrQixFQUFFRyxhQUFhLENBQUN6QyxVQUFVb0IsTUFBTSxFQUFFO1lBQ2xDa0IsRUFBRUcsYUFBYSxDQUFDLEdBQUc7WUFDbkIsbUNBQW1DO1lBQ25DSCxFQUFFSSxhQUFhLENBQUN2QyxnQkFBZ0JILFVBQVUyQixNQUFNO1lBQ2hELDBCQUEwQjtZQUMxQlcsRUFBRUksYUFBYSxDQUFDdEMsZUFBZUosVUFBVTRCLE1BQU07WUFDL0Msa0NBQWtDO1lBQ2xDVSxFQUFFRyxhQUFhLENBQUNwQyxPQUFPTCxVQUFVNkIsTUFBTTtZQUN2Qyw2QkFBNkI7WUFDN0JTLEVBQUVHLGFBQWEsQ0FBQ25DLFNBQVNOLFVBQVU4QixNQUFNO1lBQ3pDLDBCQUEwQjtZQUMxQlEsRUFBRUksYUFBYSxDQUFDbkMsZ0JBQWdCUCxVQUFVK0IsTUFBTTtZQUNoRCw4REFBOEQ7WUFDOURPLEVBQUVLLElBQUksQ0FBQyxLQUFLM0MsVUFBVWUsTUFBTTtZQUU1QixPQUFPdUI7UUFDWDtRQUVBTSxRQUFRO1lBQ0osOEJBQThCO1lBQzlCLE1BQU1oQyxTQUFTLFNBQVVpQyxFQUFFLEVBQUVDLEdBQUc7Z0JBQzVCLElBQUlDLE9BQU9GLEdBQUdHLFFBQVEsQ0FBQyxJQUFJQyxXQUFXO2dCQUN0QyxNQUFPRixLQUFLN0IsTUFBTSxHQUFHNEIsSUFBS0MsT0FBTyxNQUFNQTtnQkFDdkMsT0FBTyxPQUFPQTtZQUNsQjtZQUVBLE9BQU87Z0JBQ0h2QyxhQUFhTDtnQkFDYk8sY0FBY047Z0JBQ2RPLE1BQU1OLFFBQVE7Z0JBQ2RPLFFBQVFBLE9BQU9OLFNBQVM7Z0JBQ3hCTyxlQUFlTjtZQUNuQjtRQUNKO1FBRUF5QyxVQUFVO1lBQ04sT0FBT0UsS0FBS0MsU0FBUyxDQUFDLElBQUksQ0FBQ1AsTUFBTSxJQUFJLE1BQU07UUFDL0M7SUFDSjtBQUNKLEdBQ0MsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmRheUFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy9hZG0temlwL2hlYWRlcnMvbWFpbkhlYWRlci5qcz9mYTczIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cztcblxuLyogVGhlIGVudHJpZXMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92b2x1bWVFbnRyaWVzID0gMCxcbiAgICAgICAgX3RvdGFsRW50cmllcyA9IDAsXG4gICAgICAgIF9zaXplID0gMCxcbiAgICAgICAgX29mZnNldCA9IDAsXG4gICAgICAgIF9jb21tZW50TGVuZ3RoID0gMDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBkaXNrRW50cmllcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfdm9sdW1lRW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGRpc2tFbnRyaWVzKC8qTnVtYmVyKi8gdmFsKSB7XG4gICAgICAgICAgICBfdm9sdW1lRW50cmllcyA9IF90b3RhbEVudHJpZXMgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHRvdGFsRW50cmllcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfdG90YWxFbnRyaWVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgdG90YWxFbnRyaWVzKC8qTnVtYmVyKi8gdmFsKSB7XG4gICAgICAgICAgICBfdG90YWxFbnRyaWVzID0gX3ZvbHVtZUVudHJpZXMgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBzaXplKC8qTnVtYmVyKi8gdmFsKSB7XG4gICAgICAgICAgICBfc2l6ZSA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBvZmZzZXQoLypOdW1iZXIqLyB2YWwpIHtcbiAgICAgICAgICAgIF9vZmZzZXQgPSB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGNvbW1lbnRMZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbW1lbnRMZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb21tZW50TGVuZ3RoKC8qTnVtYmVyKi8gdmFsKSB7XG4gICAgICAgICAgICBfY29tbWVudExlbmd0aCA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgbWFpbkhlYWRlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzLkVOREhEUiArIF9jb21tZW50TGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvYWRGcm9tQmluYXJ5OiBmdW5jdGlvbiAoLypCdWZmZXIqLyBkYXRhKSB7XG4gICAgICAgICAgICAvLyBkYXRhIHNob3VsZCBiZSAyMiBieXRlcyBhbmQgc3RhcnQgd2l0aCBcIlBLIDA1IDA2XCJcbiAgICAgICAgICAgIC8vIG9yIGJlIDU2KyBieXRlcyBhbmQgc3RhcnQgd2l0aCBcIlBLIDA2IDA2XCIgZm9yIFppcDY0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGRhdGEubGVuZ3RoICE9PSBDb25zdGFudHMuRU5ESERSIHx8IGRhdGEucmVhZFVJbnQzMkxFKDApICE9PSBDb25zdGFudHMuRU5EU0lHKSAmJlxuICAgICAgICAgICAgICAgIChkYXRhLmxlbmd0aCA8IENvbnN0YW50cy5aSVA2NEhEUiB8fCBkYXRhLnJlYWRVSW50MzJMRSgwKSAhPT0gQ29uc3RhbnRzLlpJUDY0U0lHKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5JTlZBTElEX0VORCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnJlYWRVSW50MzJMRSgwKSA9PT0gQ29uc3RhbnRzLkVORFNJRykge1xuICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgdm9sdW1lXG4gICAgICAgICAgICAgICAgX3ZvbHVtZUVudHJpZXMgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuRU5EU1VCKTtcbiAgICAgICAgICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuICAgICAgICAgICAgICAgIF90b3RhbEVudHJpZXMgPSBkYXRhLnJlYWRVSW50MTZMRShDb25zdGFudHMuRU5EVE9UKTtcbiAgICAgICAgICAgICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG4gICAgICAgICAgICAgICAgX3NpemUgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuRU5EU0laKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBkYXRhLnJlYWRVSW50MzJMRShDb25zdGFudHMuRU5ET0ZGKTtcbiAgICAgICAgICAgICAgICAvLyB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICAgICAgICAgIF9jb21tZW50TGVuZ3RoID0gZGF0YS5yZWFkVUludDE2TEUoQ29uc3RhbnRzLkVORENPTSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIG9uIHRoaXMgdm9sdW1lXG4gICAgICAgICAgICAgICAgX3ZvbHVtZUVudHJpZXMgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0U1VCKTtcbiAgICAgICAgICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuICAgICAgICAgICAgICAgIF90b3RhbEVudHJpZXMgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0VE9UKTtcbiAgICAgICAgICAgICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG4gICAgICAgICAgICAgICAgX3NpemUgPSBVdGlscy5yZWFkQmlnVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLlpJUDY0U0laRSk7XG4gICAgICAgICAgICAgICAgLy8gb2Zmc2V0IG9mIGZpcnN0IENFTiBoZWFkZXJcbiAgICAgICAgICAgICAgICBfb2Zmc2V0ID0gVXRpbHMucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIENvbnN0YW50cy5aSVA2NE9GRik7XG5cbiAgICAgICAgICAgICAgICBfY29tbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9CaW5hcnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiID0gQnVmZmVyLmFsbG9jKENvbnN0YW50cy5FTkRIRFIgKyBfY29tbWVudExlbmd0aCk7XG4gICAgICAgICAgICAvLyBcIlBLIDA1IDA2XCIgc2lnbmF0dXJlXG4gICAgICAgICAgICBiLndyaXRlVUludDMyTEUoQ29uc3RhbnRzLkVORFNJRywgMCk7XG4gICAgICAgICAgICBiLndyaXRlVUludDMyTEUoMCwgNCk7XG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgZW50cmllcyBvbiB0aGlzIHZvbHVtZVxuICAgICAgICAgICAgYi53cml0ZVVJbnQxNkxFKF92b2x1bWVFbnRyaWVzLCBDb25zdGFudHMuRU5EU1VCKTtcbiAgICAgICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAgICBiLndyaXRlVUludDE2TEUoX3RvdGFsRW50cmllcywgQ29uc3RhbnRzLkVORFRPVCk7XG4gICAgICAgICAgICAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG4gICAgICAgICAgICBiLndyaXRlVUludDMyTEUoX3NpemUsIENvbnN0YW50cy5FTkRTSVopO1xuICAgICAgICAgICAgLy8gb2Zmc2V0IG9mIGZpcnN0IENFTiBoZWFkZXJcbiAgICAgICAgICAgIGIud3JpdGVVSW50MzJMRShfb2Zmc2V0LCBDb25zdGFudHMuRU5ET0ZGKTtcbiAgICAgICAgICAgIC8vIHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICBiLndyaXRlVUludDE2TEUoX2NvbW1lbnRMZW5ndGgsIENvbnN0YW50cy5FTkRDT00pO1xuICAgICAgICAgICAgLy8gZmlsbCBjb21tZW50IG1lbW9yeSB3aXRoIHNwYWNlcyBzbyBubyBnYXJiYWdlIGlzIGxlZnQgdGhlcmVcbiAgICAgICAgICAgIGIuZmlsbChcIiBcIiwgQ29uc3RhbnRzLkVOREhEUik7XG5cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlcyAweDAwMDAgc3R5bGUgb3V0cHV0XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAobnIsIGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzID0gbnIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnMubGVuZ3RoIDwgbGVuKSBvZmZzID0gXCIwXCIgKyBvZmZzO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBvZmZzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNrRW50cmllczogX3ZvbHVtZUVudHJpZXMsXG4gICAgICAgICAgICAgICAgdG90YWxFbnRyaWVzOiBfdG90YWxFbnRyaWVzLFxuICAgICAgICAgICAgICAgIHNpemU6IF9zaXplICsgXCIgYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldChfb2Zmc2V0LCA0KSxcbiAgICAgICAgICAgICAgICBjb21tZW50TGVuZ3RoOiBfY29tbWVudExlbmd0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIFwiXFx0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4gLy8gTWlzc3BlbGxlZCAiXSwibmFtZXMiOlsiVXRpbHMiLCJyZXF1aXJlIiwiQ29uc3RhbnRzIiwibW9kdWxlIiwiZXhwb3J0cyIsIl92b2x1bWVFbnRyaWVzIiwiX3RvdGFsRW50cmllcyIsIl9zaXplIiwiX29mZnNldCIsIl9jb21tZW50TGVuZ3RoIiwiZGlza0VudHJpZXMiLCJ2YWwiLCJ0b3RhbEVudHJpZXMiLCJzaXplIiwib2Zmc2V0IiwiY29tbWVudExlbmd0aCIsIm1haW5IZWFkZXJTaXplIiwiRU5ESERSIiwibG9hZEZyb21CaW5hcnkiLCJkYXRhIiwibGVuZ3RoIiwicmVhZFVJbnQzMkxFIiwiRU5EU0lHIiwiWklQNjRIRFIiLCJaSVA2NFNJRyIsIkVycm9yIiwiRXJyb3JzIiwiSU5WQUxJRF9FTkQiLCJyZWFkVUludDE2TEUiLCJFTkRTVUIiLCJFTkRUT1QiLCJFTkRTSVoiLCJFTkRPRkYiLCJFTkRDT00iLCJyZWFkQmlnVUludDY0TEUiLCJaSVA2NFNVQiIsIlpJUDY0VE9UIiwiWklQNjRTSVpFIiwiWklQNjRPRkYiLCJ0b0JpbmFyeSIsImIiLCJCdWZmZXIiLCJhbGxvYyIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQxNkxFIiwiZmlsbCIsInRvSlNPTiIsIm5yIiwibGVuIiwib2ZmcyIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/headers/mainHeader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/methods/deflater.js":
/*!**************************************************!*\
  !*** ./node_modules/adm-zip/methods/deflater.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(/*Buffer*/ inbuf) {\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    var opts = {\n        chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024\n    };\n    return {\n        deflate: function() {\n            return zlib.deflateRawSync(inbuf, opts);\n        },\n        deflateAsync: function(/*Function*/ callback) {\n            var tmp = zlib.createDeflateRaw(opts), parts = [], total = 0;\n            tmp.on(\"data\", function(data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function() {\n                var buf = Buffer.alloc(total), written = 0;\n                buf.fill(0);\n                for(var i = 0; i < parts.length; i++){\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2RlZmxhdGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVUsUUFBUSxHQUFHQyxLQUFLO0lBQ3ZDLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLGtCQUFNO0lBRXpCLElBQUlDLE9BQU87UUFBRUMsV0FBVyxDQUFDQyxTQUFTTCxNQUFNTSxNQUFNLEdBQUcsUUFBUSxLQUFLO0lBQUs7SUFFbkUsT0FBTztRQUNIQyxTQUFTO1lBQ0wsT0FBT04sS0FBS08sY0FBYyxDQUFDUixPQUFPRztRQUN0QztRQUVBTSxjQUFjLFNBQVUsVUFBVSxHQUFHQyxRQUFRO1lBQ3pDLElBQUlDLE1BQU1WLEtBQUtXLGdCQUFnQixDQUFDVCxPQUM1QlUsUUFBUSxFQUFFLEVBQ1ZDLFFBQVE7WUFDWkgsSUFBSUksRUFBRSxDQUFDLFFBQVEsU0FBVUMsSUFBSTtnQkFDekJILE1BQU1JLElBQUksQ0FBQ0Q7Z0JBQ1hGLFNBQVNFLEtBQUtWLE1BQU07WUFDeEI7WUFDQUssSUFBSUksRUFBRSxDQUFDLE9BQU87Z0JBQ1YsSUFBSUcsTUFBTUMsT0FBT0MsS0FBSyxDQUFDTixRQUNuQk8sVUFBVTtnQkFDZEgsSUFBSUksSUFBSSxDQUFDO2dCQUNULElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVixNQUFNUCxNQUFNLEVBQUVpQixJQUFLO29CQUNuQyxJQUFJQyxPQUFPWCxLQUFLLENBQUNVLEVBQUU7b0JBQ25CQyxLQUFLQyxJQUFJLENBQUNQLEtBQUtHO29CQUNmQSxXQUFXRyxLQUFLbEIsTUFBTTtnQkFDMUI7Z0JBQ0FJLFlBQVlBLFNBQVNRO1lBQ3pCO1lBQ0FQLElBQUllLEdBQUcsQ0FBQzFCO1FBQ1o7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvbWV0aG9kcy9kZWZsYXRlci5qcz8wMmQzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5idWYpIHtcbiAgICB2YXIgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuXG4gICAgdmFyIG9wdHMgPSB7IGNodW5rU2l6ZTogKHBhcnNlSW50KGluYnVmLmxlbmd0aCAvIDEwMjQpICsgMSkgKiAxMDI0IH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemxpYi5kZWZsYXRlUmF3U3luYyhpbmJ1Ziwgb3B0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmbGF0ZUFzeW5jOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KG9wdHMpLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgICAgdG1wLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0b3RhbCksXG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5KGJ1Ziwgd3JpdHRlbik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1Zik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5lbmQoaW5idWYpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImluYnVmIiwiemxpYiIsInJlcXVpcmUiLCJvcHRzIiwiY2h1bmtTaXplIiwicGFyc2VJbnQiLCJsZW5ndGgiLCJkZWZsYXRlIiwiZGVmbGF0ZVJhd1N5bmMiLCJkZWZsYXRlQXN5bmMiLCJjYWxsYmFjayIsInRtcCIsImNyZWF0ZURlZmxhdGVSYXciLCJwYXJ0cyIsInRvdGFsIiwib24iLCJkYXRhIiwicHVzaCIsImJ1ZiIsIkJ1ZmZlciIsImFsbG9jIiwid3JpdHRlbiIsImZpbGwiLCJpIiwicGFydCIsImNvcHkiLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/methods/deflater.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/methods/index.js":
/*!***********************************************!*\
  !*** ./node_modules/adm-zip/methods/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.Deflater = __webpack_require__(/*! ./deflater */ \"(rsc)/./node_modules/adm-zip/methods/deflater.js\");\nexports.Inflater = __webpack_require__(/*! ./inflater */ \"(rsc)/./node_modules/adm-zip/methods/inflater.js\");\nexports.ZipCrypto = __webpack_require__(/*! ./zipcrypto */ \"(rsc)/./node_modules/adm-zip/methods/zipcrypto.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBQSw0R0FBd0M7QUFDeENBLDRHQUF3QztBQUN4Q0EsK0dBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvbWV0aG9kcy9pbmRleC5qcz9lZTQ2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuRGVmbGF0ZXIgPSByZXF1aXJlKFwiLi9kZWZsYXRlclwiKTtcbmV4cG9ydHMuSW5mbGF0ZXIgPSByZXF1aXJlKFwiLi9pbmZsYXRlclwiKTtcbmV4cG9ydHMuWmlwQ3J5cHRvID0gcmVxdWlyZShcIi4vemlwY3J5cHRvXCIpO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJEZWZsYXRlciIsInJlcXVpcmUiLCJJbmZsYXRlciIsIlppcENyeXB0byJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/methods/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/methods/inflater.js":
/*!**************************************************!*\
  !*** ./node_modules/adm-zip/methods/inflater.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function(/*Buffer*/ inbuf) {\n    var zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    return {\n        inflate: function() {\n            return zlib.inflateRawSync(inbuf);\n        },\n        inflateAsync: function(/*Function*/ callback) {\n            var tmp = zlib.createInflateRaw(), parts = [], total = 0;\n            tmp.on(\"data\", function(data) {\n                parts.push(data);\n                total += data.length;\n            });\n            tmp.on(\"end\", function() {\n                var buf = Buffer.alloc(total), written = 0;\n                buf.fill(0);\n                for(var i = 0; i < parts.length; i++){\n                    var part = parts[i];\n                    part.copy(buf, written);\n                    written += part.length;\n                }\n                callback && callback(buf);\n            });\n            tmp.end(inbuf);\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL2luZmxhdGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHLFNBQVUsUUFBUSxHQUFHQyxLQUFLO0lBQ3ZDLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLGtCQUFNO0lBRXpCLE9BQU87UUFDSEMsU0FBUztZQUNMLE9BQU9GLEtBQUtHLGNBQWMsQ0FBQ0o7UUFDL0I7UUFFQUssY0FBYyxTQUFVLFVBQVUsR0FBR0MsUUFBUTtZQUN6QyxJQUFJQyxNQUFNTixLQUFLTyxnQkFBZ0IsSUFDM0JDLFFBQVEsRUFBRSxFQUNWQyxRQUFRO1lBQ1pILElBQUlJLEVBQUUsQ0FBQyxRQUFRLFNBQVVDLElBQUk7Z0JBQ3pCSCxNQUFNSSxJQUFJLENBQUNEO2dCQUNYRixTQUFTRSxLQUFLRSxNQUFNO1lBQ3hCO1lBQ0FQLElBQUlJLEVBQUUsQ0FBQyxPQUFPO2dCQUNWLElBQUlJLE1BQU1DLE9BQU9DLEtBQUssQ0FBQ1AsUUFDbkJRLFVBQVU7Z0JBQ2RILElBQUlJLElBQUksQ0FBQztnQkFDVCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVgsTUFBTUssTUFBTSxFQUFFTSxJQUFLO29CQUNuQyxJQUFJQyxPQUFPWixLQUFLLENBQUNXLEVBQUU7b0JBQ25CQyxLQUFLQyxJQUFJLENBQUNQLEtBQUtHO29CQUNmQSxXQUFXRyxLQUFLUCxNQUFNO2dCQUMxQjtnQkFDQVIsWUFBWUEsU0FBU1M7WUFDekI7WUFDQVIsSUFBSWdCLEdBQUcsQ0FBQ3ZCO1FBQ1o7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvbWV0aG9kcy9pbmZsYXRlci5qcz8zZmZhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qQnVmZmVyKi8gaW5idWYpIHtcbiAgICB2YXIgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5mbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpsaWIuaW5mbGF0ZVJhd1N5bmMoaW5idWYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluZmxhdGVBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICAgICAgdG1wLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh0b3RhbCksXG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5KGJ1Ziwgd3JpdHRlbik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXR0ZW4gKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1Zik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRtcC5lbmQoaW5idWYpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImluYnVmIiwiemxpYiIsInJlcXVpcmUiLCJpbmZsYXRlIiwiaW5mbGF0ZVJhd1N5bmMiLCJpbmZsYXRlQXN5bmMiLCJjYWxsYmFjayIsInRtcCIsImNyZWF0ZUluZmxhdGVSYXciLCJwYXJ0cyIsInRvdGFsIiwib24iLCJkYXRhIiwicHVzaCIsImxlbmd0aCIsImJ1ZiIsIkJ1ZmZlciIsImFsbG9jIiwid3JpdHRlbiIsImZpbGwiLCJpIiwicGFydCIsImNvcHkiLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/methods/inflater.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/methods/zipcrypto.js":
/*!***************************************************!*\
  !*** ./node_modules/adm-zip/methods/zipcrypto.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n// generate CRC32 lookup table\nconst crctable = new Uint32Array(256).map((t, crc)=>{\n    for(let j = 0; j < 8; j++){\n        if (0 !== (crc & 1)) {\n            crc = crc >>> 1 ^ 0xedb88320;\n        } else {\n            crc >>>= 1;\n        }\n    }\n    return crc >>> 0;\n});\n// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\nconst uMul = (a, b)=>Math.imul(a, b) >>> 0;\n// crc32 byte single update (actually same function is part of utils.crc32 function :) )\nconst crc32update = (pCrc32, bval)=>{\n    return crctable[(pCrc32 ^ bval) & 0xff] ^ pCrc32 >>> 8;\n};\n// function for generating salt for encrytion header\nconst genSalt = ()=>{\n    if (\"function\" === typeof randomFillSync) {\n        return randomFillSync(Buffer.alloc(12));\n    } else {\n        // fallback if function is not defined\n        return genSalt.node();\n    }\n};\n// salt generation with node random function (mainly as fallback)\ngenSalt.node = ()=>{\n    const salt = Buffer.alloc(12);\n    const len = salt.length;\n    for(let i = 0; i < len; i++)salt[i] = Math.random() * 256 & 0xff;\n    return salt;\n};\n// general config\nconst config = {\n    genSalt\n};\n// Class Initkeys handles same basic ops with keys\nfunction Initkeys(pw) {\n    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n    this.keys = new Uint32Array([\n        0x12345678,\n        0x23456789,\n        0x34567890\n    ]);\n    for(let i = 0; i < pass.length; i++){\n        this.updateKeys(pass[i]);\n    }\n}\nInitkeys.prototype.updateKeys = function(byteValue) {\n    const keys = this.keys;\n    keys[0] = crc32update(keys[0], byteValue);\n    keys[1] += keys[0] & 0xff;\n    keys[1] = uMul(keys[1], 134775813) + 1;\n    keys[2] = crc32update(keys[2], keys[1] >>> 24);\n    return byteValue;\n};\nInitkeys.prototype.next = function() {\n    const k = (this.keys[2] | 2) >>> 0; // key\n    return uMul(k, k ^ 1) >> 8 & 0xff; // decode\n};\nfunction make_decrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n    // return decrypter function\n    return function(/*Buffer*/ data) {\n        // result - we create new Buffer for results\n        const result = Buffer.alloc(data.length);\n        let pos = 0;\n        // process input data\n        for (let c of data){\n            //c ^= keys.next();\n            //result[pos++] = c; // decode & Save Value\n            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n        }\n        return result;\n    };\n}\nfunction make_encrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n    // return encrypting function, result and pos is here so we dont have to merge buffers later\n    return function(/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {\n        // result - we create new Buffer for results\n        if (!result) result = Buffer.alloc(data.length);\n        // process input data\n        for (let c of data){\n            const k = keys.next(); // save key byte\n            result[pos++] = c ^ k; // save val\n            keys.updateKeys(c); // update keys with decoded byte\n        }\n        return result;\n    };\n}\nfunction decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {\n    if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n        return Buffer.alloc(0);\n    }\n    // 1. We Initialize and generate decrypting function\n    const decrypter = make_decrypter(pwd);\n    // 2. decrypt salt what is always 12 bytes and is a part of file content\n    const salt = decrypter(data.slice(0, 12));\n    // 3. does password meet expectations\n    if (salt[11] !== header.crc >>> 24) {\n        throw \"ADM-ZIP: Wrong Password\";\n    }\n    // 4. decode content\n    return decrypter(data.slice(12));\n}\n// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\nfunction _salter(data) {\n    if (Buffer.isBuffer(data) && data.length >= 12) {\n        // be aware - currently salting buffer data is modified\n        config.genSalt = function() {\n            return data.slice(0, 12);\n        };\n    } else if (data === \"node\") {\n        // test salt generation with node random function\n        config.genSalt = genSalt.node;\n    } else {\n        // if value is not acceptable config gets reset.\n        config.genSalt = genSalt;\n    }\n}\nfunction encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {\n    // 1. test data if data is not Buffer we make buffer from it\n    if (data == null) data = Buffer.alloc(0);\n    // if data is not buffer be make buffer from it\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n    // 2. We Initialize and generate encrypting function\n    const encrypter = make_encrypter(pwd);\n    // 3. generate salt (12-bytes of random data)\n    const salt = config.genSalt();\n    salt[11] = header.crc >>> 24 & 0xff;\n    // old implementations (before PKZip 2.04g) used two byte check\n    if (oldlike) salt[10] = header.crc >>> 16 & 0xff;\n    // 4. create output\n    const result = Buffer.alloc(data.length + 12);\n    encrypter(salt, result);\n    // finally encode content\n    return encrypter(data, result, 12);\n}\nmodule.exports = {\n    decrypt,\n    encrypt,\n    _salter\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL3ppcGNyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLDBDQUEwQztBQUMxQyxzRUFBc0U7QUFDdEUsTUFBTSxFQUFFQSxjQUFjLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsc0JBQVE7QUFFM0MsOEJBQThCO0FBQzlCLE1BQU1DLFdBQVcsSUFBSUMsWUFBWSxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0M7SUFDMUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN4QixJQUFJLE1BQU9ELENBQUFBLE1BQU0sSUFBSTtZQUNqQkEsTUFBTSxRQUFTLElBQUs7UUFDeEIsT0FBTztZQUNIQSxTQUFTO1FBQ2I7SUFDSjtJQUNBLE9BQU9BLFFBQVE7QUFDbkI7QUFFQSx1RkFBdUY7QUFDdkYsTUFBTUUsT0FBTyxDQUFDQyxHQUFHQyxJQUFNQyxLQUFLQyxJQUFJLENBQUNILEdBQUdDLE9BQU87QUFFM0Msd0ZBQXdGO0FBQ3hGLE1BQU1HLGNBQWMsQ0FBQ0MsUUFBUUM7SUFDekIsT0FBT2IsUUFBUSxDQUFDLENBQUNZLFNBQVNDLElBQUcsSUFBSyxLQUFLLEdBQUlELFdBQVc7QUFDMUQ7QUFFQSxvREFBb0Q7QUFDcEQsTUFBTUUsVUFBVTtJQUNaLElBQUksZUFBZSxPQUFPaEIsZ0JBQWdCO1FBQ3RDLE9BQU9BLGVBQWVpQixPQUFPQyxLQUFLLENBQUM7SUFDdkMsT0FBTztRQUNILHNDQUFzQztRQUN0QyxPQUFPRixRQUFRRyxJQUFJO0lBQ3ZCO0FBQ0o7QUFFQSxpRUFBaUU7QUFDakVILFFBQVFHLElBQUksR0FBRztJQUNYLE1BQU1DLE9BQU9ILE9BQU9DLEtBQUssQ0FBQztJQUMxQixNQUFNRyxNQUFNRCxLQUFLRSxNQUFNO0lBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLSCxJQUFJLENBQUNHLEVBQUUsR0FBRyxLQUFNQyxNQUFNLEtBQUss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QVFkLEdBQUcsS0FBSyxLQUFNO0lBRWpDLCtEQUErRDtJQUMvRCxJQUFJNEMsU0FBUzlCLElBQUksQ0FBQyxHQUFHLEdBQUcsT0FBUWQsR0FBRyxLQUFLLEtBQU07SUFFOUMsbUJBQW1CO0lBQ25CLE1BQU1rQyxTQUFTdkIsT0FBT0MsS0FBSyxDQUFDcUIsS0FBS2pCLE1BQU0sR0FBRztJQUMxQzhCLFVBQVVoQyxNQUFNb0I7SUFFaEIseUJBQXlCO0lBQ3pCLE9BQU9ZLFVBQVViLE1BQU1DLFFBQVE7QUFDbkM7QUFFQWEsT0FBT0MsT0FBTyxHQUFHO0lBQUVWO0lBQVNLO0lBQVNEO0FBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25kYXlBc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvYWRtLXppcC9tZXRob2RzL3ppcGNyeXB0by5qcz9iOWE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBub2RlIGNyeXB0LCB3ZSB1c2UgaXQgZm9yIGdlbmVyYXRlIHNhbHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5cbi8vIGdlbmVyYXRlIENSQzMyIGxvb2t1cCB0YWJsZVxuY29uc3QgY3JjdGFibGUgPSBuZXcgVWludDMyQXJyYXkoMjU2KS5tYXAoKHQsIGNyYykgPT4ge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgIGlmICgwICE9PSAoY3JjICYgMSkpIHtcbiAgICAgICAgICAgIGNyYyA9IChjcmMgPj4+IDEpIF4gMHhlZGI4ODMyMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyYyA+Pj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyYyA+Pj4gMDtcbn0pO1xuXG4vLyBDLXN0eWxlIHVJbnQzMiBNdWx0aXBseSAoZGlzY2FyZHMgaGlnaGVyIGJpdHMsIHdoZW4gSlMgbXVsdGlwbHkgZGlzY2FyZHMgbG93ZXIgYml0cylcbmNvbnN0IHVNdWwgPSAoYSwgYikgPT4gTWF0aC5pbXVsKGEsIGIpID4+PiAwO1xuXG4vLyBjcmMzMiBieXRlIHNpbmdsZSB1cGRhdGUgKGFjdHVhbGx5IHNhbWUgZnVuY3Rpb24gaXMgcGFydCBvZiB1dGlscy5jcmMzMiBmdW5jdGlvbiA6KSApXG5jb25zdCBjcmMzMnVwZGF0ZSA9IChwQ3JjMzIsIGJ2YWwpID0+IHtcbiAgICByZXR1cm4gY3JjdGFibGVbKHBDcmMzMiBeIGJ2YWwpICYgMHhmZl0gXiAocENyYzMyID4+PiA4KTtcbn07XG5cbi8vIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHNhbHQgZm9yIGVuY3J5dGlvbiBoZWFkZXJcbmNvbnN0IGdlblNhbHQgPSAoKSA9PiB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJhbmRvbUZpbGxTeW5jKSB7XG4gICAgICAgIHJldHVybiByYW5kb21GaWxsU3luYyhCdWZmZXIuYWxsb2MoMTIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBpZiBmdW5jdGlvbiBpcyBub3QgZGVmaW5lZFxuICAgICAgICByZXR1cm4gZ2VuU2FsdC5ub2RlKCk7XG4gICAgfVxufTtcblxuLy8gc2FsdCBnZW5lcmF0aW9uIHdpdGggbm9kZSByYW5kb20gZnVuY3Rpb24gKG1haW5seSBhcyBmYWxsYmFjaylcbmdlblNhbHQubm9kZSA9ICgpID0+IHtcbiAgICBjb25zdCBzYWx0ID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgICBjb25zdCBsZW4gPSBzYWx0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSBzYWx0W2ldID0gKE1hdGgucmFuZG9tKCkgKiAyNTYpICYgMHhmZjtcbiAgICByZXR1cm4gc2FsdDtcbn07XG5cbi8vIGdlbmVyYWwgY29uZmlnXG5jb25zdCBjb25maWcgPSB7XG4gICAgZ2VuU2FsdFxufTtcblxuLy8gQ2xhc3MgSW5pdGtleXMgaGFuZGxlcyBzYW1lIGJhc2ljIG9wcyB3aXRoIGtleXNcbmZ1bmN0aW9uIEluaXRrZXlzKHB3KSB7XG4gICAgY29uc3QgcGFzcyA9IEJ1ZmZlci5pc0J1ZmZlcihwdykgPyBwdyA6IEJ1ZmZlci5mcm9tKHB3KTtcbiAgICB0aGlzLmtleXMgPSBuZXcgVWludDMyQXJyYXkoWzB4MTIzNDU2NzgsIDB4MjM0NTY3ODksIDB4MzQ1Njc4OTBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlzKHBhc3NbaV0pO1xuICAgIH1cbn1cblxuSW5pdGtleXMucHJvdG90eXBlLnVwZGF0ZUtleXMgPSBmdW5jdGlvbiAoYnl0ZVZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cztcbiAgICBrZXlzWzBdID0gY3JjMzJ1cGRhdGUoa2V5c1swXSwgYnl0ZVZhbHVlKTtcbiAgICBrZXlzWzFdICs9IGtleXNbMF0gJiAweGZmO1xuICAgIGtleXNbMV0gPSB1TXVsKGtleXNbMV0sIDEzNDc3NTgxMykgKyAxO1xuICAgIGtleXNbMl0gPSBjcmMzMnVwZGF0ZShrZXlzWzJdLCBrZXlzWzFdID4+PiAyNCk7XG4gICAgcmV0dXJuIGJ5dGVWYWx1ZTtcbn07XG5cbkluaXRrZXlzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGsgPSAodGhpcy5rZXlzWzJdIHwgMikgPj4+IDA7IC8vIGtleVxuICAgIHJldHVybiAodU11bChrLCBrIF4gMSkgPj4gOCkgJiAweGZmOyAvLyBkZWNvZGVcbn07XG5cbmZ1bmN0aW9uIG1ha2VfZGVjcnlwdGVyKC8qQnVmZmVyKi8gcHdkKSB7XG4gICAgLy8gMS4gU3RhZ2UgaW5pdGlhbGl6ZSBrZXlcbiAgICBjb25zdCBrZXlzID0gbmV3IEluaXRrZXlzKHB3ZCk7XG5cbiAgICAvLyByZXR1cm4gZGVjcnlwdGVyIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgvKkJ1ZmZlciovIGRhdGEpIHtcbiAgICAgICAgLy8gcmVzdWx0IC0gd2UgY3JlYXRlIG5ldyBCdWZmZXIgZm9yIHJlc3VsdHNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGRhdGEubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICBmb3IgKGxldCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIC8vYyBePSBrZXlzLm5leHQoKTtcbiAgICAgICAgICAgIC8vcmVzdWx0W3BvcysrXSA9IGM7IC8vIGRlY29kZSAmIFNhdmUgVmFsdWVcbiAgICAgICAgICAgIHJlc3VsdFtwb3MrK10gPSBrZXlzLnVwZGF0ZUtleXMoYyBeIGtleXMubmV4dCgpKTsgLy8gdXBkYXRlIGtleXMgd2l0aCBkZWNvZGVkIGJ5dGVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfZW5jcnlwdGVyKC8qQnVmZmVyKi8gcHdkKSB7XG4gICAgLy8gMS4gU3RhZ2UgaW5pdGlhbGl6ZSBrZXlcbiAgICBjb25zdCBrZXlzID0gbmV3IEluaXRrZXlzKHB3ZCk7XG5cbiAgICAvLyByZXR1cm4gZW5jcnlwdGluZyBmdW5jdGlvbiwgcmVzdWx0IGFuZCBwb3MgaXMgaGVyZSBzbyB3ZSBkb250IGhhdmUgdG8gbWVyZ2UgYnVmZmVycyBsYXRlclxuICAgIHJldHVybiBmdW5jdGlvbiAoLypCdWZmZXIqLyBkYXRhLCAvKkJ1ZmZlciovIHJlc3VsdCwgLyogTnVtYmVyICovIHBvcyA9IDApIHtcbiAgICAgICAgLy8gcmVzdWx0IC0gd2UgY3JlYXRlIG5ldyBCdWZmZXIgZm9yIHJlc3VsdHNcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhkYXRhLmxlbmd0aCk7XG4gICAgICAgIC8vIHByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICBmb3IgKGxldCBjIG9mIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBrZXlzLm5leHQoKTsgLy8gc2F2ZSBrZXkgYnl0ZVxuICAgICAgICAgICAgcmVzdWx0W3BvcysrXSA9IGMgXiBrOyAvLyBzYXZlIHZhbFxuICAgICAgICAgICAga2V5cy51cGRhdGVLZXlzKGMpOyAvLyB1cGRhdGUga2V5cyB3aXRoIGRlY29kZWQgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCgvKkJ1ZmZlciovIGRhdGEsIC8qT2JqZWN0Ki8gaGVhZGVyLCAvKlN0cmluZywgQnVmZmVyKi8gcHdkKSB7XG4gICAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkgfHwgZGF0YS5sZW5ndGggPCAxMikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cblxuICAgIC8vIDEuIFdlIEluaXRpYWxpemUgYW5kIGdlbmVyYXRlIGRlY3J5cHRpbmcgZnVuY3Rpb25cbiAgICBjb25zdCBkZWNyeXB0ZXIgPSBtYWtlX2RlY3J5cHRlcihwd2QpO1xuXG4gICAgLy8gMi4gZGVjcnlwdCBzYWx0IHdoYXQgaXMgYWx3YXlzIDEyIGJ5dGVzIGFuZCBpcyBhIHBhcnQgb2YgZmlsZSBjb250ZW50XG4gICAgY29uc3Qgc2FsdCA9IGRlY3J5cHRlcihkYXRhLnNsaWNlKDAsIDEyKSk7XG5cbiAgICAvLyAzLiBkb2VzIHBhc3N3b3JkIG1lZXQgZXhwZWN0YXRpb25zXG4gICAgaWYgKHNhbHRbMTFdICE9PSBoZWFkZXIuY3JjID4+PiAyNCkge1xuICAgICAgICB0aHJvdyBcIkFETS1aSVA6IFdyb25nIFBhc3N3b3JkXCI7XG4gICAgfVxuXG4gICAgLy8gNC4gZGVjb2RlIGNvbnRlbnRcbiAgICByZXR1cm4gZGVjcnlwdGVyKGRhdGEuc2xpY2UoMTIpKTtcbn1cblxuLy8gbGV0cyBhZGQgd2F5IHRvIHBvcHVsYXRlIHNhbHQsIE5PVCBSRUNPTU1FTkRFRCBmb3IgcHJvZHVjdGlvbiBidXQgbWF5YmUgdXNlZnVsIGZvciB0ZXN0aW5nIGdlbmVyYWwgZnVuY3Rpb25hbGl0eVxuZnVuY3Rpb24gX3NhbHRlcihkYXRhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiBkYXRhLmxlbmd0aCA+PSAxMikge1xuICAgICAgICAvLyBiZSBhd2FyZSAtIGN1cnJlbnRseSBzYWx0aW5nIGJ1ZmZlciBkYXRhIGlzIG1vZGlmaWVkXG4gICAgICAgIGNvbmZpZy5nZW5TYWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgMTIpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gXCJub2RlXCIpIHtcbiAgICAgICAgLy8gdGVzdCBzYWx0IGdlbmVyYXRpb24gd2l0aCBub2RlIHJhbmRvbSBmdW5jdGlvblxuICAgICAgICBjb25maWcuZ2VuU2FsdCA9IGdlblNhbHQubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB2YWx1ZSBpcyBub3QgYWNjZXB0YWJsZSBjb25maWcgZ2V0cyByZXNldC5cbiAgICAgICAgY29uZmlnLmdlblNhbHQgPSBnZW5TYWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jcnlwdCgvKkJ1ZmZlciovIGRhdGEsIC8qT2JqZWN0Ki8gaGVhZGVyLCAvKlN0cmluZywgQnVmZmVyKi8gcHdkLCAvKkJvb2xlYW4qLyBvbGRsaWtlID0gZmFsc2UpIHtcbiAgICAvLyAxLiB0ZXN0IGRhdGEgaWYgZGF0YSBpcyBub3QgQnVmZmVyIHdlIG1ha2UgYnVmZmVyIGZyb20gaXRcbiAgICBpZiAoZGF0YSA9PSBudWxsKSBkYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIC8vIGlmIGRhdGEgaXMgbm90IGJ1ZmZlciBiZSBtYWtlIGJ1ZmZlciBmcm9tIGl0XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gMi4gV2UgSW5pdGlhbGl6ZSBhbmQgZ2VuZXJhdGUgZW5jcnlwdGluZyBmdW5jdGlvblxuICAgIGNvbnN0IGVuY3J5cHRlciA9IG1ha2VfZW5jcnlwdGVyKHB3ZCk7XG5cbiAgICAvLyAzLiBnZW5lcmF0ZSBzYWx0ICgxMi1ieXRlcyBvZiByYW5kb20gZGF0YSlcbiAgICBjb25zdCBzYWx0ID0gY29uZmlnLmdlblNhbHQoKTtcbiAgICBzYWx0WzExXSA9IChoZWFkZXIuY3JjID4+PiAyNCkgJiAweGZmO1xuXG4gICAgLy8gb2xkIGltcGxlbWVudGF0aW9ucyAoYmVmb3JlIFBLWmlwIDIuMDRnKSB1c2VkIHR3byBieXRlIGNoZWNrXG4gICAgaWYgKG9sZGxpa2UpIHNhbHRbMTBdID0gKGhlYWRlci5jcmMgPj4+IDE2KSAmIDB4ZmY7XG5cbiAgICAvLyA0LiBjcmVhdGUgb3V0cHV0XG4gICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKGRhdGEubGVuZ3RoICsgMTIpO1xuICAgIGVuY3J5cHRlcihzYWx0LCByZXN1bHQpO1xuXG4gICAgLy8gZmluYWxseSBlbmNvZGUgY29udGVudFxuICAgIHJldHVybiBlbmNyeXB0ZXIoZGF0YSwgcmVzdWx0LCAxMik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNyeXB0LCBlbmNyeXB0LCBfc2FsdGVyIH07XG4iXSwibmFtZXMiOlsicmFuZG9tRmlsbFN5bmMiLCJyZXF1aXJlIiwiY3JjdGFibGUiLCJVaW50MzJBcnJheSIsIm1hcCIsInQiLCJjcmMiLCJqIiwidU11bCIsImEiLCJiIiwiTWF0aCIsImltdWwiLCJjcmMzMnVwZGF0ZSIsInBDcmMzMiIsImJ2YWwiLCJnZW5TYWx0IiwiQnVmZmVyIiwiYWxsb2MiLCJub2RlIiwic2FsdCIsImxlbiIsImxlbmd0aCIsImkiLCJyYW5kb20iLCJjb25maWciLCJJbml0a2V5cyIsInB3IiwicGFzcyIsImlzQnVmZmVyIiwiZnJvbSIsImtleXMiLCJ1cGRhdGVLZXlzIiwicHJvdG90eXBlIiwiYnl0ZVZhbHVlIiwibmV4dCIsImsiLCJtYWtlX2RlY3J5cHRlciIsInB3ZCIsImRhdGEiLCJyZXN1bHQiLCJwb3MiLCJjIiwibWFrZV9lbmNyeXB0ZXIiLCJkZWNyeXB0IiwiaGVhZGVyIiwiZGVjcnlwdGVyIiwic2xpY2UiLCJfc2FsdGVyIiwiZW5jcnlwdCIsIm9sZGxpa2UiLCJ0b1N0cmluZyIsImVuY3J5cHRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/methods/zipcrypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/constants.js":
/*!************************************************!*\
  !*** ./node_modules/adm-zip/util/constants.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    /* The local file header */ LOCHDR: 30,\n    LOCSIG: 0x04034b50,\n    LOCVER: 4,\n    LOCFLG: 6,\n    LOCHOW: 8,\n    LOCTIM: 10,\n    LOCCRC: 14,\n    LOCSIZ: 18,\n    LOCLEN: 22,\n    LOCNAM: 26,\n    LOCEXT: 28,\n    /* The Data descriptor */ EXTSIG: 0x08074b50,\n    EXTHDR: 16,\n    EXTCRC: 4,\n    EXTSIZ: 8,\n    EXTLEN: 12,\n    /* The central directory file header */ CENHDR: 46,\n    CENSIG: 0x02014b50,\n    CENVEM: 4,\n    CENVER: 6,\n    CENFLG: 8,\n    CENHOW: 10,\n    CENTIM: 12,\n    CENCRC: 16,\n    CENSIZ: 20,\n    CENLEN: 24,\n    CENNAM: 28,\n    CENEXT: 30,\n    CENCOM: 32,\n    CENDSK: 34,\n    CENATT: 36,\n    CENATX: 38,\n    CENOFF: 42,\n    /* The entries in the end of central directory */ ENDHDR: 22,\n    ENDSIG: 0x06054b50,\n    ENDSUB: 8,\n    ENDTOT: 10,\n    ENDSIZ: 12,\n    ENDOFF: 16,\n    ENDCOM: 20,\n    END64HDR: 20,\n    END64SIG: 0x07064b50,\n    END64START: 4,\n    END64OFF: 8,\n    END64NUMDISKS: 16,\n    ZIP64SIG: 0x06064b50,\n    ZIP64HDR: 56,\n    ZIP64LEAD: 12,\n    ZIP64SIZE: 4,\n    ZIP64VEM: 12,\n    ZIP64VER: 14,\n    ZIP64DSK: 16,\n    ZIP64DSKDIR: 20,\n    ZIP64SUB: 24,\n    ZIP64TOT: 32,\n    ZIP64SIZB: 40,\n    ZIP64OFF: 48,\n    ZIP64EXTRA: 56,\n    /* Compression methods */ STORED: 0,\n    SHRUNK: 1,\n    REDUCED1: 2,\n    REDUCED2: 3,\n    REDUCED3: 4,\n    REDUCED4: 5,\n    IMPLODED: 6,\n    // 7 reserved for Tokenizing compression algorithm\n    DEFLATED: 8,\n    ENHANCED_DEFLATED: 9,\n    PKWARE: 10,\n    // 11 reserved by PKWARE\n    BZIP2: 12,\n    // 13 reserved by PKWARE\n    LZMA: 14,\n    // 15-17 reserved by PKWARE\n    IBM_TERSE: 18,\n    IBM_LZ77: 19,\n    AES_ENCRYPT: 99,\n    /* General purpose bit flag */ // values can obtained with expression 2**bitnr\n    FLG_ENC: 1,\n    FLG_COMP1: 2,\n    FLG_COMP2: 4,\n    FLG_DESC: 8,\n    FLG_ENH: 16,\n    FLG_PATCH: 32,\n    FLG_STR: 64,\n    // Bits 7-10: Currently unused.\n    FLG_EFS: 2048,\n    // Bit 12: Reserved by PKWARE for enhanced compression.\n    // Bit 13: encrypted the Central Directory (patented).\n    // Bits 14-15: Reserved by PKWARE.\n    FLG_MSK: 4096,\n    /* Load type */ FILE: 2,\n    BUFFER: 1,\n    NONE: 0,\n    /* 4.5 Extensible data fields */ EF_ID: 0,\n    EF_SIZE: 2,\n    /* Header IDs */ ID_ZIP64: 0x0001,\n    ID_AVINFO: 0x0007,\n    ID_PFS: 0x0008,\n    ID_OS2: 0x0009,\n    ID_NTFS: 0x000a,\n    ID_OPENVMS: 0x000c,\n    ID_UNIX: 0x000d,\n    ID_FORK: 0x000e,\n    ID_PATCH: 0x000f,\n    ID_X509_PKCS7: 0x0014,\n    ID_X509_CERTID_F: 0x0015,\n    ID_X509_CERTID_C: 0x0016,\n    ID_STRONGENC: 0x0017,\n    ID_RECORD_MGT: 0x0018,\n    ID_X509_PKCS7_RL: 0x0019,\n    ID_IBM1: 0x0065,\n    ID_IBM2: 0x0066,\n    ID_POSZIP: 0x4690,\n    EF_ZIP64_OR_32: 0xffffffff,\n    EF_ZIP64_OR_16: 0xffff,\n    EF_ZIP64_SUNCOMP: 0,\n    EF_ZIP64_SCOMP: 8,\n    EF_ZIP64_RHO: 16,\n    EF_ZIP64_DSN: 24\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNiLHlCQUF5QixHQUN6QkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBRW5CLHVCQUF1QixHQUN2QkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBRW5CLHFDQUFxQyxHQUNyQ0MsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBRW5CLCtDQUErQyxHQUMvQ0MsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFFbkJDLFVBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsWUFBbUI7SUFDbkJDLFVBQW1CO0lBQ25CQyxlQUFtQjtJQUVuQkMsVUFBbUI7SUFDbkJDLFVBQW1CO0lBQ25CQyxXQUFtQjtJQUNuQkMsV0FBbUI7SUFDbkJDLFVBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsVUFBbUI7SUFDbkJDLGFBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsVUFBbUI7SUFDbkJDLFdBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsWUFBbUI7SUFFbkIsdUJBQXVCLEdBQ3ZCQyxRQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFVBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsVUFBbUI7SUFDbkJDLFVBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQixrREFBa0Q7SUFDbERDLFVBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QkMsT0FBbUI7SUFDbkIsd0JBQXdCO0lBQ3hCQyxNQUFtQjtJQUNuQiwyQkFBMkI7SUFDM0JDLFdBQW1CO0lBQ25CQyxVQUFtQjtJQUNuQkMsYUFBbUI7SUFFbkIsNEJBQTRCLEdBQzVCLCtDQUErQztJQUMvQ0MsU0FBbUI7SUFDbkJDLFdBQW1CO0lBQ25CQyxXQUFtQjtJQUNuQkMsVUFBbUI7SUFDbkJDLFNBQW1CO0lBQ25CQyxXQUFtQjtJQUNuQkMsU0FBbUI7SUFDTSwrQkFBK0I7SUFDeERDLFNBQW1CO0lBQ00sdURBQXVEO0lBQ3ZELHNEQUFzRDtJQUN0RCxrQ0FBa0M7SUFDM0RDLFNBQW1CO0lBRW5CLGFBQWEsR0FDYkMsTUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxNQUFtQjtJQUVuQiw4QkFBOEIsR0FDOUJDLE9BQW1CO0lBQ25CQyxTQUFtQjtJQUVuQixjQUFjLEdBQ2RDLFVBQW1CO0lBQ25CQyxXQUFtQjtJQUNuQkMsUUFBbUI7SUFDbkJDLFFBQW1CO0lBQ25CQyxTQUFtQjtJQUNuQkMsWUFBbUI7SUFDbkJDLFNBQW1CO0lBQ25CQyxTQUFtQjtJQUNuQkMsVUFBbUI7SUFDbkJDLGVBQW1CO0lBQ25CQyxrQkFBbUI7SUFDbkJDLGtCQUFtQjtJQUNuQkMsY0FBbUI7SUFDbkJDLGVBQW1CO0lBQ25CQyxrQkFBbUI7SUFDbkJDLFNBQW1CO0lBQ25CQyxTQUFtQjtJQUNuQkMsV0FBbUI7SUFFbkJDLGdCQUFtQjtJQUNuQkMsZ0JBQW1CO0lBQ25CQyxrQkFBbUI7SUFDbkJDLGdCQUFtQjtJQUNuQkMsY0FBbUI7SUFDbkJDLGNBQW1CO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9jb25zdGFudHMuanM/NDJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKiBUaGUgbG9jYWwgZmlsZSBoZWFkZXIgKi9cbiAgICBMT0NIRFIgICAgICAgICAgIDogMzAsIC8vIExPQyBoZWFkZXIgc2l6ZVxuICAgIExPQ1NJRyAgICAgICAgICAgOiAweDA0MDM0YjUwLCAvLyBcIlBLXFwwMDNcXDAwNFwiXG4gICAgTE9DVkVSICAgICAgICAgICA6IDQsXHQvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgTE9DRkxHICAgICAgICAgICA6IDYsIC8vIGdlbmVyYWwgcHVycG9zZSBiaXQgZmxhZ1xuICAgIExPQ0hPVyAgICAgICAgICAgOiA4LCAvLyBjb21wcmVzc2lvbiBtZXRob2RcbiAgICBMT0NUSU0gICAgICAgICAgIDogMTAsIC8vIG1vZGlmaWNhdGlvbiB0aW1lICgyIGJ5dGVzIHRpbWUsIDIgYnl0ZXMgZGF0ZSlcbiAgICBMT0NDUkMgICAgICAgICAgIDogMTQsIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgIExPQ1NJWiAgICAgICAgICAgOiAxOCwgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgTE9DTEVOICAgICAgICAgICA6IDIyLCAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIExPQ05BTSAgICAgICAgICAgOiAyNiwgLy8gZmlsZW5hbWUgbGVuZ3RoXG4gICAgTE9DRVhUICAgICAgICAgICA6IDI4LCAvLyBleHRyYSBmaWVsZCBsZW5ndGhcblxuICAgIC8qIFRoZSBEYXRhIGRlc2NyaXB0b3IgKi9cbiAgICBFWFRTSUcgICAgICAgICAgIDogMHgwODA3NGI1MCwgLy8gXCJQS1xcMDA3XFwwMDhcIlxuICAgIEVYVEhEUiAgICAgICAgICAgOiAxNiwgLy8gRVhUIGhlYWRlciBzaXplXG4gICAgRVhUQ1JDICAgICAgICAgICA6IDQsIC8vIHVuY29tcHJlc3NlZCBmaWxlIGNyYy0zMiB2YWx1ZVxuICAgIEVYVFNJWiAgICAgICAgICAgOiA4LCAvLyBjb21wcmVzc2VkIHNpemVcbiAgICBFWFRMRU4gICAgICAgICAgIDogMTIsIC8vIHVuY29tcHJlc3NlZCBzaXplXG5cbiAgICAvKiBUaGUgY2VudHJhbCBkaXJlY3RvcnkgZmlsZSBoZWFkZXIgKi9cbiAgICBDRU5IRFIgICAgICAgICAgIDogNDYsIC8vIENFTiBoZWFkZXIgc2l6ZVxuICAgIENFTlNJRyAgICAgICAgICAgOiAweDAyMDE0YjUwLCAvLyBcIlBLXFwwMDFcXDAwMlwiXG4gICAgQ0VOVkVNICAgICAgICAgICA6IDQsIC8vIHZlcnNpb24gbWFkZSBieVxuICAgIENFTlZFUiAgICAgICAgICAgOiA2LCAvLyB2ZXJzaW9uIG5lZWRlZCB0byBleHRyYWN0XG4gICAgQ0VORkxHICAgICAgICAgICA6IDgsIC8vIGVuY3J5cHQsIGRlY3J5cHQgZmxhZ3NcbiAgICBDRU5IT1cgICAgICAgICAgIDogMTAsIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIENFTlRJTSAgICAgICAgICAgOiAxMiwgLy8gbW9kaWZpY2F0aW9uIHRpbWUgKDIgYnl0ZXMgdGltZSwgMiBieXRlcyBkYXRlKVxuICAgIENFTkNSQyAgICAgICAgICAgOiAxNiwgLy8gdW5jb21wcmVzc2VkIGZpbGUgY3JjLTMyIHZhbHVlXG4gICAgQ0VOU0laICAgICAgICAgICA6IDIwLCAvLyBjb21wcmVzc2VkIHNpemVcbiAgICBDRU5MRU4gICAgICAgICAgIDogMjQsIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgQ0VOTkFNICAgICAgICAgICA6IDI4LCAvLyBmaWxlbmFtZSBsZW5ndGhcbiAgICBDRU5FWFQgICAgICAgICAgIDogMzAsIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIENFTkNPTSAgICAgICAgICAgOiAzMiwgLy8gZmlsZSBjb21tZW50IGxlbmd0aFxuICAgIENFTkRTSyAgICAgICAgICAgOiAzNCwgLy8gdm9sdW1lIG51bWJlciBzdGFydFxuICAgIENFTkFUVCAgICAgICAgICAgOiAzNiwgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzXG4gICAgQ0VOQVRYICAgICAgICAgICA6IDM4LCAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMgKGhvc3Qgc3lzdGVtIGRlcGVuZGVudClcbiAgICBDRU5PRkYgICAgICAgICAgIDogNDIsIC8vIExPQyBoZWFkZXIgb2Zmc2V0XG5cbiAgICAvKiBUaGUgZW50cmllcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5ICovXG4gICAgRU5ESERSICAgICAgICAgICA6IDIyLCAvLyBFTkQgaGVhZGVyIHNpemVcbiAgICBFTkRTSUcgICAgICAgICAgIDogMHgwNjA1NGI1MCwgLy8gXCJQS1xcMDA1XFwwMDZcIlxuICAgIEVORFNVQiAgICAgICAgICAgOiA4LCAvLyBudW1iZXIgb2YgZW50cmllcyBvbiB0aGlzIGRpc2tcbiAgICBFTkRUT1QgICAgICAgICAgIDogMTAsIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgRU5EU0laICAgICAgICAgICA6IDEyLCAvLyBjZW50cmFsIGRpcmVjdG9yeSBzaXplIGluIGJ5dGVzXG4gICAgRU5ET0ZGICAgICAgICAgICA6IDE2LCAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuICAgIEVORENPTSAgICAgICAgICAgOiAyMCwgLy8gemlwIGZpbGUgY29tbWVudCBsZW5ndGhcblxuICAgIEVORDY0SERSICAgICAgICAgOiAyMCwgLy8gemlwNjQgRU5EIGhlYWRlciBzaXplXG4gICAgRU5ENjRTSUcgICAgICAgICA6IDB4MDcwNjRiNTAsIC8vIHppcDY0IExvY2F0b3Igc2lnbmF0dXJlLCBcIlBLXFwwMDZcXDAwN1wiXG4gICAgRU5ENjRTVEFSVCAgICAgICA6IDQsIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgemlwNjRcbiAgICBFTkQ2NE9GRiAgICAgICAgIDogOCwgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIHRoZSB6aXA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcbiAgICBFTkQ2NE5VTURJU0tTICAgIDogMTYsIC8vIHRvdGFsIG51bWJlciBvZiBkaXNrc1xuXG4gICAgWklQNjRTSUcgICAgICAgICA6IDB4MDYwNjRiNTAsIC8vIHppcDY0IHNpZ25hdHVyZSwgXCJQS1xcMDA2XFwwMDZcIlxuICAgIFpJUDY0SERSICAgICAgICAgOiA1NiwgLy8gemlwNjQgcmVjb3JkIG1pbmltdW0gc2l6ZVxuICAgIFpJUDY0TEVBRCAgICAgICAgOiAxMiwgLy8gbGVhZGluZyBieXRlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlY29yZCwgbm90IGNvdW50ZWQgYnkgdGhlIHZhbHVlIHN0b3JlZCBpbiBaSVA2NFNJWkVcbiAgICBaSVA2NFNJWkUgICAgICAgIDogNCwgLy8gemlwNjQgc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgcmVjb3JkXG4gICAgWklQNjRWRU0gICAgICAgICA6IDEyLCAvLyB6aXA2NCB2ZXJzaW9uIG1hZGUgYnlcbiAgICBaSVA2NFZFUiAgICAgICAgIDogMTQsIC8vIHppcDY0IHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBaSVA2NERTSyAgICAgICAgIDogMTYsIC8vIHppcDY0IG51bWJlciBvZiB0aGlzIGRpc2tcbiAgICBaSVA2NERTS0RJUiAgICAgIDogMjAsIC8vIG51bWJlciBvZiB0aGUgZGlzayB3aXRoIHRoZSBzdGFydCBvZiB0aGUgcmVjb3JkIGRpcmVjdG9yeVxuICAgIFpJUDY0U1VCICAgICAgICAgOiAyNCwgLy8gbnVtYmVyIG9mIGVudHJpZXMgb24gdGhpcyBkaXNrXG4gICAgWklQNjRUT1QgICAgICAgICA6IDMyLCAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllc1xuICAgIFpJUDY0U0laQiAgICAgICAgOiA0MCwgLy8gemlwNjQgY2VudHJhbCBkaXJlY3Rvcnkgc2l6ZSBpbiBieXRlc1xuICAgIFpJUDY0T0ZGICAgICAgICAgOiA0OCwgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICBaSVA2NEVYVFJBICAgICAgIDogNTYsIC8vIGV4dGVuc2libGUgZGF0YSBzZWN0b3JcblxuICAgIC8qIENvbXByZXNzaW9uIG1ldGhvZHMgKi9cbiAgICBTVE9SRUQgICAgICAgICAgIDogMCwgLy8gbm8gY29tcHJlc3Npb25cbiAgICBTSFJVTksgICAgICAgICAgIDogMSwgLy8gc2hydW5rXG4gICAgUkVEVUNFRDEgICAgICAgICA6IDIsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgMVxuICAgIFJFRFVDRUQyICAgICAgICAgOiAzLCAvLyByZWR1Y2VkIHdpdGggY29tcHJlc3Npb24gZmFjdG9yIDJcbiAgICBSRURVQ0VEMyAgICAgICAgIDogNCwgLy8gcmVkdWNlZCB3aXRoIGNvbXByZXNzaW9uIGZhY3RvciAzXG4gICAgUkVEVUNFRDQgICAgICAgICA6IDUsIC8vIHJlZHVjZWQgd2l0aCBjb21wcmVzc2lvbiBmYWN0b3IgNFxuICAgIElNUExPREVEICAgICAgICAgOiA2LCAvLyBpbXBsb2RlZFxuICAgIC8vIDcgcmVzZXJ2ZWQgZm9yIFRva2VuaXppbmcgY29tcHJlc3Npb24gYWxnb3JpdGhtXG4gICAgREVGTEFURUQgICAgICAgICA6IDgsIC8vIGRlZmxhdGVkXG4gICAgRU5IQU5DRURfREVGTEFURUQ6IDksIC8vIGVuaGFuY2VkIGRlZmxhdGVkXG4gICAgUEtXQVJFICAgICAgICAgICA6IDEwLC8vIFBLV2FyZSBEQ0wgaW1wbG9kZWRcbiAgICAvLyAxMSByZXNlcnZlZCBieSBQS1dBUkVcbiAgICBCWklQMiAgICAgICAgICAgIDogMTIsIC8vICBjb21wcmVzc2VkIHVzaW5nIEJaSVAyXG4gICAgLy8gMTMgcmVzZXJ2ZWQgYnkgUEtXQVJFXG4gICAgTFpNQSAgICAgICAgICAgICA6IDE0LCAvLyBMWk1BXG4gICAgLy8gMTUtMTcgcmVzZXJ2ZWQgYnkgUEtXQVJFXG4gICAgSUJNX1RFUlNFICAgICAgICA6IDE4LCAvLyBjb21wcmVzc2VkIHVzaW5nIElCTSBURVJTRVxuICAgIElCTV9MWjc3ICAgICAgICAgOiAxOSwgLy8gSUJNIExaNzcgelxuICAgIEFFU19FTkNSWVBUICAgICAgOiA5OSwgLy8gV2luWklQIEFFUyBlbmNyeXB0aW9uIG1ldGhvZFxuXG4gICAgLyogR2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnICovXG4gICAgLy8gdmFsdWVzIGNhbiBvYnRhaW5lZCB3aXRoIGV4cHJlc3Npb24gMioqYml0bnJcbiAgICBGTEdfRU5DICAgICAgICAgIDogMSwgICAgLy8gQml0IDA6IGVuY3J5cHRlZCBmaWxlXG4gICAgRkxHX0NPTVAxICAgICAgICA6IDIsICAgIC8vIEJpdCAxLCBjb21wcmVzc2lvbiBvcHRpb25cbiAgICBGTEdfQ09NUDIgICAgICAgIDogNCwgICAgLy8gQml0IDIsIGNvbXByZXNzaW9uIG9wdGlvblxuICAgIEZMR19ERVNDICAgICAgICAgOiA4LCAgICAvLyBCaXQgMywgZGF0YSBkZXNjcmlwdG9yXG4gICAgRkxHX0VOSCAgICAgICAgICA6IDE2LCAgIC8vIEJpdCA0LCBlbmhhbmNlZCBkZWZsYXRpbmdcbiAgICBGTEdfUEFUQ0ggICAgICAgIDogMzIsICAgLy8gQml0IDUsIGluZGljYXRlcyB0aGF0IHRoZSBmaWxlIGlzIGNvbXByZXNzZWQgcGF0Y2hlZCBkYXRhLlxuICAgIEZMR19TVFIgICAgICAgICAgOiA2NCwgICAvLyBCaXQgNiwgc3Ryb25nIGVuY3J5cHRpb24gKHBhdGVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXRzIDctMTA6IEN1cnJlbnRseSB1bnVzZWQuXG4gICAgRkxHX0VGUyAgICAgICAgICA6IDIwNDgsIC8vIEJpdCAxMTogTGFuZ3VhZ2UgZW5jb2RpbmcgZmxhZyAoRUZTKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXQgMTI6IFJlc2VydmVkIGJ5IFBLV0FSRSBmb3IgZW5oYW5jZWQgY29tcHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdCAxMzogZW5jcnlwdGVkIHRoZSBDZW50cmFsIERpcmVjdG9yeSAocGF0ZW50ZWQpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXRzIDE0LTE1OiBSZXNlcnZlZCBieSBQS1dBUkUuXG4gICAgRkxHX01TSyAgICAgICAgICA6IDQwOTYsIC8vIG1hc2sgaGVhZGVyIHZhbHVlc1xuXG4gICAgLyogTG9hZCB0eXBlICovXG4gICAgRklMRSAgICAgICAgICAgICA6IDIsXG4gICAgQlVGRkVSICAgICAgICAgICA6IDEsXG4gICAgTk9ORSAgICAgICAgICAgICA6IDAsXG5cbiAgICAvKiA0LjUgRXh0ZW5zaWJsZSBkYXRhIGZpZWxkcyAqL1xuICAgIEVGX0lEICAgICAgICAgICAgOiAwLFxuICAgIEVGX1NJWkUgICAgICAgICAgOiAyLFxuXG4gICAgLyogSGVhZGVyIElEcyAqL1xuICAgIElEX1pJUDY0ICAgICAgICAgOiAweDAwMDEsXG4gICAgSURfQVZJTkZPICAgICAgICA6IDB4MDAwNyxcbiAgICBJRF9QRlMgICAgICAgICAgIDogMHgwMDA4LFxuICAgIElEX09TMiAgICAgICAgICAgOiAweDAwMDksXG4gICAgSURfTlRGUyAgICAgICAgICA6IDB4MDAwYSxcbiAgICBJRF9PUEVOVk1TICAgICAgIDogMHgwMDBjLFxuICAgIElEX1VOSVggICAgICAgICAgOiAweDAwMGQsXG4gICAgSURfRk9SSyAgICAgICAgICA6IDB4MDAwZSxcbiAgICBJRF9QQVRDSCAgICAgICAgIDogMHgwMDBmLFxuICAgIElEX1g1MDlfUEtDUzcgICAgOiAweDAwMTQsXG4gICAgSURfWDUwOV9DRVJUSURfRiA6IDB4MDAxNSxcbiAgICBJRF9YNTA5X0NFUlRJRF9DIDogMHgwMDE2LFxuICAgIElEX1NUUk9OR0VOQyAgICAgOiAweDAwMTcsXG4gICAgSURfUkVDT1JEX01HVCAgICA6IDB4MDAxOCxcbiAgICBJRF9YNTA5X1BLQ1M3X1JMIDogMHgwMDE5LFxuICAgIElEX0lCTTEgICAgICAgICAgOiAweDAwNjUsXG4gICAgSURfSUJNMiAgICAgICAgICA6IDB4MDA2NixcbiAgICBJRF9QT1NaSVAgICAgICAgIDogMHg0NjkwLFxuXG4gICAgRUZfWklQNjRfT1JfMzIgICA6IDB4ZmZmZmZmZmYsXG4gICAgRUZfWklQNjRfT1JfMTYgICA6IDB4ZmZmZixcbiAgICBFRl9aSVA2NF9TVU5DT01QIDogMCxcbiAgICBFRl9aSVA2NF9TQ09NUCAgIDogOCxcbiAgICBFRl9aSVA2NF9SSE8gICAgIDogMTYsXG4gICAgRUZfWklQNjRfRFNOICAgICA6IDI0XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJMT0NIRFIiLCJMT0NTSUciLCJMT0NWRVIiLCJMT0NGTEciLCJMT0NIT1ciLCJMT0NUSU0iLCJMT0NDUkMiLCJMT0NTSVoiLCJMT0NMRU4iLCJMT0NOQU0iLCJMT0NFWFQiLCJFWFRTSUciLCJFWFRIRFIiLCJFWFRDUkMiLCJFWFRTSVoiLCJFWFRMRU4iLCJDRU5IRFIiLCJDRU5TSUciLCJDRU5WRU0iLCJDRU5WRVIiLCJDRU5GTEciLCJDRU5IT1ciLCJDRU5USU0iLCJDRU5DUkMiLCJDRU5TSVoiLCJDRU5MRU4iLCJDRU5OQU0iLCJDRU5FWFQiLCJDRU5DT00iLCJDRU5EU0siLCJDRU5BVFQiLCJDRU5BVFgiLCJDRU5PRkYiLCJFTkRIRFIiLCJFTkRTSUciLCJFTkRTVUIiLCJFTkRUT1QiLCJFTkRTSVoiLCJFTkRPRkYiLCJFTkRDT00iLCJFTkQ2NEhEUiIsIkVORDY0U0lHIiwiRU5ENjRTVEFSVCIsIkVORDY0T0ZGIiwiRU5ENjROVU1ESVNLUyIsIlpJUDY0U0lHIiwiWklQNjRIRFIiLCJaSVA2NExFQUQiLCJaSVA2NFNJWkUiLCJaSVA2NFZFTSIsIlpJUDY0VkVSIiwiWklQNjREU0siLCJaSVA2NERTS0RJUiIsIlpJUDY0U1VCIiwiWklQNjRUT1QiLCJaSVA2NFNJWkIiLCJaSVA2NE9GRiIsIlpJUDY0RVhUUkEiLCJTVE9SRUQiLCJTSFJVTksiLCJSRURVQ0VEMSIsIlJFRFVDRUQyIiwiUkVEVUNFRDMiLCJSRURVQ0VENCIsIklNUExPREVEIiwiREVGTEFURUQiLCJFTkhBTkNFRF9ERUZMQVRFRCIsIlBLV0FSRSIsIkJaSVAyIiwiTFpNQSIsIklCTV9URVJTRSIsIklCTV9MWjc3IiwiQUVTX0VOQ1JZUFQiLCJGTEdfRU5DIiwiRkxHX0NPTVAxIiwiRkxHX0NPTVAyIiwiRkxHX0RFU0MiLCJGTEdfRU5IIiwiRkxHX1BBVENIIiwiRkxHX1NUUiIsIkZMR19FRlMiLCJGTEdfTVNLIiwiRklMRSIsIkJVRkZFUiIsIk5PTkUiLCJFRl9JRCIsIkVGX1NJWkUiLCJJRF9aSVA2NCIsIklEX0FWSU5GTyIsIklEX1BGUyIsIklEX09TMiIsIklEX05URlMiLCJJRF9PUEVOVk1TIiwiSURfVU5JWCIsIklEX0ZPUksiLCJJRF9QQVRDSCIsIklEX1g1MDlfUEtDUzciLCJJRF9YNTA5X0NFUlRJRF9GIiwiSURfWDUwOV9DRVJUSURfQyIsIklEX1NUUk9OR0VOQyIsIklEX1JFQ09SRF9NR1QiLCJJRF9YNTA5X1BLQ1M3X1JMIiwiSURfSUJNMSIsIklEX0lCTTIiLCJJRF9QT1NaSVAiLCJFRl9aSVA2NF9PUl8zMiIsIkVGX1pJUDY0X09SXzE2IiwiRUZfWklQNjRfU1VOQ09NUCIsIkVGX1pJUDY0X1NDT01QIiwiRUZfWklQNjRfUkhPIiwiRUZfWklQNjRfRFNOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/adm-zip/util/errors.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    /* Header error messages */ INVALID_LOC: \"Invalid LOC header (bad signature)\",\n    INVALID_CEN: \"Invalid CEN header (bad signature)\",\n    INVALID_END: \"Invalid END header (bad signature)\",\n    /* ZipEntry error messages*/ NO_DATA: \"Nothing to decompress\",\n    BAD_CRC: \"CRC32 checksum failed\",\n    FILE_IN_THE_WAY: \"There is a file in the way: %s\",\n    UNKNOWN_METHOD: \"Invalid/unsupported compression method\",\n    /* Inflater error messages */ AVAIL_DATA: \"inflate::Available inflate data did not terminate\",\n    INVALID_DISTANCE: \"inflate::Invalid literal/length or distance code in fixed or dynamic block\",\n    TO_MANY_CODES: \"inflate::Dynamic block code description: too many length or distance codes\",\n    INVALID_REPEAT_LEN: \"inflate::Dynamic block code description: repeat more than specified lengths\",\n    INVALID_REPEAT_FIRST: \"inflate::Dynamic block code description: repeat lengths with no first length\",\n    INCOMPLETE_CODES: \"inflate::Dynamic block code description: code lengths codes incomplete\",\n    INVALID_DYN_DISTANCE: \"inflate::Dynamic block code description: invalid distance code lengths\",\n    INVALID_CODES_LEN: \"inflate::Dynamic block code description: invalid literal/length code lengths\",\n    INVALID_STORE_BLOCK: \"inflate::Stored block length did not match one's complement\",\n    INVALID_BLOCK_TYPE: \"inflate::Invalid block type (type == 3)\",\n    /* ADM-ZIP error messages */ CANT_EXTRACT_FILE: \"Could not extract the file\",\n    CANT_OVERRIDE: \"Target file already exists\",\n    NO_ZIP: \"No zip file was loaded\",\n    NO_ENTRY: \"Entry doesn't exist\",\n    DIRECTORY_CONTENT_ERROR: \"A directory cannot have content\",\n    FILE_NOT_FOUND: \"File not found: %s\",\n    NOT_IMPLEMENTED: \"Not implemented\",\n    INVALID_FILENAME: \"Invalid filename\",\n    INVALID_FORMAT: \"Invalid or unsupported zip format. No END header found\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNiLHlCQUF5QixHQUN6QkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGFBQWE7SUFFYiwwQkFBMEIsR0FDMUJDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxpQkFBaUI7SUFDakJDLGdCQUFnQjtJQUVoQiwyQkFBMkIsR0FDM0JDLFlBQVk7SUFDWkMsa0JBQWtCO0lBQ2xCQyxlQUFlO0lBQ2ZDLG9CQUFvQjtJQUNwQkMsc0JBQXNCO0lBQ3RCQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUN0QkMsbUJBQW1CO0lBQ25CQyxxQkFBcUI7SUFDckJDLG9CQUFvQjtJQUVwQiwwQkFBMEIsR0FDMUJDLG1CQUFtQjtJQUNuQkMsZUFBZTtJQUNmQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMseUJBQXlCO0lBQ3pCQyxnQkFBZ0I7SUFDaEJDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25kYXlBc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2Vycm9ycy5qcz8yOWNhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qIEhlYWRlciBlcnJvciBtZXNzYWdlcyAqL1xuICAgIElOVkFMSURfTE9DOiBcIkludmFsaWQgTE9DIGhlYWRlciAoYmFkIHNpZ25hdHVyZSlcIixcbiAgICBJTlZBTElEX0NFTjogXCJJbnZhbGlkIENFTiBoZWFkZXIgKGJhZCBzaWduYXR1cmUpXCIsXG4gICAgSU5WQUxJRF9FTkQ6IFwiSW52YWxpZCBFTkQgaGVhZGVyIChiYWQgc2lnbmF0dXJlKVwiLFxuXG4gICAgLyogWmlwRW50cnkgZXJyb3IgbWVzc2FnZXMqL1xuICAgIE5PX0RBVEE6IFwiTm90aGluZyB0byBkZWNvbXByZXNzXCIsXG4gICAgQkFEX0NSQzogXCJDUkMzMiBjaGVja3N1bSBmYWlsZWRcIixcbiAgICBGSUxFX0lOX1RIRV9XQVk6IFwiVGhlcmUgaXMgYSBmaWxlIGluIHRoZSB3YXk6ICVzXCIsXG4gICAgVU5LTk9XTl9NRVRIT0Q6IFwiSW52YWxpZC91bnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2RcIixcblxuICAgIC8qIEluZmxhdGVyIGVycm9yIG1lc3NhZ2VzICovXG4gICAgQVZBSUxfREFUQTogXCJpbmZsYXRlOjpBdmFpbGFibGUgaW5mbGF0ZSBkYXRhIGRpZCBub3QgdGVybWluYXRlXCIsXG4gICAgSU5WQUxJRF9ESVNUQU5DRTogXCJpbmZsYXRlOjpJbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIG9yIGRpc3RhbmNlIGNvZGUgaW4gZml4ZWQgb3IgZHluYW1pYyBibG9ja1wiLFxuICAgIFRPX01BTllfQ09ERVM6IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiB0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2UgY29kZXNcIixcbiAgICBJTlZBTElEX1JFUEVBVF9MRU46IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiByZXBlYXQgbW9yZSB0aGFuIHNwZWNpZmllZCBsZW5ndGhzXCIsXG4gICAgSU5WQUxJRF9SRVBFQVRfRklSU1Q6IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiByZXBlYXQgbGVuZ3RocyB3aXRoIG5vIGZpcnN0IGxlbmd0aFwiLFxuICAgIElOQ09NUExFVEVfQ09ERVM6IFwiaW5mbGF0ZTo6RHluYW1pYyBibG9jayBjb2RlIGRlc2NyaXB0aW9uOiBjb2RlIGxlbmd0aHMgY29kZXMgaW5jb21wbGV0ZVwiLFxuICAgIElOVkFMSURfRFlOX0RJU1RBTkNFOiBcImluZmxhdGU6OkR5bmFtaWMgYmxvY2sgY29kZSBkZXNjcmlwdGlvbjogaW52YWxpZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHNcIixcbiAgICBJTlZBTElEX0NPREVTX0xFTjogXCJpbmZsYXRlOjpEeW5hbWljIGJsb2NrIGNvZGUgZGVzY3JpcHRpb246IGludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSBsZW5ndGhzXCIsXG4gICAgSU5WQUxJRF9TVE9SRV9CTE9DSzogXCJpbmZsYXRlOjpTdG9yZWQgYmxvY2sgbGVuZ3RoIGRpZCBub3QgbWF0Y2ggb25lJ3MgY29tcGxlbWVudFwiLFxuICAgIElOVkFMSURfQkxPQ0tfVFlQRTogXCJpbmZsYXRlOjpJbnZhbGlkIGJsb2NrIHR5cGUgKHR5cGUgPT0gMylcIixcblxuICAgIC8qIEFETS1aSVAgZXJyb3IgbWVzc2FnZXMgKi9cbiAgICBDQU5UX0VYVFJBQ1RfRklMRTogXCJDb3VsZCBub3QgZXh0cmFjdCB0aGUgZmlsZVwiLFxuICAgIENBTlRfT1ZFUlJJREU6IFwiVGFyZ2V0IGZpbGUgYWxyZWFkeSBleGlzdHNcIixcbiAgICBOT19aSVA6IFwiTm8gemlwIGZpbGUgd2FzIGxvYWRlZFwiLFxuICAgIE5PX0VOVFJZOiBcIkVudHJ5IGRvZXNuJ3QgZXhpc3RcIixcbiAgICBESVJFQ1RPUllfQ09OVEVOVF9FUlJPUjogXCJBIGRpcmVjdG9yeSBjYW5ub3QgaGF2ZSBjb250ZW50XCIsXG4gICAgRklMRV9OT1RfRk9VTkQ6IFwiRmlsZSBub3QgZm91bmQ6ICVzXCIsXG4gICAgTk9UX0lNUExFTUVOVEVEOiBcIk5vdCBpbXBsZW1lbnRlZFwiLFxuICAgIElOVkFMSURfRklMRU5BTUU6IFwiSW52YWxpZCBmaWxlbmFtZVwiLFxuICAgIElOVkFMSURfRk9STUFUOiBcIkludmFsaWQgb3IgdW5zdXBwb3J0ZWQgemlwIGZvcm1hdC4gTm8gRU5EIGhlYWRlciBmb3VuZFwiXG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJJTlZBTElEX0xPQyIsIklOVkFMSURfQ0VOIiwiSU5WQUxJRF9FTkQiLCJOT19EQVRBIiwiQkFEX0NSQyIsIkZJTEVfSU5fVEhFX1dBWSIsIlVOS05PV05fTUVUSE9EIiwiQVZBSUxfREFUQSIsIklOVkFMSURfRElTVEFOQ0UiLCJUT19NQU5ZX0NPREVTIiwiSU5WQUxJRF9SRVBFQVRfTEVOIiwiSU5WQUxJRF9SRVBFQVRfRklSU1QiLCJJTkNPTVBMRVRFX0NPREVTIiwiSU5WQUxJRF9EWU5fRElTVEFOQ0UiLCJJTlZBTElEX0NPREVTX0xFTiIsIklOVkFMSURfU1RPUkVfQkxPQ0siLCJJTlZBTElEX0JMT0NLX1RZUEUiLCJDQU5UX0VYVFJBQ1RfRklMRSIsIkNBTlRfT1ZFUlJJREUiLCJOT19aSVAiLCJOT19FTlRSWSIsIkRJUkVDVE9SWV9DT05URU5UX0VSUk9SIiwiRklMRV9OT1RfRk9VTkQiLCJOT1RfSU1QTEVNRU5URUQiLCJJTlZBTElEX0ZJTEVOQU1FIiwiSU5WQUxJRF9GT1JNQVQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/fattr.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/fattr.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = (__webpack_require__(/*! ./fileSystem */ \"(rsc)/./node_modules/adm-zip/util/fileSystem.js\").require)();\nconst pth = __webpack_require__(/*! path */ \"path\");\nfs.existsSync = fs.existsSync || pth.existsSync;\nmodule.exports = function(/*String*/ path) {\n    var _path = path || \"\", _obj = newAttr(), _stat = null;\n    function newAttr() {\n        return {\n            directory: false,\n            readonly: false,\n            hidden: false,\n            executable: false,\n            mtime: 0,\n            atime: 0\n        };\n    }\n    if (_path && fs.existsSync(_path)) {\n        _stat = fs.statSync(_path);\n        _obj.directory = _stat.isDirectory();\n        _obj.mtime = _stat.mtime;\n        _obj.atime = _stat.atime;\n        _obj.executable = (73 & _stat.mode) !== 0; // file is executable who ever har right not just owner\n        _obj.readonly = (128 & _stat.mode) === 0; // readonly if owner has no write right\n        _obj.hidden = pth.basename(_path)[0] === \".\";\n    } else {\n        console.warn(\"Invalid path: \" + _path);\n    }\n    return {\n        get directory () {\n            return _obj.directory;\n        },\n        get readOnly () {\n            return _obj.readonly;\n        },\n        get hidden () {\n            return _obj.hidden;\n        },\n        get mtime () {\n            return _obj.mtime;\n        },\n        get atime () {\n            return _obj.atime;\n        },\n        get executable () {\n            return _obj.executable;\n        },\n        decodeAttributes: function() {},\n        encodeAttributes: function() {},\n        toJSON: function() {\n            return {\n                path: _path,\n                isDirectory: _obj.directory,\n                isReadOnly: _obj.readonly,\n                isHidden: _obj.hidden,\n                isExecutable: _obj.executable,\n                mTime: _obj.mtime,\n                aTime: _obj.atime\n            };\n        },\n        toString: function() {\n            return JSON.stringify(this.toJSON(), null, \"\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2ZhdHRyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxLQUFLQyxvR0FBK0I7QUFDMUMsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUMsa0JBQU07QUFFMUJELEdBQUdHLFVBQVUsR0FBR0gsR0FBR0csVUFBVSxJQUFJRCxJQUFJQyxVQUFVO0FBRS9DQyxPQUFPQyxPQUFPLEdBQUcsU0FBVSxRQUFRLEdBQUdDLElBQUk7SUFDdEMsSUFBSUMsUUFBUUQsUUFBUSxJQUNoQkUsT0FBT0MsV0FDUEMsUUFBUTtJQUVaLFNBQVNEO1FBQ0wsT0FBTztZQUNIRSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkMsUUFBUTtZQUNSQyxZQUFZO1lBQ1pDLE9BQU87WUFDUEMsT0FBTztRQUNYO0lBQ0o7SUFFQSxJQUFJVCxTQUFTUCxHQUFHRyxVQUFVLENBQUNJLFFBQVE7UUFDL0JHLFFBQVFWLEdBQUdpQixRQUFRLENBQUNWO1FBQ3BCQyxLQUFLRyxTQUFTLEdBQUdELE1BQU1RLFdBQVc7UUFDbENWLEtBQUtPLEtBQUssR0FBR0wsTUFBTUssS0FBSztRQUN4QlAsS0FBS1EsS0FBSyxHQUFHTixNQUFNTSxLQUFLO1FBQ3hCUixLQUFLTSxVQUFVLEdBQUcsQ0FBQyxLQUFRSixNQUFNUyxJQUFJLE1BQU0sR0FBRyx1REFBdUQ7UUFDckdYLEtBQUtJLFFBQVEsR0FBRyxDQUFDLE1BQVFGLE1BQU1TLElBQUksTUFBTSxHQUFHLHVDQUF1QztRQUNuRlgsS0FBS0ssTUFBTSxHQUFHWCxJQUFJa0IsUUFBUSxDQUFDYixNQUFNLENBQUMsRUFBRSxLQUFLO0lBQzdDLE9BQU87UUFDSGMsUUFBUUMsSUFBSSxDQUFDLG1CQUFtQmY7SUFDcEM7SUFFQSxPQUFPO1FBQ0gsSUFBSUksYUFBWTtZQUNaLE9BQU9ILEtBQUtHLFNBQVM7UUFDekI7UUFFQSxJQUFJWSxZQUFXO1lBQ1gsT0FBT2YsS0FBS0ksUUFBUTtRQUN4QjtRQUVBLElBQUlDLFVBQVM7WUFDVCxPQUFPTCxLQUFLSyxNQUFNO1FBQ3RCO1FBRUEsSUFBSUUsU0FBUTtZQUNSLE9BQU9QLEtBQUtPLEtBQUs7UUFDckI7UUFFQSxJQUFJQyxTQUFRO1lBQ1IsT0FBT1IsS0FBS1EsS0FBSztRQUNyQjtRQUVBLElBQUlGLGNBQWE7WUFDYixPQUFPTixLQUFLTSxVQUFVO1FBQzFCO1FBRUFVLGtCQUFrQixZQUFhO1FBRS9CQyxrQkFBa0IsWUFBYTtRQUUvQkMsUUFBUTtZQUNKLE9BQU87Z0JBQ0hwQixNQUFNQztnQkFDTlcsYUFBYVYsS0FBS0csU0FBUztnQkFDM0JnQixZQUFZbkIsS0FBS0ksUUFBUTtnQkFDekJnQixVQUFVcEIsS0FBS0ssTUFBTTtnQkFDckJnQixjQUFjckIsS0FBS00sVUFBVTtnQkFDN0JnQixPQUFPdEIsS0FBS08sS0FBSztnQkFDakJnQixPQUFPdkIsS0FBS1EsS0FBSztZQUNyQjtRQUNKO1FBRUFnQixVQUFVO1lBQ04sT0FBT0MsS0FBS0MsU0FBUyxDQUFDLElBQUksQ0FBQ1IsTUFBTSxJQUFJLE1BQU07UUFDL0M7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9mYXR0ci5qcz9jOWUzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZShcIi4vZmlsZVN5c3RlbVwiKS5yZXF1aXJlKCk7XG5jb25zdCBwdGggPSByZXF1aXJlKFwicGF0aFwiKTtcblxuZnMuZXhpc3RzU3luYyA9IGZzLmV4aXN0c1N5bmMgfHwgcHRoLmV4aXN0c1N5bmM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCkge1xuICAgIHZhciBfcGF0aCA9IHBhdGggfHwgXCJcIixcbiAgICAgICAgX29iaiA9IG5ld0F0dHIoKSxcbiAgICAgICAgX3N0YXQgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gbmV3QXR0cigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdG9yeTogZmFsc2UsXG4gICAgICAgICAgICByZWFkb25seTogZmFsc2UsXG4gICAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgZXhlY3V0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBtdGltZTogMCxcbiAgICAgICAgICAgIGF0aW1lOiAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKF9wYXRoICYmIGZzLmV4aXN0c1N5bmMoX3BhdGgpKSB7XG4gICAgICAgIF9zdGF0ID0gZnMuc3RhdFN5bmMoX3BhdGgpO1xuICAgICAgICBfb2JqLmRpcmVjdG9yeSA9IF9zdGF0LmlzRGlyZWN0b3J5KCk7XG4gICAgICAgIF9vYmoubXRpbWUgPSBfc3RhdC5tdGltZTtcbiAgICAgICAgX29iai5hdGltZSA9IF9zdGF0LmF0aW1lO1xuICAgICAgICBfb2JqLmV4ZWN1dGFibGUgPSAoMG8xMTEgJiBfc3RhdC5tb2RlKSAhPT0gMDsgLy8gZmlsZSBpcyBleGVjdXRhYmxlIHdobyBldmVyIGhhciByaWdodCBub3QganVzdCBvd25lclxuICAgICAgICBfb2JqLnJlYWRvbmx5ID0gKDBvMjAwICYgX3N0YXQubW9kZSkgPT09IDA7IC8vIHJlYWRvbmx5IGlmIG93bmVyIGhhcyBubyB3cml0ZSByaWdodFxuICAgICAgICBfb2JqLmhpZGRlbiA9IHB0aC5iYXNlbmFtZShfcGF0aClbMF0gPT09IFwiLlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcGF0aDogXCIgKyBfcGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGRpcmVjdG9yeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmRpcmVjdG9yeTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgcmVhZE9ubHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iai5yZWFkb25seTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmouaGlkZGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLm10aW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBhdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqLmF0aW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBleGVjdXRhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmouZXhlY3V0YWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWNvZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICBlbmNvZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICAgICAgaXNEaXJlY3Rvcnk6IF9vYmouZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IF9vYmoucmVhZG9ubHksXG4gICAgICAgICAgICAgICAgaXNIaWRkZW46IF9vYmouaGlkZGVuLFxuICAgICAgICAgICAgICAgIGlzRXhlY3V0YWJsZTogX29iai5leGVjdXRhYmxlLFxuICAgICAgICAgICAgICAgIG1UaW1lOiBfb2JqLm10aW1lLFxuICAgICAgICAgICAgICAgIGFUaW1lOiBfb2JqLmF0aW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwdGgiLCJleGlzdHNTeW5jIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhdGgiLCJfcGF0aCIsIl9vYmoiLCJuZXdBdHRyIiwiX3N0YXQiLCJkaXJlY3RvcnkiLCJyZWFkb25seSIsImhpZGRlbiIsImV4ZWN1dGFibGUiLCJtdGltZSIsImF0aW1lIiwic3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsIm1vZGUiLCJiYXNlbmFtZSIsImNvbnNvbGUiLCJ3YXJuIiwicmVhZE9ubHkiLCJkZWNvZGVBdHRyaWJ1dGVzIiwiZW5jb2RlQXR0cmlidXRlcyIsInRvSlNPTiIsImlzUmVhZE9ubHkiLCJpc0hpZGRlbiIsImlzRXhlY3V0YWJsZSIsIm1UaW1lIiwiYVRpbWUiLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/fattr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/fileSystem.js":
/*!*************************************************!*\
  !*** ./node_modules/adm-zip/util/fileSystem.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.require = function() {\n    if (typeof process === \"object\" && process.versions && process.versions[\"electron\"]) {\n        try {\n            const originalFs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'original-fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n            if (Object.keys(originalFs).length > 0) {\n                return originalFs;\n            }\n        } catch (e) {}\n    }\n    return __webpack_require__(/*! fs */ \"fs\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2ZpbGVTeXN0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQUFBLGVBQWUsR0FBRztJQUNkLElBQUksT0FBT0UsWUFBWSxZQUFZQSxRQUFRQyxRQUFRLElBQUlELFFBQVFDLFFBQVEsQ0FBQyxXQUFXLEVBQUU7UUFDakYsSUFBSTtZQUNBLE1BQU1DLGFBQWFILG1CQUFPQSxDQUFDLDBJQUFhO1lBQ3hDLElBQUlJLE9BQU9DLElBQUksQ0FBQ0YsWUFBWUcsTUFBTSxHQUFHLEdBQUc7Z0JBQ3BDLE9BQU9IO1lBQ1g7UUFDSixFQUFFLE9BQU9JLEdBQUcsQ0FBQztJQUNqQjtJQUNBLE9BQU9QLG1CQUFPQSxDQUFDLGNBQUk7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25kYXlBc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2ZpbGVTeXN0ZW0uanM/YzNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLnJlcXVpcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9uc1tcImVsZWN0cm9uXCJdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbEZzID0gcmVxdWlyZShcIm9yaWdpbmFsLWZzXCIpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9yaWdpbmFsRnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVpcmUoXCJmc1wiKTtcbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsInJlcXVpcmUiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJvcmlnaW5hbEZzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/fileSystem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/index.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/adm-zip/util/utils.js\");\nmodule.exports.Constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/adm-zip/util/constants.js\");\nmodule.exports.Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/adm-zip/util/errors.js\");\nmodule.exports.FileAttr = __webpack_require__(/*! ./fattr */ \"(rsc)/./node_modules/adm-zip/util/fattr.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWRtLXppcC91dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsaUdBQW1DO0FBQ25DQSxtSEFBaUQ7QUFDakRBLDBHQUEyQztBQUMzQ0EsMEdBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC9pbmRleC5qcz8wODI1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5Db25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5tb2R1bGUuZXhwb3J0cy5FcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5tb2R1bGUuZXhwb3J0cy5GaWxlQXR0ciA9IHJlcXVpcmUoXCIuL2ZhdHRyXCIpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiQ29uc3RhbnRzIiwiRXJyb3JzIiwiRmlsZUF0dHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/util/utils.js":
/*!********************************************!*\
  !*** ./node_modules/adm-zip/util/utils.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fsystem = (__webpack_require__(/*! ./fileSystem */ \"(rsc)/./node_modules/adm-zip/util/fileSystem.js\").require)();\nconst pth = __webpack_require__(/*! path */ \"path\");\nconst Constants = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/adm-zip/util/constants.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/adm-zip/util/errors.js\");\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\nconst is_Obj = (obj)=>obj && typeof obj === \"object\";\n// generate CRC32 lookup table\nconst crcTable = new Uint32Array(256).map((t, c)=>{\n    for(let k = 0; k < 8; k++){\n        if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ c >>> 1;\n        } else {\n            c >>>= 1;\n        }\n    }\n    return c >>> 0;\n});\n// UTILS functions\nfunction Utils(opts) {\n    this.sep = pth.sep;\n    this.fs = fsystem;\n    if (is_Obj(opts)) {\n        // custom filesystem\n        if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n            this.fs = opts.fs;\n        }\n    }\n}\nmodule.exports = Utils;\n// INSTANCED functions\nUtils.prototype.makeDir = function(/*String*/ folder) {\n    const self = this;\n    // Sync - make directories tree\n    function mkdirSync(/*String*/ fpath) {\n        let resolvedPath = fpath.split(self.sep)[0];\n        fpath.split(self.sep).forEach(function(name) {\n            if (!name || name.substr(-1, 1) === \":\") return;\n            resolvedPath += self.sep + name;\n            var stat;\n            try {\n                stat = self.fs.statSync(resolvedPath);\n            } catch (e) {\n                self.fs.mkdirSync(resolvedPath);\n            }\n            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\n        });\n    }\n    mkdirSync(folder);\n};\nUtils.prototype.writeFileTo = function(/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {\n    const self = this;\n    if (self.fs.existsSync(path)) {\n        if (!overwrite) return false; // cannot overwrite\n        var stat = self.fs.statSync(path);\n        if (stat.isDirectory()) {\n            return false;\n        }\n    }\n    var folder = pth.dirname(path);\n    if (!self.fs.existsSync(folder)) {\n        self.makeDir(folder);\n    }\n    var fd;\n    try {\n        fd = self.fs.openSync(path, \"w\", 438); // 0666\n    } catch (e) {\n        self.fs.chmodSync(path, 438);\n        fd = self.fs.openSync(path, \"w\", 438);\n    }\n    if (fd) {\n        try {\n            self.fs.writeSync(fd, content, 0, content.length, 0);\n        } finally{\n            self.fs.closeSync(fd);\n        }\n    }\n    self.fs.chmodSync(path, attr || 438);\n    return true;\n};\nUtils.prototype.writeFileToAsync = function(/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {\n    if (typeof attr === \"function\") {\n        callback = attr;\n        attr = undefined;\n    }\n    const self = this;\n    self.fs.exists(path, function(exist) {\n        if (exist && !overwrite) return callback(false);\n        self.fs.stat(path, function(err, stat) {\n            if (exist && stat.isDirectory()) {\n                return callback(false);\n            }\n            var folder = pth.dirname(path);\n            self.fs.exists(folder, function(exists) {\n                if (!exists) self.makeDir(folder);\n                self.fs.open(path, \"w\", 438, function(err, fd) {\n                    if (err) {\n                        self.fs.chmod(path, 438, function() {\n                            self.fs.open(path, \"w\", 438, function(err, fd) {\n                                self.fs.write(fd, content, 0, content.length, 0, function() {\n                                    self.fs.close(fd, function() {\n                                        self.fs.chmod(path, attr || 438, function() {\n                                            callback(true);\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                    } else if (fd) {\n                        self.fs.write(fd, content, 0, content.length, 0, function() {\n                            self.fs.close(fd, function() {\n                                self.fs.chmod(path, attr || 438, function() {\n                                    callback(true);\n                                });\n                            });\n                        });\n                    } else {\n                        self.fs.chmod(path, attr || 438, function() {\n                            callback(true);\n                        });\n                    }\n                });\n            });\n        });\n    });\n};\nUtils.prototype.findFiles = function(/*String*/ path) {\n    const self = this;\n    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {\n        if (typeof pattern === \"boolean\") {\n            recursive = pattern;\n            pattern = undefined;\n        }\n        let files = [];\n        self.fs.readdirSync(dir).forEach(function(file) {\n            var path = pth.join(dir, file);\n            if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n            if (!pattern || pattern.test(path)) {\n                files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : \"\"));\n            }\n        });\n        return files;\n    }\n    return findSync(path, undefined, true);\n};\nUtils.prototype.getAttributes = function() {};\nUtils.prototype.setAttributes = function() {};\n// STATIC functions\n// crc32 single update (it is part of crc32)\nUtils.crc32update = function(crc, byte) {\n    return crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n};\nUtils.crc32 = function(buf) {\n    if (typeof buf === \"string\") {\n        buf = Buffer.from(buf, \"utf8\");\n    }\n    // Generate crcTable\n    if (!crcTable.length) genCRCTable();\n    let len = buf.length;\n    let crc = ~0;\n    for(let off = 0; off < len;)crc = Utils.crc32update(crc, buf[off++]);\n    // xor and cast as uint32 number\n    return ~crc >>> 0;\n};\nUtils.methodToString = function(/*Number*/ method) {\n    switch(method){\n        case Constants.STORED:\n            return \"STORED (\" + method + \")\";\n        case Constants.DEFLATED:\n            return \"DEFLATED (\" + method + \")\";\n        default:\n            return \"UNSUPPORTED (\" + method + \")\";\n    }\n};\n// removes \"..\" style path elements\nUtils.canonical = function(/*string*/ path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    var safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.join(\".\", safeSuffix);\n};\n// make abolute paths taking prefix as root folder\nUtils.sanitize = function(/*string*/ prefix, /*string*/ name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split(\"/\");\n    for(var i = 0, l = parts.length; i < l; i++){\n        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n        if (path.indexOf(prefix) === 0) {\n            return path;\n        }\n    }\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n};\n// converts buffer, Uint8Array, string types to buffer\nUtils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {\n    if (Buffer.isBuffer(input)) {\n        return input;\n    } else if (input instanceof Uint8Array) {\n        return Buffer.from(input);\n    } else {\n        // expect string all other values are invalid and return empty buffer\n        return typeof input === \"string\" ? Buffer.from(input, \"utf8\") : Buffer.alloc(0);\n    }\n};\nUtils.readBigUInt64LE = function(/*Buffer*/ buffer, /*int*/ index) {\n    var slice = Buffer.from(buffer.slice(index, index + 8));\n    slice.swap64();\n    return parseInt(`0x${slice.toString(\"hex\")}`);\n};\nUtils.isWin = isWin; // Do we have windows system\nUtils.crcTable = crcTable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2pEVyxNQUFNTixRQUFRLEdBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvdXRpbC91dGlscy5qcz85OGExIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzeXN0ZW0gPSByZXF1aXJlKFwiLi9maWxlU3lzdGVtXCIpLnJlcXVpcmUoKTtcbmNvbnN0IHB0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXNXaW4gPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBcIndpbjMyXCIgPT09IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IGlzX09iaiA9IChvYmopID0+IG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiO1xuXG4vLyBnZW5lcmF0ZSBDUkMzMiBsb29rdXAgdGFibGVcbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKCh0LCBjKSA9PiB7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgaWYgKChjICYgMSkgIT09IDApIHtcbiAgICAgICAgICAgIGMgPSAweGVkYjg4MzIwIF4gKGMgPj4+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyA+Pj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGMgPj4+IDA7XG59KTtcblxuLy8gVVRJTFMgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIFV0aWxzKG9wdHMpIHtcbiAgICB0aGlzLnNlcCA9IHB0aC5zZXA7XG4gICAgdGhpcy5mcyA9IGZzeXN0ZW07XG5cbiAgICBpZiAoaXNfT2JqKG9wdHMpKSB7XG4gICAgICAgIC8vIGN1c3RvbSBmaWxlc3lzdGVtXG4gICAgICAgIGlmIChpc19PYmoob3B0cy5mcykgJiYgdHlwZW9mIG9wdHMuZnMuc3RhdFN5bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5mcyA9IG9wdHMuZnM7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8vIElOU1RBTkNFRCBmdW5jdGlvbnNcblxuVXRpbHMucHJvdG90eXBlLm1ha2VEaXIgPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBmb2xkZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIFN5bmMgLSBtYWtlIGRpcmVjdG9yaWVzIHRyZWVcbiAgICBmdW5jdGlvbiBta2RpclN5bmMoLypTdHJpbmcqLyBmcGF0aCkge1xuICAgICAgICBsZXQgcmVzb2x2ZWRQYXRoID0gZnBhdGguc3BsaXQoc2VsZi5zZXApWzBdO1xuICAgICAgICBmcGF0aC5zcGxpdChzZWxmLnNlcCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUuc3Vic3RyKC0xLCAxKSA9PT0gXCI6XCIpIHJldHVybjtcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCArPSBzZWxmLnNlcCArIG5hbWU7XG4gICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IHNlbGYuZnMuc3RhdFN5bmMocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZzLm1rZGlyU3luYyhyZXNvbHZlZFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXQgJiYgc3RhdC5pc0ZpbGUoKSkgdGhyb3cgRXJyb3JzLkZJTEVfSU5fVEhFX1dBWS5yZXBsYWNlKFwiJXNcIiwgcmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWtkaXJTeW5jKGZvbGRlcik7XG59O1xuXG5VdGlscy5wcm90b3R5cGUud3JpdGVGaWxlVG8gPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBwYXRoLCAvKkJ1ZmZlciovIGNvbnRlbnQsIC8qQm9vbGVhbiovIG92ZXJ3cml0ZSwgLypOdW1iZXIqLyBhdHRyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYuZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgICBpZiAoIW92ZXJ3cml0ZSkgcmV0dXJuIGZhbHNlOyAvLyBjYW5ub3Qgb3ZlcndyaXRlXG5cbiAgICAgICAgdmFyIHN0YXQgPSBzZWxmLmZzLnN0YXRTeW5jKHBhdGgpO1xuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZvbGRlciA9IHB0aC5kaXJuYW1lKHBhdGgpO1xuICAgIGlmICghc2VsZi5mcy5leGlzdHNTeW5jKGZvbGRlcikpIHtcbiAgICAgICAgc2VsZi5tYWtlRGlyKGZvbGRlcik7XG4gICAgfVxuXG4gICAgdmFyIGZkO1xuICAgIHRyeSB7XG4gICAgICAgIGZkID0gc2VsZi5mcy5vcGVuU3luYyhwYXRoLCBcIndcIiwgNDM4KTsgLy8gMDY2NlxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5mcy5jaG1vZFN5bmMocGF0aCwgNDM4KTtcbiAgICAgICAgZmQgPSBzZWxmLmZzLm9wZW5TeW5jKHBhdGgsIFwid1wiLCA0MzgpO1xuICAgIH1cbiAgICBpZiAoZmQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbGYuZnMud3JpdGVTeW5jKGZkLCBjb250ZW50LCAwLCBjb250ZW50Lmxlbmd0aCwgMCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZWxmLmZzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5mcy5jaG1vZFN5bmMocGF0aCwgYXR0ciB8fCA0MzgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuVXRpbHMucHJvdG90eXBlLndyaXRlRmlsZVRvQXN5bmMgPSBmdW5jdGlvbiAoLypTdHJpbmcqLyBwYXRoLCAvKkJ1ZmZlciovIGNvbnRlbnQsIC8qQm9vbGVhbiovIG92ZXJ3cml0ZSwgLypOdW1iZXIqLyBhdHRyLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGF0dHIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IGF0dHI7XG4gICAgICAgIGF0dHIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLmZzLmV4aXN0cyhwYXRoLCBmdW5jdGlvbiAoZXhpc3QpIHtcbiAgICAgICAgaWYgKGV4aXN0ICYmICFvdmVyd3JpdGUpIHJldHVybiBjYWxsYmFjayhmYWxzZSk7XG5cbiAgICAgICAgc2VsZi5mcy5zdGF0KHBhdGgsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgICAgIGlmIChleGlzdCAmJiBzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9sZGVyID0gcHRoLmRpcm5hbWUocGF0aCk7XG4gICAgICAgICAgICBzZWxmLmZzLmV4aXN0cyhmb2xkZXIsIGZ1bmN0aW9uIChleGlzdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykgc2VsZi5tYWtlRGlyKGZvbGRlcik7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmZzLm9wZW4ocGF0aCwgXCJ3XCIsIDQzOCwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jaG1vZChwYXRoLCA0MzgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLm9wZW4ocGF0aCwgXCJ3XCIsIDQzOCwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy53cml0ZShmZCwgY29udGVudCwgMCwgY29udGVudC5sZW5ndGgsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMuY2xvc2UoZmQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIGF0dHIgfHwgNDM4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMud3JpdGUoZmQsIGNvbnRlbnQsIDAsIGNvbnRlbnQubGVuZ3RoLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mcy5jbG9zZShmZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZzLmNobW9kKHBhdGgsIGF0dHIgfHwgNDM4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZnMuY2htb2QocGF0aCwgYXR0ciB8fCA0MzgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5VdGlscy5wcm90b3R5cGUuZmluZEZpbGVzID0gZnVuY3Rpb24gKC8qU3RyaW5nKi8gcGF0aCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmluZFN5bmMoLypTdHJpbmcqLyBkaXIsIC8qUmVnRXhwKi8gcGF0dGVybiwgLypCb29sZWFuKi8gcmVjdXJzaXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IHBhdHRlcm47XG4gICAgICAgICAgICBwYXR0ZXJuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlcyA9IFtdO1xuICAgICAgICBzZWxmLmZzLnJlYWRkaXJTeW5jKGRpcikuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwdGguam9pbihkaXIsIGZpbGUpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5mcy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpICYmIHJlY3Vyc2l2ZSkgZmlsZXMgPSBmaWxlcy5jb25jYXQoZmluZFN5bmMocGF0aCwgcGF0dGVybiwgcmVjdXJzaXZlKSk7XG5cbiAgICAgICAgICAgIGlmICghcGF0dGVybiB8fCBwYXR0ZXJuLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHB0aC5ub3JtYWxpemUocGF0aCkgKyAoc2VsZi5mcy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpID8gc2VsZi5zZXAgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRTeW5jKHBhdGgsIHVuZGVmaW5lZCwgdHJ1ZSk7XG59O1xuXG5VdGlscy5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5VdGlscy5wcm90b3R5cGUuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBTVEFUSUMgZnVuY3Rpb25zXG5cbi8vIGNyYzMyIHNpbmdsZSB1cGRhdGUgKGl0IGlzIHBhcnQgb2YgY3JjMzIpXG5VdGlscy5jcmMzMnVwZGF0ZSA9IGZ1bmN0aW9uIChjcmMsIGJ5dGUpIHtcbiAgICByZXR1cm4gY3JjVGFibGVbKGNyYyBeIGJ5dGUpICYgMHhmZl0gXiAoY3JjID4+PiA4KTtcbn07XG5cblV0aWxzLmNyYzMyID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgXCJ1dGY4XCIpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBjcmNUYWJsZVxuICAgIGlmICghY3JjVGFibGUubGVuZ3RoKSBnZW5DUkNUYWJsZSgpO1xuXG4gICAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgbGV0IGNyYyA9IH4wO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IG9mZiA8IGxlbjsgKSBjcmMgPSBVdGlscy5jcmMzMnVwZGF0ZShjcmMsIGJ1ZltvZmYrK10pO1xuICAgIC8vIHhvciBhbmQgY2FzdCBhcyB1aW50MzIgbnVtYmVyXG4gICAgcmV0dXJuIH5jcmMgPj4+IDA7XG59O1xuXG5VdGlscy5tZXRob2RUb1N0cmluZyA9IGZ1bmN0aW9uICgvKk51bWJlciovIG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgQ29uc3RhbnRzLlNUT1JFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlNUT1JFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgY2FzZSBDb25zdGFudHMuREVGTEFURUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJERUZMQVRFRCAoXCIgKyBtZXRob2QgKyBcIilcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOU1VQUE9SVEVEIChcIiArIG1ldGhvZCArIFwiKVwiO1xuICAgIH1cbn07XG5cbi8vIHJlbW92ZXMgXCIuLlwiIHN0eWxlIHBhdGggZWxlbWVudHNcblV0aWxzLmNhbm9uaWNhbCA9IGZ1bmN0aW9uICgvKnN0cmluZyovIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBcIlwiO1xuICAgIC8vIHRyaWNrIG5vcm1hbGl6ZSB0aGluayBwYXRoIGlzIGFic29sdXRlXG4gICAgdmFyIHNhZmVTdWZmaXggPSBwdGgucG9zaXgubm9ybWFsaXplKFwiL1wiICsgcGF0aC5zcGxpdChcIlxcXFxcIikuam9pbihcIi9cIikpO1xuICAgIHJldHVybiBwdGguam9pbihcIi5cIiwgc2FmZVN1ZmZpeCk7XG59O1xuXG4vLyBtYWtlIGFib2x1dGUgcGF0aHMgdGFraW5nIHByZWZpeCBhcyByb290IGZvbGRlclxuVXRpbHMuc2FuaXRpemUgPSBmdW5jdGlvbiAoLypzdHJpbmcqLyBwcmVmaXgsIC8qc3RyaW5nKi8gbmFtZSkge1xuICAgIHByZWZpeCA9IHB0aC5yZXNvbHZlKHB0aC5ub3JtYWxpemUocHJlZml4KSk7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcGFydHMuc2xpY2UoaSwgbCkuam9pbihwdGguc2VwKSkpO1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwdGgubm9ybWFsaXplKHB0aC5qb2luKHByZWZpeCwgcHRoLmJhc2VuYW1lKG5hbWUpKSk7XG59O1xuXG4vLyBjb252ZXJ0cyBidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyB0eXBlcyB0byBidWZmZXJcblV0aWxzLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIoLypidWZmZXIsIFVpbnQ4QXJyYXksIHN0cmluZyovIGlucHV0KSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhwZWN0IHN0cmluZyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBpbnZhbGlkIGFuZCByZXR1cm4gZW1wdHkgYnVmZmVyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBCdWZmZXIuZnJvbShpbnB1dCwgXCJ1dGY4XCIpIDogQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbn07XG5cblV0aWxzLnJlYWRCaWdVSW50NjRMRSA9IGZ1bmN0aW9uICgvKkJ1ZmZlciovIGJ1ZmZlciwgLyppbnQqLyBpbmRleCkge1xuICAgIHZhciBzbGljZSA9IEJ1ZmZlci5mcm9tKGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyA4KSk7XG4gICAgc2xpY2Uuc3dhcDY0KCk7XG5cbiAgICByZXR1cm4gcGFyc2VJbnQoYDB4JHtzbGljZS50b1N0cmluZyhcImhleFwiKX1gKTtcbn07XG5cblV0aWxzLmlzV2luID0gaXNXaW47IC8vIERvIHdlIGhhdmUgd2luZG93cyBzeXN0ZW1cblV0aWxzLmNyY1RhYmxlID0gY3JjVGFibGU7XG4iXSwibmFtZXMiOlsiZnN5c3RlbSIsInJlcXVpcmUiLCJwdGgiLCJDb25zdGFudHMiLCJFcnJvcnMiLCJpc1dpbiIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImlzX09iaiIsIm9iaiIsImNyY1RhYmxlIiwiVWludDMyQXJyYXkiLCJtYXAiLCJ0IiwiYyIsImsiLCJVdGlscyIsIm9wdHMiLCJzZXAiLCJmcyIsInN0YXRTeW5jIiwibW9kdWxlIiwiZXhwb3J0cyIsInByb3RvdHlwZSIsIm1ha2VEaXIiLCJmb2xkZXIiLCJzZWxmIiwibWtkaXJTeW5jIiwiZnBhdGgiLCJyZXNvbHZlZFBhdGgiLCJzcGxpdCIsImZvckVhY2giLCJuYW1lIiwic3Vic3RyIiwic3RhdCIsImUiLCJpc0ZpbGUiLCJGSUxFX0lOX1RIRV9XQVkiLCJyZXBsYWNlIiwid3JpdGVGaWxlVG8iLCJwYXRoIiwiY29udGVudCIsIm92ZXJ3cml0ZSIsImF0dHIiLCJleGlzdHNTeW5jIiwiaXNEaXJlY3RvcnkiLCJkaXJuYW1lIiwiZmQiLCJvcGVuU3luYyIsImNobW9kU3luYyIsIndyaXRlU3luYyIsImxlbmd0aCIsImNsb3NlU3luYyIsIndyaXRlRmlsZVRvQXN5bmMiLCJjYWxsYmFjayIsInVuZGVmaW5lZCIsImV4aXN0cyIsImV4aXN0IiwiZXJyIiwib3BlbiIsImNobW9kIiwid3JpdGUiLCJjbG9zZSIsImZpbmRGaWxlcyIsImZpbmRTeW5jIiwiZGlyIiwicGF0dGVybiIsInJlY3Vyc2l2ZSIsImZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWxlIiwiam9pbiIsImNvbmNhdCIsInRlc3QiLCJwdXNoIiwibm9ybWFsaXplIiwiZ2V0QXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZXMiLCJjcmMzMnVwZGF0ZSIsImNyYyIsImJ5dGUiLCJjcmMzMiIsImJ1ZiIsIkJ1ZmZlciIsImZyb20iLCJnZW5DUkNUYWJsZSIsImxlbiIsIm9mZiIsIm1ldGhvZFRvU3RyaW5nIiwibWV0aG9kIiwiU1RPUkVEIiwiREVGTEFURUQiLCJjYW5vbmljYWwiLCJzYWZlU3VmZml4IiwicG9zaXgiLCJzYW5pdGl6ZSIsInByZWZpeCIsInJlc29sdmUiLCJwYXJ0cyIsImkiLCJsIiwic2xpY2UiLCJpbmRleE9mIiwiYmFzZW5hbWUiLCJ0b0J1ZmZlciIsImlucHV0IiwiaXNCdWZmZXIiLCJVaW50OEFycmF5IiwiYWxsb2MiLCJyZWFkQmlnVUludDY0TEUiLCJidWZmZXIiLCJpbmRleCIsInN3YXA2NCIsInBhcnNlSW50IiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/util/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/zipEntry.js":
/*!******************************************!*\
  !*** ./node_modules/adm-zip/zipEntry.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Utils = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/adm-zip/util/index.js\"), Headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/adm-zip/headers/index.js\"), Constants = Utils.Constants, Methods = __webpack_require__(/*! ./methods */ \"(rsc)/./node_modules/adm-zip/methods/index.js\");\nmodule.exports = function(/*Buffer*/ input) {\n    var _entryHeader = new Headers.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0);\n    function getCompressedDataFromZip() {\n        if (!input || !Buffer.isBuffer(input)) {\n            return Buffer.alloc(0);\n        }\n        _entryHeader.loadDataHeaderFromBinary(input);\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n    }\n    function crc32OK(data1) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\n            if (Utils.crc32(data1) !== _entryHeader.dataHeader.crc) {\n                return false;\n            }\n        } else {\n        // @TODO: load and check data descriptor header\n        // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n        // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n        }\n        return true;\n    }\n    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {\n        if (typeof callback === \"undefined\" && typeof async === \"string\") {\n            pass = async;\n            async = void 0;\n        }\n        if (_isDirectory) {\n            if (async && callback) {\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n            }\n            return Buffer.alloc(0);\n        }\n        var compressedData = getCompressedDataFromZip();\n        if (compressedData.length === 0) {\n            // File is empty, nothing to decompress.\n            if (async && callback) callback(compressedData);\n            return compressedData;\n        }\n        if (_entryHeader.encripted) {\n            if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n                throw new Error(\"ADM-ZIP: Incompatible password parameter\");\n            }\n            compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);\n        }\n        var data1 = Buffer.alloc(_entryHeader.size);\n        switch(_entryHeader.method){\n            case Utils.Constants.STORED:\n                compressedData.copy(data1);\n                if (!crc32OK(data1)) {\n                    if (async && callback) callback(data1, Utils.Errors.BAD_CRC); //si added error\n                    throw new Error(Utils.Errors.BAD_CRC);\n                } else {\n                    //si added otherwise did not seem to return data.\n                    if (async && callback) callback(data1);\n                    return data1;\n                }\n            case Utils.Constants.DEFLATED:\n                var inflater = new Methods.Inflater(compressedData);\n                if (!async) {\n                    const result = inflater.inflate(data1);\n                    result.copy(data1, 0);\n                    if (!crc32OK(data1)) {\n                        throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n                    }\n                    return data1;\n                } else {\n                    inflater.inflateAsync(function(result) {\n                        result.copy(result, 0);\n                        if (callback) {\n                            if (!crc32OK(result)) {\n                                callback(result, Utils.Errors.BAD_CRC); //si added error\n                            } else {\n                                callback(result);\n                            }\n                        }\n                    });\n                }\n                break;\n            default:\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n                throw new Error(Utils.Errors.UNKNOWN_METHOD);\n        }\n    }\n    function compress(/*Boolean*/ async, /*Function*/ callback) {\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n            // no data set or the data wasn't changed to require recompression\n            if (async && callback) callback(getCompressedDataFromZip());\n            return getCompressedDataFromZip();\n        }\n        if (uncompressedData.length && !_isDirectory) {\n            var compressedData;\n            // Local file header\n            switch(_entryHeader.method){\n                case Utils.Constants.STORED:\n                    _entryHeader.compressedSize = _entryHeader.size;\n                    compressedData = Buffer.alloc(uncompressedData.length);\n                    uncompressedData.copy(compressedData);\n                    if (async && callback) callback(compressedData);\n                    return compressedData;\n                default:\n                case Utils.Constants.DEFLATED:\n                    var deflater = new Methods.Deflater(uncompressedData);\n                    if (!async) {\n                        var deflated = deflater.deflate();\n                        _entryHeader.compressedSize = deflated.length;\n                        return deflated;\n                    } else {\n                        deflater.deflateAsync(function(data1) {\n                            compressedData = Buffer.alloc(data1.length);\n                            _entryHeader.compressedSize = data1.length;\n                            data1.copy(compressedData);\n                            callback && callback(compressedData);\n                        });\n                    }\n                    deflater = null;\n                    break;\n            }\n        } else if (async && callback) {\n            callback(Buffer.alloc(0));\n        } else {\n            return Buffer.alloc(0);\n        }\n    }\n    function readUInt64LE(buffer, offset) {\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n    }\n    function parseExtra(data1) {\n        var offset = 0;\n        var signature, size, part;\n        while(offset < data1.length){\n            signature = data1.readUInt16LE(offset);\n            offset += 2;\n            size = data1.readUInt16LE(offset);\n            offset += 2;\n            part = data1.slice(offset, offset + size);\n            offset += size;\n            if (Constants.ID_ZIP64 === signature) {\n                parseZip64ExtendedInformation(part);\n            }\n        }\n    }\n    //Override header field values with values from the ZIP64 extra field\n    function parseZip64ExtendedInformation(data1) {\n        var size, compressedSize, offset, diskNumStart;\n        if (data1.length >= Constants.EF_ZIP64_SCOMP) {\n            size = readUInt64LE(data1, Constants.EF_ZIP64_SUNCOMP);\n            if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.size = size;\n            }\n        }\n        if (data1.length >= Constants.EF_ZIP64_RHO) {\n            compressedSize = readUInt64LE(data1, Constants.EF_ZIP64_SCOMP);\n            if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.compressedSize = compressedSize;\n            }\n        }\n        if (data1.length >= Constants.EF_ZIP64_DSN) {\n            offset = readUInt64LE(data1, Constants.EF_ZIP64_RHO);\n            if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.offset = offset;\n            }\n        }\n        if (data1.length >= Constants.EF_ZIP64_DSN + 4) {\n            diskNumStart = data1.readUInt32LE(Constants.EF_ZIP64_DSN);\n            if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n                _entryHeader.diskNumStart = diskNumStart;\n            }\n        }\n    }\n    return {\n        get entryName () {\n            return _entryName.toString();\n        },\n        get rawEntryName () {\n            return _entryName;\n        },\n        set entryName (val){\n            _entryName = Utils.toBuffer(val);\n            var lastChar = _entryName[_entryName.length - 1];\n            _isDirectory = lastChar === 47 || lastChar === 92;\n            _entryHeader.fileNameLength = _entryName.length;\n        },\n        get extra () {\n            return _extra;\n        },\n        set extra (val){\n            _extra = val;\n            _entryHeader.extraLength = val.length;\n            parseExtra(val);\n        },\n        get comment () {\n            return _comment.toString();\n        },\n        set comment (val){\n            _comment = Utils.toBuffer(val);\n            _entryHeader.commentLength = _comment.length;\n        },\n        get name () {\n            var n = _entryName.toString();\n            return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n        },\n        get isDirectory () {\n            return _isDirectory;\n        },\n        getCompressedData: function() {\n            return compress(false, null);\n        },\n        getCompressedDataAsync: function(/*Function*/ callback) {\n            compress(true, callback);\n        },\n        setData: function(value) {\n            uncompressedData = Utils.toBuffer(value);\n            if (!_isDirectory && uncompressedData.length) {\n                _entryHeader.size = uncompressedData.length;\n                _entryHeader.method = Utils.Constants.DEFLATED;\n                _entryHeader.crc = Utils.crc32(value);\n                _entryHeader.changed = true;\n            } else {\n                // folders and blank files should be stored\n                _entryHeader.method = Utils.Constants.STORED;\n            }\n        },\n        getData: function(pass) {\n            if (_entryHeader.changed) {\n                return uncompressedData;\n            } else {\n                return decompress(false, null, pass);\n            }\n        },\n        getDataAsync: function(/*Function*/ callback, pass) {\n            if (_entryHeader.changed) {\n                callback(uncompressedData);\n            } else {\n                decompress(true, callback, pass);\n            }\n        },\n        set attr (attr){\n            _entryHeader.attr = attr;\n        },\n        get attr () {\n            return _entryHeader.attr;\n        },\n        set header (/*Buffer*/ data){\n            _entryHeader.loadFromBinary(data);\n        },\n        get header () {\n            return _entryHeader;\n        },\n        packHeader: function() {\n            // 1. create header (buffer)\n            var header = _entryHeader.entryHeaderToBinary();\n            var addpos = Utils.Constants.CENHDR;\n            // 2. add file name\n            _entryName.copy(header, addpos);\n            addpos += _entryName.length;\n            // 3. add extra data\n            if (_entryHeader.extraLength) {\n                _extra.copy(header, addpos);\n                addpos += _entryHeader.extraLength;\n            }\n            // 4. add file comment\n            if (_entryHeader.commentLength) {\n                _comment.copy(header, addpos);\n            }\n            return header;\n        },\n        toJSON: function() {\n            const bytes = function(nr) {\n                return \"<\" + (nr && nr.length + \" bytes buffer\" || \"null\") + \">\";\n            };\n            return {\n                entryName: this.entryName,\n                name: this.name,\n                comment: this.comment,\n                isDirectory: this.isDirectory,\n                header: _entryHeader.toJSON(),\n                compressedData: bytes(input),\n                data: bytes(uncompressedData)\n            };\n        },\n        toString: function() {\n            return JSON.stringify(this.toJSON(), null, \"\t\");\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDVCxPQUFPN0Y7UUFDWDtRQUVBK0YsWUFBWTtZQUNSLDRCQUE0QjtZQUM1QixJQUFJRixTQUFTN0YsYUFBYWdHLG1CQUFtQjtZQUM3QyxJQUFJQyxTQUFTekcsTUFBTUcsU0FBUyxDQUFDdUcsTUFBTTtZQUNuQyxtQkFBbUI7WUFDbkJoRyxXQUFXa0MsSUFBSSxDQUFDeUQsUUFBUUk7WUFDeEJBLFVBQVUvRixXQUFXMEIsTUFBTTtZQUMzQixvQkFBb0I7WUFDcEIsSUFBSTVCLGFBQWE0RSxXQUFXLEVBQUU7Z0JBQzFCcEUsT0FBTzRCLElBQUksQ0FBQ3lELFFBQVFJO2dCQUNwQkEsVUFBVWpHLGFBQWE0RSxXQUFXO1lBQ3RDO1lBQ0Esc0JBQXNCO1lBQ3RCLElBQUk1RSxhQUFhOEUsYUFBYSxFQUFFO2dCQUM1QnpFLFNBQVMrQixJQUFJLENBQUN5RCxRQUFRSTtZQUMxQjtZQUNBLE9BQU9KO1FBQ1g7UUFFQU0sUUFBUTtZQUNKLE1BQU1DLFFBQVEsU0FBVUMsRUFBRTtnQkFDdEIsT0FBTyxNQUFPLE9BQU9BLEdBQUd6RSxNQUFNLEdBQUcsbUJBQW9CLE1BQUssSUFBSztZQUNuRTtZQUVBLE9BQU87Z0JBQ0h5QyxXQUFXLElBQUksQ0FBQ0EsU0FBUztnQkFDekJVLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmRixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJPLGFBQWEsSUFBSSxDQUFDQSxXQUFXO2dCQUM3QlMsUUFBUTdGLGFBQWFtRyxNQUFNO2dCQUMzQnhFLGdCQUFnQnlFLE1BQU1yRztnQkFDdEJpQixNQUFNb0YsTUFBTTdGO1lBQ2hCO1FBQ0o7UUFFQW9DLFVBQVU7WUFDTixPQUFPMkQsS0FBS0MsU0FBUyxDQUFDLElBQUksQ0FBQ0osTUFBTSxJQUFJLE1BQU07UUFDL0M7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9uZGF5QXNzaXN0YW50Ly4vbm9kZV9tb2R1bGVzL2FkbS16aXAvemlwRW50cnkuanM/YTQwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIEhlYWRlcnMgPSByZXF1aXJlKFwiLi9oZWFkZXJzXCIpLFxuICAgIENvbnN0YW50cyA9IFV0aWxzLkNvbnN0YW50cyxcbiAgICBNZXRob2RzID0gcmVxdWlyZShcIi4vbWV0aG9kc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLypCdWZmZXIqLyBpbnB1dCkge1xuICAgIHZhciBfZW50cnlIZWFkZXIgPSBuZXcgSGVhZGVycy5FbnRyeUhlYWRlcigpLFxuICAgICAgICBfZW50cnlOYW1lID0gQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBfY29tbWVudCA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgX2lzRGlyZWN0b3J5ID0gZmFsc2UsXG4gICAgICAgIHVuY29tcHJlc3NlZERhdGEgPSBudWxsLFxuICAgICAgICBfZXh0cmEgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKSB7XG4gICAgICAgIGlmICghaW5wdXQgfHwgIUJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2VudHJ5SGVhZGVyLmxvYWREYXRhSGVhZGVyRnJvbUJpbmFyeShpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dC5zbGljZShfZW50cnlIZWFkZXIucmVhbERhdGFPZmZzZXQsIF9lbnRyeUhlYWRlci5yZWFsRGF0YU9mZnNldCArIF9lbnRyeUhlYWRlci5jb21wcmVzc2VkU2l6ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JjMzJPSyhkYXRhKSB7XG4gICAgICAgIC8vIGlmIGJpdCAzICgweDA4KSBvZiB0aGUgZ2VuZXJhbC1wdXJwb3NlIGZsYWdzIGZpZWxkIGlzIHNldCwgdGhlbiB0aGUgQ1JDLTMyIGFuZCBmaWxlIHNpemVzIGFyZSBub3Qga25vd24gd2hlbiB0aGUgaGVhZGVyIGlzIHdyaXR0ZW5cbiAgICAgICAgaWYgKChfZW50cnlIZWFkZXIuZmxhZ3MgJiAweDgpICE9PSAweDgpIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5jcmMzMihkYXRhKSAhPT0gX2VudHJ5SGVhZGVyLmRhdGFIZWFkZXIuY3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQFRPRE86IGxvYWQgYW5kIGNoZWNrIGRhdGEgZGVzY3JpcHRvciBoZWFkZXJcbiAgICAgICAgICAgIC8vIFRoZSBmaWVsZHMgaW4gdGhlIGxvY2FsIGhlYWRlciBhcmUgZmlsbGVkIHdpdGggemVybywgYW5kIHRoZSBDUkMtMzIgYW5kIHNpemUgYXJlIGFwcGVuZGVkIGluIGEgMTItYnl0ZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIC8vIChvcHRpb25hbGx5IHByZWNlZGVkIGJ5IGEgNC1ieXRlIHNpZ25hdHVyZSkgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXByZXNzZWQgZGF0YTpcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNvbXByZXNzKC8qQm9vbGVhbiovIGFzeW5jLCAvKkZ1bmN0aW9uKi8gY2FsbGJhY2ssIC8qU3RyaW5nLCBCdWZmZXIqLyBwYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFzeW5jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXNzID0gYXN5bmM7XG4gICAgICAgICAgICBhc3luYyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhCdWZmZXIuYWxsb2MoMCksIFV0aWxzLkVycm9ycy5ESVJFQ1RPUllfQ09OVEVOVF9FUlJPUik7IC8vc2kgYWRkZWQgZXJyb3IuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXByZXNzZWREYXRhID0gZ2V0Q29tcHJlc3NlZERhdGFGcm9tWmlwKCk7XG5cbiAgICAgICAgaWYgKGNvbXByZXNzZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRmlsZSBpcyBlbXB0eSwgbm90aGluZyB0byBkZWNvbXByZXNzLlxuICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3NlZERhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2VudHJ5SGVhZGVyLmVuY3JpcHRlZCkge1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBwYXNzICYmICFCdWZmZXIuaXNCdWZmZXIocGFzcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRE0tWklQOiBJbmNvbXBhdGlibGUgcGFzc3dvcmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBNZXRob2RzLlppcENyeXB0by5kZWNyeXB0KGNvbXByZXNzZWREYXRhLCBfZW50cnlIZWFkZXIsIHBhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuYWxsb2MoX2VudHJ5SGVhZGVyLnNpemUpO1xuXG4gICAgICAgIHN3aXRjaCAoX2VudHJ5SGVhZGVyLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBVdGlscy5Db25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgIGNvbXByZXNzZWREYXRhLmNvcHkoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjcmMzMk9LKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soZGF0YSwgVXRpbHMuRXJyb3JzLkJBRF9DUkMpOyAvL3NpIGFkZGVkIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuQkFEX0NSQyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9zaSBhZGRlZCBvdGhlcndpc2UgZGlkIG5vdCBzZWVtIHRvIHJldHVybiBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFV0aWxzLkNvbnN0YW50cy5ERUZMQVRFRDpcbiAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZXIgPSBuZXcgTWV0aG9kcy5JbmZsYXRlcihjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhc3luYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmZsYXRlci5pbmZsYXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29weShkYXRhLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcmMzMk9LKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoVXRpbHMuRXJyb3JzLkJBRF9DUkMgKyBcIiBcIiArIF9lbnRyeU5hbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZXIuaW5mbGF0ZUFzeW5jKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KHJlc3VsdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNyYzMyT0socmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQsIFV0aWxzLkVycm9ycy5CQURfQ1JDKTsgLy9zaSBhZGRlZCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChhc3luYyAmJiBjYWxsYmFjaykgY2FsbGJhY2soQnVmZmVyLmFsbG9jKDApLCBVdGlscy5FcnJvcnMuVU5LTk9XTl9NRVRIT0QpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihVdGlscy5FcnJvcnMuVU5LTk9XTl9NRVRIT0QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHJlc3MoLypCb29sZWFuKi8gYXN5bmMsIC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICBpZiAoKCF1bmNvbXByZXNzZWREYXRhIHx8ICF1bmNvbXByZXNzZWREYXRhLmxlbmd0aCkgJiYgQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSBzZXQgb3IgdGhlIGRhdGEgd2Fzbid0IGNoYW5nZWQgdG8gcmVxdWlyZSByZWNvbXByZXNzaW9uXG4gICAgICAgICAgICBpZiAoYXN5bmMgJiYgY2FsbGJhY2spIGNhbGxiYWNrKGdldENvbXByZXNzZWREYXRhRnJvbVppcCgpKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wcmVzc2VkRGF0YUZyb21aaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCAmJiAhX2lzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZERhdGE7XG4gICAgICAgICAgICAvLyBMb2NhbCBmaWxlIGhlYWRlclxuICAgICAgICAgICAgc3dpdGNoIChfZW50cnlIZWFkZXIubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBVdGlscy5Db25zdGFudHMuU1RPUkVEOlxuICAgICAgICAgICAgICAgICAgICBfZW50cnlIZWFkZXIuY29tcHJlc3NlZFNpemUgPSBfZW50cnlIZWFkZXIuc2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YSA9IEJ1ZmZlci5hbGxvYyh1bmNvbXByZXNzZWREYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHVuY29tcHJlc3NlZERhdGEuY29weShjb21wcmVzc2VkRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmIGNhbGxiYWNrKSBjYWxsYmFjayhjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2VkRGF0YTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmbGF0ZXIgPSBuZXcgTWV0aG9kcy5EZWZsYXRlcih1bmNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmxhdGVkID0gZGVmbGF0ZXIuZGVmbGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmNvbXByZXNzZWRTaXplID0gZGVmbGF0ZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmxhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmbGF0ZXIuZGVmbGF0ZUFzeW5jKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZERhdGEgPSBCdWZmZXIuYWxsb2MoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lbnRyeUhlYWRlci5jb21wcmVzc2VkU2l6ZSA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29weShjb21wcmVzc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY29tcHJlc3NlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmbGF0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhc3luYyAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soQnVmZmVyLmFsbG9jKDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkVUludDY0TEUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIChidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpIDw8IDQpICsgYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXh0cmEoZGF0YSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSwgc2l6ZSwgcGFydDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBkYXRhLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICBzaXplID0gZGF0YS5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgcGFydCA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgaWYgKENvbnN0YW50cy5JRF9aSVA2NCA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VaaXA2NEV4dGVuZGVkSW5mb3JtYXRpb24ocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL092ZXJyaWRlIGhlYWRlciBmaWVsZCB2YWx1ZXMgd2l0aCB2YWx1ZXMgZnJvbSB0aGUgWklQNjQgZXh0cmEgZmllbGRcbiAgICBmdW5jdGlvbiBwYXJzZVppcDY0RXh0ZW5kZWRJbmZvcm1hdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBzaXplLCBjb21wcmVzc2VkU2l6ZSwgb2Zmc2V0LCBkaXNrTnVtU3RhcnQ7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID49IENvbnN0YW50cy5FRl9aSVA2NF9TQ09NUCkge1xuICAgICAgICAgICAgc2l6ZSA9IHJlYWRVSW50NjRMRShkYXRhLCBDb25zdGFudHMuRUZfWklQNjRfU1VOQ09NUCk7XG4gICAgICAgICAgICBpZiAoX2VudHJ5SGVhZGVyLnNpemUgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8zMikge1xuICAgICAgICAgICAgICAgIF9lbnRyeUhlYWRlci5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPj0gQ29uc3RhbnRzLkVGX1pJUDY0X1JITykge1xuICAgICAgICAgICAgY29tcHJlc3NlZFNpemUgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1NDT01QKTtcbiAgICAgICAgICAgIGlmIChfZW50cnlIZWFkZXIuY29tcHJlc3NlZFNpemUgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8zMikge1xuICAgICAgICAgICAgICAgIF9lbnRyeUhlYWRlci5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+PSBDb25zdGFudHMuRUZfWklQNjRfRFNOKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSByZWFkVUludDY0TEUoZGF0YSwgQ29uc3RhbnRzLkVGX1pJUDY0X1JITyk7XG4gICAgICAgICAgICBpZiAoX2VudHJ5SGVhZGVyLm9mZnNldCA9PT0gQ29uc3RhbnRzLkVGX1pJUDY0X09SXzMyKSB7XG4gICAgICAgICAgICAgICAgX2VudHJ5SGVhZGVyLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPj0gQ29uc3RhbnRzLkVGX1pJUDY0X0RTTiArIDQpIHtcbiAgICAgICAgICAgIGRpc2tOdW1TdGFydCA9IGRhdGEucmVhZFVJbnQzMkxFKENvbnN0YW50cy5FRl9aSVA2NF9EU04pO1xuICAgICAgICAgICAgaWYgKF9lbnRyeUhlYWRlci5kaXNrTnVtU3RhcnQgPT09IENvbnN0YW50cy5FRl9aSVA2NF9PUl8xNikge1xuICAgICAgICAgICAgICAgIF9lbnRyeUhlYWRlci5kaXNrTnVtU3RhcnQgPSBkaXNrTnVtU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgZW50cnlOYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9lbnRyeU5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHJhd0VudHJ5TmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZW50cnlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZW50cnlOYW1lKHZhbCkge1xuICAgICAgICAgICAgX2VudHJ5TmFtZSA9IFV0aWxzLnRvQnVmZmVyKHZhbCk7XG4gICAgICAgICAgICB2YXIgbGFzdENoYXIgPSBfZW50cnlOYW1lW19lbnRyeU5hbWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBfaXNEaXJlY3RvcnkgPSBsYXN0Q2hhciA9PT0gNDcgfHwgbGFzdENoYXIgPT09IDkyO1xuICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmZpbGVOYW1lTGVuZ3RoID0gX2VudHJ5TmFtZS5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGV4dHJhKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9leHRyYTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGV4dHJhKHZhbCkge1xuICAgICAgICAgICAgX2V4dHJhID0gdmFsO1xuICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmV4dHJhTGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnNlRXh0cmEodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgY29tbWVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tbWVudC50b1N0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY29tbWVudCh2YWwpIHtcbiAgICAgICAgICAgIF9jb21tZW50ID0gVXRpbHMudG9CdWZmZXIodmFsKTtcbiAgICAgICAgICAgIF9lbnRyeUhlYWRlci5jb21tZW50TGVuZ3RoID0gX2NvbW1lbnQubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgdmFyIG4gPSBfZW50cnlOYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gX2lzRGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgPyBuXG4gICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cihuLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICAgIC5wb3AoKVxuICAgICAgICAgICAgICAgIDogbi5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfaXNEaXJlY3Rvcnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29tcHJlc3NlZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzcyhmYWxzZSwgbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29tcHJlc3NlZERhdGFBc3luYzogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29tcHJlc3ModHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdW5jb21wcmVzc2VkRGF0YSA9IFV0aWxzLnRvQnVmZmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghX2lzRGlyZWN0b3J5ICYmIHVuY29tcHJlc3NlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX2VudHJ5SGVhZGVyLnNpemUgPSB1bmNvbXByZXNzZWREYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBfZW50cnlIZWFkZXIubWV0aG9kID0gVXRpbHMuQ29uc3RhbnRzLkRFRkxBVEVEO1xuICAgICAgICAgICAgICAgIF9lbnRyeUhlYWRlci5jcmMgPSBVdGlscy5jcmMzMih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb2xkZXJzIGFuZCBibGFuayBmaWxlcyBzaG91bGQgYmUgc3RvcmVkXG4gICAgICAgICAgICAgICAgX2VudHJ5SGVhZGVyLm1ldGhvZCA9IFV0aWxzLkNvbnN0YW50cy5TVE9SRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKHBhc3MpIHtcbiAgICAgICAgICAgIGlmIChfZW50cnlIZWFkZXIuY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmNvbXByZXNzZWREYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb21wcmVzcyhmYWxzZSwgbnVsbCwgcGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGF0YUFzeW5jOiBmdW5jdGlvbiAoLypGdW5jdGlvbiovIGNhbGxiYWNrLCBwYXNzKSB7XG4gICAgICAgICAgICBpZiAoX2VudHJ5SGVhZGVyLmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh1bmNvbXByZXNzZWREYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzcyh0cnVlLCBjYWxsYmFjaywgcGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IGF0dHIoYXR0cikge1xuICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmF0dHIgPSBhdHRyO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgYXR0cigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZW50cnlIZWFkZXIuYXR0cjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgaGVhZGVyKC8qQnVmZmVyKi8gZGF0YSkge1xuICAgICAgICAgICAgX2VudHJ5SGVhZGVyLmxvYWRGcm9tQmluYXJ5KGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VudHJ5SGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhY2tIZWFkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIDEuIGNyZWF0ZSBoZWFkZXIgKGJ1ZmZlcilcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfZW50cnlIZWFkZXIuZW50cnlIZWFkZXJUb0JpbmFyeSgpO1xuICAgICAgICAgICAgdmFyIGFkZHBvcyA9IFV0aWxzLkNvbnN0YW50cy5DRU5IRFI7XG4gICAgICAgICAgICAvLyAyLiBhZGQgZmlsZSBuYW1lXG4gICAgICAgICAgICBfZW50cnlOYW1lLmNvcHkoaGVhZGVyLCBhZGRwb3MpO1xuICAgICAgICAgICAgYWRkcG9zICs9IF9lbnRyeU5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgLy8gMy4gYWRkIGV4dHJhIGRhdGFcbiAgICAgICAgICAgIGlmIChfZW50cnlIZWFkZXIuZXh0cmFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfZXh0cmEuY29weShoZWFkZXIsIGFkZHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkcG9zICs9IF9lbnRyeUhlYWRlci5leHRyYUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDQuIGFkZCBmaWxlIGNvbW1lbnRcbiAgICAgICAgICAgIGlmIChfZW50cnlIZWFkZXIuY29tbWVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9jb21tZW50LmNvcHkoaGVhZGVyLCBhZGRwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gZnVuY3Rpb24gKG5yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgKChuciAmJiBuci5sZW5ndGggKyBcIiBieXRlcyBidWZmZXJcIikgfHwgXCJudWxsXCIpICsgXCI+XCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVudHJ5TmFtZTogdGhpcy5lbnRyeU5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgICAgICAgICBpc0RpcmVjdG9yeTogdGhpcy5pc0RpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IF9lbnRyeUhlYWRlci50b0pTT04oKSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2VkRGF0YTogYnl0ZXMoaW5wdXQpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGJ5dGVzKHVuY29tcHJlc3NlZERhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSwgbnVsbCwgXCJcXHRcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJVdGlscyIsInJlcXVpcmUiLCJIZWFkZXJzIiwiQ29uc3RhbnRzIiwiTWV0aG9kcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbnB1dCIsIl9lbnRyeUhlYWRlciIsIkVudHJ5SGVhZGVyIiwiX2VudHJ5TmFtZSIsIkJ1ZmZlciIsImFsbG9jIiwiX2NvbW1lbnQiLCJfaXNEaXJlY3RvcnkiLCJ1bmNvbXByZXNzZWREYXRhIiwiX2V4dHJhIiwiZ2V0Q29tcHJlc3NlZERhdGFGcm9tWmlwIiwiaXNCdWZmZXIiLCJsb2FkRGF0YUhlYWRlckZyb21CaW5hcnkiLCJzbGljZSIsInJlYWxEYXRhT2Zmc2V0IiwiY29tcHJlc3NlZFNpemUiLCJjcmMzMk9LIiwiZGF0YSIsImZsYWdzIiwiY3JjMzIiLCJkYXRhSGVhZGVyIiwiY3JjIiwiZGVjb21wcmVzcyIsImFzeW5jIiwiY2FsbGJhY2siLCJwYXNzIiwiRXJyb3JzIiwiRElSRUNUT1JZX0NPTlRFTlRfRVJST1IiLCJjb21wcmVzc2VkRGF0YSIsImxlbmd0aCIsImVuY3JpcHRlZCIsIkVycm9yIiwiWmlwQ3J5cHRvIiwiZGVjcnlwdCIsInNpemUiLCJtZXRob2QiLCJTVE9SRUQiLCJjb3B5IiwiQkFEX0NSQyIsIkRFRkxBVEVEIiwiaW5mbGF0ZXIiLCJJbmZsYXRlciIsInJlc3VsdCIsImluZmxhdGUiLCJ0b1N0cmluZyIsImluZmxhdGVBc3luYyIsIlVOS05PV05fTUVUSE9EIiwiY29tcHJlc3MiLCJkZWZsYXRlciIsIkRlZmxhdGVyIiwiZGVmbGF0ZWQiLCJkZWZsYXRlIiwiZGVmbGF0ZUFzeW5jIiwicmVhZFVJbnQ2NExFIiwiYnVmZmVyIiwib2Zmc2V0IiwicmVhZFVJbnQzMkxFIiwicGFyc2VFeHRyYSIsInNpZ25hdHVyZSIsInBhcnQiLCJyZWFkVUludDE2TEUiLCJJRF9aSVA2NCIsInBhcnNlWmlwNjRFeHRlbmRlZEluZm9ybWF0aW9uIiwiZGlza051bVN0YXJ0IiwiRUZfWklQNjRfU0NPTVAiLCJFRl9aSVA2NF9TVU5DT01QIiwiRUZfWklQNjRfT1JfMzIiLCJFRl9aSVA2NF9SSE8iLCJFRl9aSVA2NF9EU04iLCJFRl9aSVA2NF9PUl8xNiIsImVudHJ5TmFtZSIsInJhd0VudHJ5TmFtZSIsInZhbCIsInRvQnVmZmVyIiwibGFzdENoYXIiLCJmaWxlTmFtZUxlbmd0aCIsImV4dHJhIiwiZXh0cmFMZW5ndGgiLCJjb21tZW50IiwiY29tbWVudExlbmd0aCIsIm5hbWUiLCJuIiwic3Vic3RyIiwic3BsaXQiLCJwb3AiLCJpc0RpcmVjdG9yeSIsImdldENvbXByZXNzZWREYXRhIiwiZ2V0Q29tcHJlc3NlZERhdGFBc3luYyIsInNldERhdGEiLCJ2YWx1ZSIsImNoYW5nZWQiLCJnZXREYXRhIiwiZ2V0RGF0YUFzeW5jIiwiYXR0ciIsImhlYWRlciIsImxvYWRGcm9tQmluYXJ5IiwicGFja0hlYWRlciIsImVudHJ5SGVhZGVyVG9CaW5hcnkiLCJhZGRwb3MiLCJDRU5IRFIiLCJ0b0pTT04iLCJieXRlcyIsIm5yIiwiSlNPTiIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/zipEntry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/adm-zip/zipFile.js":
/*!*****************************************!*\
  !*** ./node_modules/adm-zip/zipFile.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst ZipEntry = __webpack_require__(/*! ./zipEntry */ \"(rsc)/./node_modules/adm-zip/zipEntry.js\");\nconst Headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/adm-zip/headers/index.js\");\nconst Utils = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/adm-zip/util/index.js\");\nmodule.exports = function(/*Buffer|null*/ inBuffer, /** object */ options) {\n    var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader = new Headers.MainHeader(), loadedEntries = false;\n    // assign options\n    const opts = Object.assign(Object.create(null), options);\n    const { noSort } = opts;\n    if (inBuffer) {\n        // is a memory buffer\n        readMainHeader(opts.readEntries);\n    } else {\n        // none. is a new file\n        loadedEntries = true;\n    }\n    function iterateEntries(callback) {\n        const totalEntries = mainHeader.diskEntries; // total number of entries\n        let index = mainHeader.offset; // offset of first CEN header\n        for(let i = 0; i < totalEntries; i++){\n            let tmp = index;\n            const entry = new ZipEntry(inBuffer);\n            entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n            entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n            index += entry.header.entryHeaderSize;\n            callback(entry);\n        }\n    }\n    function readEntries() {\n        loadedEntries = true;\n        entryTable = {};\n        entryList = new Array(mainHeader.diskEntries); // total number of entries\n        var index = mainHeader.offset; // offset of first CEN header\n        for(var i = 0; i < entryList.length; i++){\n            var tmp = index, entry = new ZipEntry(inBuffer);\n            entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n            entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n            if (entry.header.extraLength) {\n                entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n            }\n            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n            index += entry.header.entryHeaderSize;\n            entryList[i] = entry;\n            entryTable[entry.entryName] = entry;\n        }\n    }\n    function readMainHeader(/*Boolean*/ readNow) {\n        var i = inBuffer.length - Utils.Constants.ENDHDR, max = Math.max(0, i - 0xffff), n = max, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;\n        for(i; i >= n; i--){\n            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n                // \"PK\\005\\006\"\n                endOffset = i;\n                commentEnd = i;\n                endStart = i + Utils.Constants.ENDHDR;\n                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n                n = i - Utils.Constants.END64HDR;\n                continue;\n            }\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n                // Found a zip64 signature, let's continue reading the whole zip64 record\n                n = max;\n                continue;\n            }\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n                // Found the zip64 record, let's determine it's size\n                endOffset = i;\n                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n                break;\n            }\n        }\n        if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n        if (mainHeader.commentLength) {\n            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n        }\n        if (readNow) readEntries();\n    }\n    function sortEntries() {\n        if (entryList.length > 1 && !noSort) {\n            entryList.sort((a, b)=>a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n        }\n    }\n    return {\n        /**\n         * Returns an array of ZipEntry objects existent in the current opened archive\n         * @return Array\n         */ get entries () {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryList;\n        },\n        /**\n         * Archive comment\n         * @return {String}\n         */ get comment () {\n            return _comment.toString();\n        },\n        set comment (val){\n            _comment = Utils.toBuffer(val);\n            mainHeader.commentLength = _comment.length;\n        },\n        getEntryCount: function() {\n            if (!loadedEntries) {\n                return mainHeader.diskEntries;\n            }\n            return entryList.length;\n        },\n        forEach: function(callback) {\n            if (!loadedEntries) {\n                iterateEntries(callback);\n                return;\n            }\n            entryList.forEach(callback);\n        },\n        /**\n         * Returns a reference to the entry with the given name or null if entry is inexistent\n         *\n         * @param entryName\n         * @return ZipEntry\n         */ getEntry: function(/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryTable[entryName] || null;\n        },\n        /**\n         * Adds the given entry to the entry list\n         *\n         * @param entry\n         */ setEntry: function(/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            entryList.push(entry);\n            entryTable[entry.entryName] = entry;\n            mainHeader.totalEntries = entryList.length;\n        },\n        /**\n         * Removes the entry with the given name from the entry list.\n         *\n         * If the entry is a directory, then all nested files and directories will be removed\n         * @param entryName\n         */ deleteEntry: function(/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            var entry = entryTable[entryName];\n            if (entry && entry.isDirectory) {\n                var _self = this;\n                this.getEntryChildren(entry).forEach(function(child) {\n                    if (child.entryName !== entryName) {\n                        _self.deleteEntry(child.entryName);\n                    }\n                });\n            }\n            entryList.splice(entryList.indexOf(entry), 1);\n            delete entryTable[entryName];\n            mainHeader.totalEntries = entryList.length;\n        },\n        /**\n         *  Iterates and returns all nested files and directories of the given entry\n         *\n         * @param entry\n         * @return Array\n         */ getEntryChildren: function(/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            if (entry && entry.isDirectory) {\n                const list = [];\n                const name = entry.entryName;\n                const len = name.length;\n                entryList.forEach(function(zipEntry) {\n                    if (zipEntry.entryName.substr(0, len) === name) {\n                        list.push(zipEntry);\n                    }\n                });\n                return list;\n            }\n            return [];\n        },\n        /**\n         * Returns the zip file\n         *\n         * @return Buffer\n         */ compressToBuffer: function() {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            sortEntries();\n            const dataBlock = [];\n            const entryHeaders = [];\n            let totalSize = 0;\n            let dindex = 0;\n            mainHeader.size = 0;\n            mainHeader.offset = 0;\n            for (const entry of entryList){\n                // compress data and set local and entry header accordingly. Reason why is called first\n                const compressedData = entry.getCompressedData();\n                // 1. construct data header\n                entry.header.offset = dindex;\n                const dataHeader = entry.header.dataHeaderToBinary();\n                const entryNameLen = entry.rawEntryName.length;\n                // 1.2. postheader - data after data header\n                const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);\n                entry.rawEntryName.copy(postHeader, 0);\n                postHeader.copy(entry.extra, entryNameLen);\n                // 2. offsets\n                const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n                dindex += dataLength;\n                // 3. store values in sequence\n                dataBlock.push(dataHeader);\n                dataBlock.push(postHeader);\n                dataBlock.push(compressedData);\n                // 4. construct entry header\n                const entryHeader = entry.packHeader();\n                entryHeaders.push(entryHeader);\n                // 5. update main header\n                mainHeader.size += entryHeader.length;\n                totalSize += dataLength + entryHeader.length;\n            }\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n            // point to end of data and beginning of central directory first record\n            mainHeader.offset = dindex;\n            dindex = 0;\n            const outBuffer = Buffer.alloc(totalSize);\n            // write data blocks\n            for (const content of dataBlock){\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n            // write central directory entries\n            for (const content of entryHeaders){\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n            // write main header\n            const mh = mainHeader.toBinary();\n            if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n            }\n            mh.copy(outBuffer, dindex);\n            return outBuffer;\n        },\n        toAsyncBuffer: function(/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {\n            try {\n                if (!loadedEntries) {\n                    readEntries();\n                }\n                sortEntries();\n                const dataBlock = [];\n                const entryHeaders = [];\n                let totalSize = 0;\n                let dindex = 0;\n                mainHeader.size = 0;\n                mainHeader.offset = 0;\n                const compress2Buffer = function(entryLists) {\n                    if (entryLists.length) {\n                        const entry = entryLists.pop();\n                        const name = entry.entryName + entry.extra.toString();\n                        if (onItemStart) onItemStart(name);\n                        entry.getCompressedDataAsync(function(compressedData) {\n                            if (onItemEnd) onItemEnd(name);\n                            entry.header.offset = dindex;\n                            // data header\n                            const dataHeader = entry.header.dataHeaderToBinary();\n                            const postHeader = Buffer.alloc(name.length, name);\n                            const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n                            dindex += dataLength;\n                            dataBlock.push(dataHeader);\n                            dataBlock.push(postHeader);\n                            dataBlock.push(compressedData);\n                            const entryHeader = entry.packHeader();\n                            entryHeaders.push(entryHeader);\n                            mainHeader.size += entryHeader.length;\n                            totalSize += dataLength + entryHeader.length;\n                            compress2Buffer(entryLists);\n                        });\n                    } else {\n                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n                        // point to end of data and beginning of central directory first record\n                        mainHeader.offset = dindex;\n                        dindex = 0;\n                        const outBuffer = Buffer.alloc(totalSize);\n                        dataBlock.forEach(function(content) {\n                            content.copy(outBuffer, dindex); // write data blocks\n                            dindex += content.length;\n                        });\n                        entryHeaders.forEach(function(content) {\n                            content.copy(outBuffer, dindex); // write central directory entries\n                            dindex += content.length;\n                        });\n                        const mh = mainHeader.toBinary();\n                        if (_comment) {\n                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n                        }\n                        mh.copy(outBuffer, dindex); // write main header\n                        onSuccess(outBuffer);\n                    }\n                };\n                compress2Buffer(entryList);\n            } catch (e) {\n                onFail(e);\n            }\n        }\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNLLFdBQVdkLFNBQVMsb0JBQW9COzRCQUNyREEsVUFBVWUsUUFBUXZFLE1BQU07d0JBQzVCO3dCQUNBc0QsYUFBYWxCLE9BQU8sQ0FBQyxTQUFVbUMsT0FBTzs0QkFDbENBLFFBQVFOLElBQUksQ0FBQ0ssV0FBV2QsU0FBUyxrQ0FBa0M7NEJBQ25FQSxVQUFVZSxRQUFRdkUsTUFBTTt3QkFDNUI7d0JBRUEsTUFBTXdFLEtBQUtuRyxXQUFXb0csUUFBUTt3QkFDOUIsSUFBSXZHLFVBQVU7NEJBQ1ZBLFNBQVMrRixJQUFJLENBQUNPLElBQUk3RyxNQUFNK0IsU0FBUyxDQUFDWSxNQUFNLEdBQUcsdUJBQXVCO3dCQUN0RTt3QkFFQWtFLEdBQUdQLElBQUksQ0FBQ0ssV0FBV2QsU0FBUyxvQkFBb0I7d0JBRWhEbUIsVUFBVUw7b0JBQ2Q7Z0JBQ0o7Z0JBRUFTLGdCQUFnQi9HO1lBQ3BCLEVBQUUsT0FBT21ILEdBQUc7Z0JBQ1JQLE9BQU9PO1lBQ1g7UUFDSjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb25kYXlBc3Npc3RhbnQvLi9ub2RlX21vZHVsZXMvYWRtLXppcC96aXBGaWxlLmpzPzM0YjAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgWmlwRW50cnkgPSByZXF1aXJlKFwiLi96aXBFbnRyeVwiKTtcbmNvbnN0IEhlYWRlcnMgPSByZXF1aXJlKFwiLi9oZWFkZXJzXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKkJ1ZmZlcnxudWxsKi8gaW5CdWZmZXIsIC8qKiBvYmplY3QgKi8gb3B0aW9ucykge1xuICAgIHZhciBlbnRyeUxpc3QgPSBbXSxcbiAgICAgICAgZW50cnlUYWJsZSA9IHt9LFxuICAgICAgICBfY29tbWVudCA9IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgbWFpbkhlYWRlciA9IG5ldyBIZWFkZXJzLk1haW5IZWFkZXIoKSxcbiAgICAgICAgbG9hZGVkRW50cmllcyA9IGZhbHNlO1xuXG4gICAgLy8gYXNzaWduIG9wdGlvbnNcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHsgbm9Tb3J0IH0gPSBvcHRzO1xuXG4gICAgaWYgKGluQnVmZmVyKSB7XG4gICAgICAgIC8vIGlzIGEgbWVtb3J5IGJ1ZmZlclxuICAgICAgICByZWFkTWFpbkhlYWRlcihvcHRzLnJlYWRFbnRyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub25lLiBpcyBhIG5ldyBmaWxlXG4gICAgICAgIGxvYWRlZEVudHJpZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVFbnRyaWVzKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHRvdGFsRW50cmllcyA9IG1haW5IZWFkZXIuZGlza0VudHJpZXM7IC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgIGxldCBpbmRleCA9IG1haW5IZWFkZXIub2Zmc2V0OyAvLyBvZmZzZXQgb2YgZmlyc3QgQ0VOIGhlYWRlclxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxFbnRyaWVzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IFppcEVudHJ5KGluQnVmZmVyKTtcblxuICAgICAgICAgICAgZW50cnkuaGVhZGVyID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IFV0aWxzLkNvbnN0YW50cy5DRU5IRFIpKTtcbiAgICAgICAgICAgIGVudHJ5LmVudHJ5TmFtZSA9IGluQnVmZmVyLnNsaWNlKHRtcCwgKHRtcCArPSBlbnRyeS5oZWFkZXIuZmlsZU5hbWVMZW5ndGgpKTtcblxuICAgICAgICAgICAgaW5kZXggKz0gZW50cnkuaGVhZGVyLmVudHJ5SGVhZGVyU2l6ZTtcblxuICAgICAgICAgICAgY2FsbGJhY2soZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEVudHJpZXMoKSB7XG4gICAgICAgIGxvYWRlZEVudHJpZXMgPSB0cnVlO1xuICAgICAgICBlbnRyeVRhYmxlID0ge307XG4gICAgICAgIGVudHJ5TGlzdCA9IG5ldyBBcnJheShtYWluSGVhZGVyLmRpc2tFbnRyaWVzKTsgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAgdmFyIGluZGV4ID0gbWFpbkhlYWRlci5vZmZzZXQ7IC8vIG9mZnNldCBvZiBmaXJzdCBDRU4gaGVhZGVyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gaW5kZXgsXG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgWmlwRW50cnkoaW5CdWZmZXIpO1xuICAgICAgICAgICAgZW50cnkuaGVhZGVyID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IFV0aWxzLkNvbnN0YW50cy5DRU5IRFIpKTtcblxuICAgICAgICAgICAgZW50cnkuZW50cnlOYW1lID0gaW5CdWZmZXIuc2xpY2UodG1wLCAodG1wICs9IGVudHJ5LmhlYWRlci5maWxlTmFtZUxlbmd0aCkpO1xuXG4gICAgICAgICAgICBpZiAoZW50cnkuaGVhZGVyLmV4dHJhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuZXh0cmEgPSBpbkJ1ZmZlci5zbGljZSh0bXAsICh0bXAgKz0gZW50cnkuaGVhZGVyLmV4dHJhTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS5oZWFkZXIuY29tbWVudExlbmd0aCkgZW50cnkuY29tbWVudCA9IGluQnVmZmVyLnNsaWNlKHRtcCwgdG1wICsgZW50cnkuaGVhZGVyLmNvbW1lbnRMZW5ndGgpO1xuXG4gICAgICAgICAgICBpbmRleCArPSBlbnRyeS5oZWFkZXIuZW50cnlIZWFkZXJTaXplO1xuXG4gICAgICAgICAgICBlbnRyeUxpc3RbaV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5VGFibGVbZW50cnkuZW50cnlOYW1lXSA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZE1haW5IZWFkZXIoLypCb29sZWFuKi8gcmVhZE5vdykge1xuICAgICAgICB2YXIgaSA9IGluQnVmZmVyLmxlbmd0aCAtIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIsIC8vIEVORCBoZWFkZXIgc2l6ZVxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoMCwgaSAtIDB4ZmZmZiksIC8vIDB4RkZGRiBpcyB0aGUgbWF4IHppcCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgICAgICBuID0gbWF4LFxuICAgICAgICAgICAgZW5kU3RhcnQgPSBpbkJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgICBlbmRPZmZzZXQgPSAtMSwgLy8gU3RhcnQgb2Zmc2V0IG9mIHRoZSBFTkQgaGVhZGVyXG4gICAgICAgICAgICBjb21tZW50RW5kID0gMDtcblxuICAgICAgICBmb3IgKGk7IGkgPj0gbjsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoaW5CdWZmZXJbaV0gIT09IDB4NTApIGNvbnRpbnVlOyAvLyBxdWljayBjaGVjayB0aGF0IHRoZSBieXRlIGlzICdQJ1xuICAgICAgICAgICAgaWYgKGluQnVmZmVyLnJlYWRVSW50MzJMRShpKSA9PT0gVXRpbHMuQ29uc3RhbnRzLkVORFNJRykge1xuICAgICAgICAgICAgICAgIC8vIFwiUEtcXDAwNVxcMDA2XCJcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRFbmQgPSBpO1xuICAgICAgICAgICAgICAgIGVuZFN0YXJ0ID0gaSArIFV0aWxzLkNvbnN0YW50cy5FTkRIRFI7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBmb3VuZCBhIHJlZ3VsYXIgc2lnbmF0dXJlLCBsZXQncyBsb29rIGp1c3QgYSBiaXQgZnVydGhlciB0byBjaGVjayBpZiB0aGVyZSdzIGFueSB6aXA2NCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBuID0gaSAtIFV0aWxzLkNvbnN0YW50cy5FTkQ2NEhEUjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluQnVmZmVyLnJlYWRVSW50MzJMRShpKSA9PT0gVXRpbHMuQ29uc3RhbnRzLkVORDY0U0lHKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSB6aXA2NCBzaWduYXR1cmUsIGxldCdzIGNvbnRpbnVlIHJlYWRpbmcgdGhlIHdob2xlIHppcDY0IHJlY29yZFxuICAgICAgICAgICAgICAgIG4gPSBtYXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkJ1ZmZlci5yZWFkVUludDMyTEUoaSkgPT09IFV0aWxzLkNvbnN0YW50cy5aSVA2NFNJRykge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIHRoZSB6aXA2NCByZWNvcmQsIGxldCdzIGRldGVybWluZSBpdCdzIHNpemVcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGVuZFN0YXJ0ID0gaSArIFV0aWxzLnJlYWRCaWdVSW50NjRMRShpbkJ1ZmZlciwgaSArIFV0aWxzLkNvbnN0YW50cy5aSVA2NFNJWkUpICsgVXRpbHMuQ29uc3RhbnRzLlpJUDY0TEVBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghfmVuZE9mZnNldCkgdGhyb3cgbmV3IEVycm9yKFV0aWxzLkVycm9ycy5JTlZBTElEX0ZPUk1BVCk7XG5cbiAgICAgICAgbWFpbkhlYWRlci5sb2FkRnJvbUJpbmFyeShpbkJ1ZmZlci5zbGljZShlbmRPZmZzZXQsIGVuZFN0YXJ0KSk7XG4gICAgICAgIGlmIChtYWluSGVhZGVyLmNvbW1lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIF9jb21tZW50ID0gaW5CdWZmZXIuc2xpY2UoY29tbWVudEVuZCArIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFkTm93KSByZWFkRW50cmllcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnRFbnRyaWVzKCkge1xuICAgICAgICBpZiAoZW50cnlMaXN0Lmxlbmd0aCA+IDEgJiYgIW5vU29ydCkge1xuICAgICAgICAgICAgZW50cnlMaXN0LnNvcnQoKGEsIGIpID0+IGEuZW50cnlOYW1lLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShiLmVudHJ5TmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBaaXBFbnRyeSBvYmplY3RzIGV4aXN0ZW50IGluIHRoZSBjdXJyZW50IG9wZW5lZCBhcmNoaXZlXG4gICAgICAgICAqIEByZXR1cm4gQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGdldCBlbnRyaWVzKCkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnRyeUxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyY2hpdmUgY29tbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY29tbWVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tbWVudC50b1N0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY29tbWVudCh2YWwpIHtcbiAgICAgICAgICAgIF9jb21tZW50ID0gVXRpbHMudG9CdWZmZXIodmFsKTtcbiAgICAgICAgICAgIG1haW5IZWFkZXIuY29tbWVudExlbmd0aCA9IF9jb21tZW50Lmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFbnRyeUNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbkhlYWRlci5kaXNrRW50cmllcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5TGlzdC5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlRW50cmllcyhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyeUxpc3QuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGVudHJ5IHdpdGggdGhlIGdpdmVuIG5hbWUgb3IgbnVsbCBpZiBlbnRyeSBpcyBpbmV4aXN0ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbnRyeU5hbWVcbiAgICAgICAgICogQHJldHVybiBaaXBFbnRyeVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnRyeVRhYmxlW2VudHJ5TmFtZV0gfHwgbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGUgZ2l2ZW4gZW50cnkgdG8gdGhlIGVudHJ5IGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBzZXRFbnRyeTogZnVuY3Rpb24gKC8qWmlwRW50cnkqLyBlbnRyeSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5TGlzdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIGVudHJ5VGFibGVbZW50cnkuZW50cnlOYW1lXSA9IGVudHJ5O1xuICAgICAgICAgICAgbWFpbkhlYWRlci50b3RhbEVudHJpZXMgPSBlbnRyeUxpc3QubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBlbnRyeSB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGVudHJ5IGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgdGhlbiBhbGwgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgICogQHBhcmFtIGVudHJ5TmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRW50cnk6IGZ1bmN0aW9uICgvKlN0cmluZyovIGVudHJ5TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFsb2FkZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJ5VGFibGVbZW50cnlOYW1lXTtcbiAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFbnRyeUNoaWxkcmVuKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZW50cnlOYW1lICE9PSBlbnRyeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zZWxmLmRlbGV0ZUVudHJ5KGNoaWxkLmVudHJ5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5TGlzdC5zcGxpY2UoZW50cnlMaXN0LmluZGV4T2YoZW50cnkpLCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbnRyeVRhYmxlW2VudHJ5TmFtZV07XG4gICAgICAgICAgICBtYWluSGVhZGVyLnRvdGFsRW50cmllcyA9IGVudHJ5TGlzdC5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBJdGVyYXRlcyBhbmQgcmV0dXJucyBhbGwgbmVzdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBvZiB0aGUgZ2l2ZW4gZW50cnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVudHJ5XG4gICAgICAgICAqIEByZXR1cm4gQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIGdldEVudHJ5Q2hpbGRyZW46IGZ1bmN0aW9uICgvKlppcEVudHJ5Ki8gZW50cnkpIHtcbiAgICAgICAgICAgIGlmICghbG9hZGVkRW50cmllcykge1xuICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGVudHJ5LmVudHJ5TmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBuYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGVudHJ5TGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh6aXBFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoemlwRW50cnkuZW50cnlOYW1lLnN1YnN0cigwLCBsZW4pID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goemlwRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHppcCBmaWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4gQnVmZmVyXG4gICAgICAgICAqL1xuICAgICAgICBjb21wcmVzc1RvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICByZWFkRW50cmllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuICAgICAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gW107XG4gICAgICAgICAgICBjb25zdCBlbnRyeUhlYWRlcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgbGV0IGRpbmRleCA9IDA7XG5cbiAgICAgICAgICAgIG1haW5IZWFkZXIuc2l6ZSA9IDA7XG4gICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcHJlc3MgZGF0YSBhbmQgc2V0IGxvY2FsIGFuZCBlbnRyeSBoZWFkZXIgYWNjb3JkaW5nbHkuIFJlYXNvbiB3aHkgaXMgY2FsbGVkIGZpcnN0XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBlbnRyeS5nZXRDb21wcmVzc2VkRGF0YSgpO1xuICAgICAgICAgICAgICAgIC8vIDEuIGNvbnN0cnVjdCBkYXRhIGhlYWRlclxuICAgICAgICAgICAgICAgIGVudHJ5LmhlYWRlci5vZmZzZXQgPSBkaW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUhlYWRlciA9IGVudHJ5LmhlYWRlci5kYXRhSGVhZGVyVG9CaW5hcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeU5hbWVMZW4gPSBlbnRyeS5yYXdFbnRyeU5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIDEuMi4gcG9zdGhlYWRlciAtIGRhdGEgYWZ0ZXIgZGF0YSBoZWFkZXJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0SGVhZGVyID0gQnVmZmVyLmFsbG9jKGVudHJ5TmFtZUxlbiArIGVudHJ5LmV4dHJhLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZW50cnkucmF3RW50cnlOYW1lLmNvcHkocG9zdEhlYWRlciwgMCk7XG4gICAgICAgICAgICAgICAgcG9zdEhlYWRlci5jb3B5KGVudHJ5LmV4dHJhLCBlbnRyeU5hbWVMZW4pO1xuXG4gICAgICAgICAgICAgICAgLy8gMi4gb2Zmc2V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhSGVhZGVyLmxlbmd0aCArIHBvc3RIZWFkZXIubGVuZ3RoICsgY29tcHJlc3NlZERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGRpbmRleCArPSBkYXRhTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gMy4gc3RvcmUgdmFsdWVzIGluIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgZGF0YUJsb2NrLnB1c2goZGF0YUhlYWRlcik7XG4gICAgICAgICAgICAgICAgZGF0YUJsb2NrLnB1c2gocG9zdEhlYWRlcik7XG4gICAgICAgICAgICAgICAgZGF0YUJsb2NrLnB1c2goY29tcHJlc3NlZERhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8gNC4gY29uc3RydWN0IGVudHJ5IGhlYWRlclxuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5SGVhZGVyID0gZW50cnkucGFja0hlYWRlcigpO1xuICAgICAgICAgICAgICAgIGVudHJ5SGVhZGVycy5wdXNoKGVudHJ5SGVhZGVyKTtcbiAgICAgICAgICAgICAgICAvLyA1LiB1cGRhdGUgbWFpbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBtYWluSGVhZGVyLnNpemUgKz0gZW50cnlIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgZW50cnlIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gbWFpbkhlYWRlci5tYWluSGVhZGVyU2l6ZTsgLy8gYWxzbyBpbmNsdWRlcyB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICAgICAgLy8gcG9pbnQgdG8gZW5kIG9mIGRhdGEgYW5kIGJlZ2lubmluZyBvZiBjZW50cmFsIGRpcmVjdG9yeSBmaXJzdCByZWNvcmRcbiAgICAgICAgICAgIG1haW5IZWFkZXIub2Zmc2V0ID0gZGluZGV4O1xuXG4gICAgICAgICAgICBkaW5kZXggPSAwO1xuICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAvLyB3cml0ZSBkYXRhIGJsb2Nrc1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIGRhdGFCbG9jaykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7XG4gICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3cml0ZSBjZW50cmFsIGRpcmVjdG9yeSBlbnRyaWVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgZW50cnlIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5jb3B5KG91dEJ1ZmZlciwgZGluZGV4KTtcbiAgICAgICAgICAgICAgICBkaW5kZXggKz0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdyaXRlIG1haW4gaGVhZGVyXG4gICAgICAgICAgICBjb25zdCBtaCA9IG1haW5IZWFkZXIudG9CaW5hcnkoKTtcbiAgICAgICAgICAgIGlmIChfY29tbWVudCkge1xuICAgICAgICAgICAgICAgIF9jb21tZW50LmNvcHkobWgsIFV0aWxzLkNvbnN0YW50cy5FTkRIRFIpOyAvLyBhZGQgemlwIGZpbGUgY29tbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWguY29weShvdXRCdWZmZXIsIGRpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRCdWZmZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9Bc3luY0J1ZmZlcjogZnVuY3Rpb24gKC8qRnVuY3Rpb24qLyBvblN1Y2Nlc3MsIC8qRnVuY3Rpb24qLyBvbkZhaWwsIC8qRnVuY3Rpb24qLyBvbkl0ZW1TdGFydCwgLypGdW5jdGlvbiovIG9uSXRlbUVuZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc29ydEVudHJpZXMoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFCbG9jayA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5SGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBkaW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgbWFpbkhlYWRlci5zaXplID0gMDtcbiAgICAgICAgICAgICAgICBtYWluSGVhZGVyLm9mZnNldCA9IDA7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzczJCdWZmZXIgPSBmdW5jdGlvbiAoZW50cnlMaXN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnlMaXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cnlMaXN0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5lbnRyeU5hbWUgKyBlbnRyeS5leHRyYS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uSXRlbVN0YXJ0KSBvbkl0ZW1TdGFydChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmdldENvbXByZXNzZWREYXRhQXN5bmMoZnVuY3Rpb24gKGNvbXByZXNzZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uSXRlbUVuZCkgb25JdGVtRW5kKG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuaGVhZGVyLm9mZnNldCA9IGRpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIZWFkZXIgPSBlbnRyeS5oZWFkZXIuZGF0YUhlYWRlclRvQmluYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdEhlYWRlciA9IEJ1ZmZlci5hbGxvYyhuYW1lLmxlbmd0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGFIZWFkZXIubGVuZ3RoICsgcG9zdEhlYWRlci5sZW5ndGggKyBjb21wcmVzc2VkRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gZGF0YUxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGRhdGFIZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKHBvc3RIZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCbG9jay5wdXNoKGNvbXByZXNzZWREYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5SGVhZGVyID0gZW50cnkucGFja0hlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5SGVhZGVycy5wdXNoKGVudHJ5SGVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluSGVhZGVyLnNpemUgKz0gZW50cnlIZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBkYXRhTGVuZ3RoICsgZW50cnlIZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3MyQnVmZmVyKGVudHJ5TGlzdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gbWFpbkhlYWRlci5tYWluSGVhZGVyU2l6ZTsgLy8gYWxzbyBpbmNsdWRlcyB6aXAgZmlsZSBjb21tZW50IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgdG8gZW5kIG9mIGRhdGEgYW5kIGJlZ2lubmluZyBvZiBjZW50cmFsIGRpcmVjdG9yeSBmaXJzdCByZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5IZWFkZXIub2Zmc2V0ID0gZGluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gQnVmZmVyLmFsbG9jKHRvdGFsU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmxvY2suZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIGRhdGEgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGluZGV4ICs9IGNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeUhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIGNlbnRyYWwgZGlyZWN0b3J5IGVudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW5kZXggKz0gY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWggPSBtYWluSGVhZGVyLnRvQmluYXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29tbWVudC5jb3B5KG1oLCBVdGlscy5Db25zdGFudHMuRU5ESERSKTsgLy8gYWRkIHppcCBmaWxlIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWguY29weShvdXRCdWZmZXIsIGRpbmRleCk7IC8vIHdyaXRlIG1haW4gaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhvdXRCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbXByZXNzMkJ1ZmZlcihlbnRyeUxpc3QpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG9uRmFpbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIlppcEVudHJ5IiwicmVxdWlyZSIsIkhlYWRlcnMiLCJVdGlscyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbkJ1ZmZlciIsIm9wdGlvbnMiLCJlbnRyeUxpc3QiLCJlbnRyeVRhYmxlIiwiX2NvbW1lbnQiLCJCdWZmZXIiLCJhbGxvYyIsIm1haW5IZWFkZXIiLCJNYWluSGVhZGVyIiwibG9hZGVkRW50cmllcyIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJjcmVhdGUiLCJub1NvcnQiLCJyZWFkTWFpbkhlYWRlciIsInJlYWRFbnRyaWVzIiwiaXRlcmF0ZUVudHJpZXMiLCJjYWxsYmFjayIsInRvdGFsRW50cmllcyIsImRpc2tFbnRyaWVzIiwiaW5kZXgiLCJvZmZzZXQiLCJpIiwidG1wIiwiZW50cnkiLCJoZWFkZXIiLCJzbGljZSIsIkNvbnN0YW50cyIsIkNFTkhEUiIsImVudHJ5TmFtZSIsImZpbGVOYW1lTGVuZ3RoIiwiZW50cnlIZWFkZXJTaXplIiwiQXJyYXkiLCJsZW5ndGgiLCJleHRyYUxlbmd0aCIsImV4dHJhIiwiY29tbWVudExlbmd0aCIsImNvbW1lbnQiLCJyZWFkTm93IiwiRU5ESERSIiwibWF4IiwiTWF0aCIsIm4iLCJlbmRTdGFydCIsImVuZE9mZnNldCIsImNvbW1lbnRFbmQiLCJyZWFkVUludDMyTEUiLCJFTkRTSUciLCJFTkQ2NEhEUiIsIkVORDY0U0lHIiwiWklQNjRTSUciLCJyZWFkQmlnVUludDY0TEUiLCJaSVA2NFNJWkUiLCJaSVA2NExFQUQiLCJFcnJvciIsIkVycm9ycyIsIklOVkFMSURfRk9STUFUIiwibG9hZEZyb21CaW5hcnkiLCJzb3J0RW50cmllcyIsInNvcnQiLCJhIiwiYiIsInRvTG93ZXJDYXNlIiwibG9jYWxlQ29tcGFyZSIsImVudHJpZXMiLCJ0b1N0cmluZyIsInZhbCIsInRvQnVmZmVyIiwiZ2V0RW50cnlDb3VudCIsImZvckVhY2giLCJnZXRFbnRyeSIsInNldEVudHJ5IiwicHVzaCIsImRlbGV0ZUVudHJ5IiwiaXNEaXJlY3RvcnkiLCJfc2VsZiIsImdldEVudHJ5Q2hpbGRyZW4iLCJjaGlsZCIsInNwbGljZSIsImluZGV4T2YiLCJsaXN0IiwibmFtZSIsImxlbiIsInppcEVudHJ5Iiwic3Vic3RyIiwiY29tcHJlc3NUb0J1ZmZlciIsImRhdGFCbG9jayIsImVudHJ5SGVhZGVycyIsInRvdGFsU2l6ZSIsImRpbmRleCIsInNpemUiLCJjb21wcmVzc2VkRGF0YSIsImdldENvbXByZXNzZWREYXRhIiwiZGF0YUhlYWRlciIsImRhdGFIZWFkZXJUb0JpbmFyeSIsImVudHJ5TmFtZUxlbiIsInJhd0VudHJ5TmFtZSIsInBvc3RIZWFkZXIiLCJjb3B5IiwiZGF0YUxlbmd0aCIsImVudHJ5SGVhZGVyIiwicGFja0hlYWRlciIsIm1haW5IZWFkZXJTaXplIiwib3V0QnVmZmVyIiwiY29udGVudCIsIm1oIiwidG9CaW5hcnkiLCJ0b0FzeW5jQnVmZmVyIiwib25TdWNjZXNzIiwib25GYWlsIiwib25JdGVtU3RhcnQiLCJvbkl0ZW1FbmQiLCJjb21wcmVzczJCdWZmZXIiLCJlbnRyeUxpc3RzIiwicG9wIiwiZ2V0Q29tcHJlc3NlZERhdGFBc3luYyIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/adm-zip/zipFile.js\n");

/***/ })

};
;