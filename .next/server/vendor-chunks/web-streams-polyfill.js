/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-streams-polyfill";
exports.ids = ["vendor-chunks/web-streams-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * web-streams-polyfill v3.2.1\n */ (function(global1, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n    /// <reference lib=\"dom\" />\n    function noop() {\n        return undefined;\n    }\n    function getGlobals() {\n        if (typeof self !== \"undefined\") {\n            return self;\n        } else if (false) {} else if (typeof global !== \"undefined\") {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n    function typeIsObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    const rethrowAssertionErrorRejection = noop;\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    function promiseResolvedWith(value) {\n        return originalPromiseResolve(value);\n    }\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    const queueMicrotask = (()=>{\n        const globalQueueMicrotask = globals && globals.queueMicrotask;\n        if (typeof globalQueueMicrotask === \"function\") {\n            return globalQueueMicrotask;\n        }\n        const resolvedPromise = promiseResolvedWith(undefined);\n        return (fn)=>PerformPromiseThen(resolvedPromise, fn);\n    })();\n    function reflectCall(F, V, args) {\n        if (typeof F !== \"function\") {\n            throw new TypeError(\"Argument is not a function\");\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        } catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */ class SimpleQueue {\n        constructor(){\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() {\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while(i !== elements.length || node._next !== undefined){\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() {\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseInitialize(reader);\n        } else if (stream._state === \"closed\") {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        } else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        if (reader._ownerReadableStream._state === \"readable\") {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        } else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        reader._ownerReadableStream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject)=>{\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n    const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n    const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n    const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function(x) {\n        return typeof x === \"number\" && isFinite(x);\n    };\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function(v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === \"object\" || typeof x === \"function\";\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== \"function\") {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        } else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamDefaultReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: ()=>resolvePromise({\n                        value: undefined,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            readRequest._closeSteps();\n        } else if (stream._state === \"errored\") {\n            readRequest._errorSteps(stream._storedError);\n        } else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel){\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = ()=>this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = ()=>this._returnSteps(value);\n            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"iterate\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    queueMicrotask(()=>resolvePromise({\n                            value: chunk,\n                            done: false\n                        }));\n                },\n                _closeSteps: ()=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({\n                        value: undefined,\n                        done: true\n                    });\n                },\n                _errorSteps: (reason)=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value,\n                    done: true\n                });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"finish iterating\"));\n            }\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, ()=>({\n                        value,\n                        done: true\n                    }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({\n                value,\n                done: true\n            });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next () {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return (value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n        } catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function(x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    // Not implemented correctly\n    function TransferArrayBuffer(O) {\n        return O;\n    }\n    // Not implemented correctly\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function IsDetachedBuffer(O) {\n        return false;\n    }\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== \"number\") {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        }\n        container._queue.push({\n            value,\n            size\n        });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */ class ReadableStreamBYOBRequest {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */ get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"view\");\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respond\");\n            }\n            assertRequiredArgument(bytesWritten, 1, \"respond\");\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(this._view.buffer)) ;\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respondWithNewView\");\n            }\n            assertRequiredArgument(view, 1, \"respondWithNewView\");\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError(\"You can only respond with array buffer views\");\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: {\n            enumerable: true\n        },\n        respondWithNewView: {\n            enumerable: true\n        },\n        view: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBRequest\",\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableByteStreamController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */ get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"byobRequest\");\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"desiredSize\");\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"close\");\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"enqueue\");\n            }\n            assertRequiredArgument(chunk, 1, \"enqueue\");\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError(\"chunk must be an array buffer view\");\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError(\"chunk must have non-zero byteLength\");\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"stream is closed or draining\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"error\");\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                const entry = this._queue.shift();\n                this._queueTotalSize -= entry.byteLength;\n                ReadableByteStreamControllerHandleQueueDrain(this);\n                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                readRequest._chunkSteps(view);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: \"default\"\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        byobRequest: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableByteStreamController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n        }, (e)=>{\n            ReadableByteStreamControllerError(controller, e);\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === \"closed\") {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"default\") {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        } else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({\n            buffer,\n            byteOffset,\n            byteLength\n        });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const elementSize = pullIntoDescriptor.elementSize;\n        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        if (maxAlignedBytes > currentAlignedBytes) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while(totalBytesToCopyRemaining > 0){\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            } else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        } else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while(controller._pendingPullIntos.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        let elementSize = 1;\n        if (view.constructor !== DataView) {\n            elementSize = view.constructor.BYTES_PER_ELEMENT;\n        }\n        const ctor = view.constructor;\n        // try {\n        const buffer = TransferArrayBuffer(view.buffer);\n        // } catch (e) {\n        //   readIntoRequest._errorSteps(e);\n        //   return;\n        // }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset: view.byteOffset,\n            byteLength: view.byteLength,\n            bytesFilled: 0,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === \"closed\") {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            ReadableByteStreamControllerRespondInClosedState(controller);\n        } else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled > 0) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        const buffer = chunk.buffer;\n        const byteOffset = chunk.byteOffset;\n        const byteLength = chunk.byteLength;\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n        }\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        if (ReadableStreamHasDefaultReader(stream)) {\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            } else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        } else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        } else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (bytesWritten !== 0) {\n                throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n            }\n        } else {\n            if (bytesWritten === 0) {\n                throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError(\"bytesWritten out of range\");\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (view.byteLength !== 0) {\n                throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n            }\n        } else {\n            if (view.byteLength === 0) {\n                throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError(\"The region specified by view does not match byobRequest\");\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError(\"The region specified by view is larger than byobRequest\");\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }, (r)=>{\n            ReadableByteStreamControllerError(controller, r);\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingByteSource.start(controller);\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        } else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamBYOBReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read(view) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readIntoRequests.length > 0) {\n                throw new TypeError(\"Tried to release a reader lock when that reader has pending read() calls un-settled\");\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"errored\") {\n            readIntoRequest._errorSteps(stream._storedError);\n        } else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError(\"Invalid highWaterMark\");\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return ()=>1;\n        }\n        return size;\n    }\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n    }\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return ()=>promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n    function isAbortSignal(value) {\n        if (typeof value !== \"object\" || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === \"boolean\";\n        } catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === \"function\";\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */ function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */ class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            } else {\n                assertObject(rawUnderlyingSink, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError(\"Invalid type is specified\");\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */ get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"locked\");\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */ abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */ close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */ getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"getWriter\");\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        getWriter: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStream\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = \"writable\";\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === \"closed\" || stream._state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === \"erroring\") {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject)=>{\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject)=>{\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === \"writable\") {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject)=>{\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === \"writable\") {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = \"erroring\";\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = \"errored\";\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach((writeRequest)=>{\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, ()=>{\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        }, (reason)=>{\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === \"erroring\") {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = \"closed\";\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            } else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */ class WritableStreamDefaultWriter {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n            assertWritableStream(stream, \"First parameter\");\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === \"writable\") {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                } else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"erroring\") {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"closed\") {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            } else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writer’s lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writer’s lock is released.\n         */ get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"desiredSize\");\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException(\"desiredSize\");\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n         * rejected.\n         */ get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */ abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */ close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"close\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */ releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"releaseLock\");\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        write: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        },\n        ready: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultWriter\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === \"pending\") {\n            defaultWriterClosedPromiseReject(writer, error);\n        } else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === \"pending\") {\n            defaultWriterReadyPromiseReject(writer, error);\n        } else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === \"errored\" || state === \"erroring\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n        }\n        const state = stream._state;\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n        }\n        if (state === \"erroring\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */ class WritableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */ get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"abortReason\");\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */ get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"signal\");\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */ error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"error\");\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== \"writable\") {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: {\n            enumerable: true\n        },\n        signal: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, ()=>{\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (r)=>{\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let writeAlgorithm = ()=>promiseResolvedWith(undefined);\n        let closeAlgorithm = ()=>promiseResolvedWith(undefined);\n        let abortAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = ()=>underlyingSink.start(controller);\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = ()=>underlyingSink.close();\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        } catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        } catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === \"erroring\") {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        } else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === \"writable\") {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, ()=>{\n            WritableStreamFinishInFlightClose(stream);\n        }, (reason)=>{\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, ()=>{\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, (reason)=>{\n            if (stream._state === \"writable\") {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject)=>{\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = \"pending\";\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"rejected\";\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"resolved\";\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject)=>{\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = \"pending\";\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"rejected\";\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"fulfilled\";\n    }\n    /// <reference lib=\"dom\" />\n    const NativeDOMException = typeof DOMException !== \"undefined\" ? DOMException : undefined;\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        } catch (_a) {\n            return false;\n        }\n    }\n    function createDOMExceptionPolyfill() {\n        // eslint-disable-next-line no-shadow\n        const ctor = function DOMException1(message, name) {\n            this.message = message || \"\";\n            this.name = name || \"Error\";\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, \"constructor\", {\n            value: ctor,\n            writable: true,\n            configurable: true\n        });\n        return ctor;\n    }\n    // eslint-disable-next-line no-redeclare\n    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject)=>{\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = ()=>{\n                    const error = new DOMException$1(\"Aborted\", \"AbortError\");\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(()=>{\n                            if (dest._state === \"writable\") {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(()=>{\n                            if (source._state === \"readable\") {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener(\"abort\", abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop)=>{\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        } else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, ()=>{\n                    return newPromise((resolveRead, rejectRead)=>{\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: (chunk)=>{\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: ()=>resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                if (!preventAbort) {\n                    shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                if (!preventClose) {\n                    shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                } else {\n                    shutdown();\n                }\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                } else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === \"errored\") {\n                    action(stream._storedError);\n                } else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === \"closed\") {\n                    action();\n                } else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                } else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                } else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener(\"abort\", abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                } else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"desiredSize\");\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"close\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits close\");\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"enqueue\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits enqueue\");\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"error\");\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                } else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            } else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n        }, (e)=>{\n            ReadableStreamDefaultControllerError(controller, e);\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        } else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            } catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            } catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === \"readable\") {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(controller, r);\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm = ()=>undefined;\n        let pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        let cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingSource.start(controller);\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingSource.pull(controller);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n        // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r)=>{\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, (r)=>{\n                if (thisReader !== reader) {\n                    return;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        } else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: (chunk)=>{\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== \"bytes\") {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== \"byob\") {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return {\n            preventCancel: Boolean(preventCancel)\n        };\n    }\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return {\n            readable,\n            writable\n        };\n    }\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */ class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            } else {\n                assertObject(rawUnderlyingSource, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n            InitializeReadableStream(this);\n            if (underlyingSource.type === \"bytes\") {\n                if (strategy.size !== undefined) {\n                    throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            } else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */ get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"locked\");\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"getReader\");\n            }\n            const options = convertReaderOptions(rawOptions, \"First parameter\");\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"pipeThrough\");\n            }\n            assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n            const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n            const options = convertPipeOptions(rawOptions, \"Second parameter\");\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, \"Second parameter\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */ tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"tee\");\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"values\");\n            }\n            const options = convertIteratorOptions(rawOptions, \"First parameter\");\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n    }\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        getReader: {\n            enumerable: true\n        },\n        pipeThrough: {\n            enumerable: true\n        },\n        pipeTo: {\n            enumerable: true\n        },\n        tee: {\n            enumerable: true\n        },\n        values: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStream\",\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = \"readable\";\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            reader._readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._closeSteps(undefined);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = \"closed\";\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach((readRequest)=>{\n                readRequest._closeSteps();\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = \"errored\";\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach((readRequest)=>{\n                readRequest._errorSteps(e);\n            });\n            reader._readRequests = new SimpleQueue();\n        } else {\n            reader._readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._errorSteps(e);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk)=>{\n        return chunk.byteLength;\n    };\n    try {\n        Object.defineProperty(byteLengthSizeFunction, \"name\", {\n            value: \"size\",\n            configurable: true\n        });\n    } catch (_a) {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */ class ByteLengthQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"highWaterMark\");\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */ get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"size\");\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ByteLengthQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = ()=>{\n        return 1;\n    };\n    try {\n        Object.defineProperty(countSizeFunction, \"name\", {\n            value: \"size\",\n            configurable: true\n        });\n    } catch (_a) {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */ class CountQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"highWaterMark\");\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */ get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"size\");\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"CountQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */ class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n            const transformer = convertTransformer(rawTransformer, \"First parameter\");\n            if (transformer.readableType !== undefined) {\n                throw new RangeError(\"Invalid readableType specified\");\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError(\"Invalid writableType specified\");\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise((resolve)=>{\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            } else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */ get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"readable\");\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */ get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"writable\");\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: {\n            enumerable: true\n        },\n        writable: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStream\",\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n            return promiseResolvedWith(undefined);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise((resolve)=>{\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */ class TransformStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n         */ get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"desiredSize\");\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"enqueue\");\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */ error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"error\");\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */ terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"terminate\");\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        terminate: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm = (chunk)=>{\n            try {\n                TransformStreamDefaultControllerEnqueue(controller, chunk);\n                return promiseResolvedWith(undefined);\n            } catch (transformResultE) {\n                return promiseRejectedWith(transformResultE);\n            }\n        };\n        let flushAlgorithm = ()=>promiseResolvedWith(undefined);\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = ()=>transformer.flush(controller);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        } catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, (r)=>{\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError(\"TransformStream terminated\");\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, ()=>{\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === \"erroring\") {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n        // errored.\n        TransformStreamError(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        const controller = stream._transformStreamController;\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        // Return a promise that is fulfilled with undefined on success.\n        return transformPromiseWith(flushPromise, ()=>{\n            if (readable._state === \"errored\") {\n                throw readable._storedError;\n            }\n            ReadableStreamDefaultControllerClose(readable._readableStreamController);\n        }, (r)=>{\n            TransformStreamError(stream, r);\n            throw readable._storedError;\n        });\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n    exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports1.CountQueuingStrategy = CountQueuingStrategy;\n    exports1.ReadableByteStreamController = ReadableByteStreamController;\n    exports1.ReadableStream = ReadableStream;\n    exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports1.TransformStream = TransformStream;\n    exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports1.WritableStream = WritableStream;\n    exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=ponyfill.es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FDQSxVQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDdEIsS0FBaUQsR0FBY0EsUUFBUUMsV0FDdkUsQ0FDa0g7QUFDdEgsR0FBRSxJQUFJLEVBQUcsU0FBVUEsUUFBTztJQUFJO0lBRTFCLHFDQUFxQztJQUNyQyxNQUFNTyxpQkFBaUIsT0FBT0MsV0FBVyxjQUFjLE9BQU9BLE9BQU9DLFFBQVEsS0FBSyxXQUM5RUQsU0FDQUUsQ0FBQUEsY0FBZSxDQUFDLE9BQU8sRUFBRUEsWUFBWSxDQUFDLENBQUM7SUFFM0MsMkJBQTJCO0lBQzNCLFNBQVNDO1FBQ0wsT0FBT0M7SUFDWDtJQUNBLFNBQVNDO1FBQ0wsSUFBSSxPQUFPUixTQUFTLGFBQWE7WUFDN0IsT0FBT0E7UUFDWCxPQUNLLElBQUksS0FBa0IsRUFBYSxFQUV2QyxNQUNJLElBQUksT0FBT1AsV0FBVyxhQUFhO1lBQ3BDLE9BQU9BO1FBQ1g7UUFDQSxPQUFPYztJQUNYO0lBQ0EsTUFBTUcsVUFBVUY7SUFFaEIsU0FBU0csYUFBYUMsQ0FBQztRQUNuQixPQUFPLE9BQVFBLE1BQU0sWUFBWUEsTUFBTSxRQUFTLE9BQU9BLE1BQU07SUFDakU7SUFDQSxNQUFNQyxpQ0FBaUNQO0lBRXZDLE1BQU1RLGtCQUFrQkM7SUFDeEIsTUFBTUMsc0JBQXNCRCxRQUFRRSxTQUFTLENBQUNDLElBQUk7SUFDbEQsTUFBTUMseUJBQXlCSixRQUFRSyxPQUFPLENBQUNDLElBQUksQ0FBQ1A7SUFDcEQsTUFBTVEsd0JBQXdCUCxRQUFRUSxNQUFNLENBQUNGLElBQUksQ0FBQ1A7SUFDbEQsU0FBU1UsV0FBV0MsUUFBUTtRQUN4QixPQUFPLElBQUlYLGdCQUFnQlc7SUFDL0I7SUFDQSxTQUFTQyxvQkFBb0JDLEtBQUs7UUFDOUIsT0FBT1IsdUJBQXVCUTtJQUNsQztJQUNBLFNB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QXFCdGpCLFFBQVF1UDtZQUM3QixNQUFNaVEsU0FBU2pmLFlBQVk7UUFDL0I7SUFDSjtJQUNBLDBDQUEwQztJQUMxQyxTQUFTMGlCLDBDQUEwQ2pqQixNQUFNO1FBQ3JELHNFQUFzRTtRQUN0RXFqQiwrQkFBK0JyakIsUUFBUTtRQUN2Qyw0REFBNEQ7UUFDNUQsT0FBT0EsT0FBT21qQiwwQkFBMEI7SUFDNUM7SUFDQSw2REFBNkQ7SUFDN0QsU0FBU08scUNBQXFDNWlCLElBQUk7UUFDOUMsT0FBTyxJQUFJL0MsVUFBVSxDQUFDLDJDQUEyQyxFQUFFK0MsS0FBSyx1REFBdUQsQ0FBQztJQUNwSTtJQUNBLDRDQUE0QztJQUM1QyxTQUFTNmhCLDBCQUEwQjdoQixJQUFJO1FBQ25DLE9BQU8sSUFBSS9DLFVBQVUsQ0FBQywwQkFBMEIsRUFBRStDLEtBQUssc0NBQXNDLENBQUM7SUFDbEc7SUFFQXRHLFNBQVFtbUIseUJBQXlCLEdBQUdBO0lBQ3BDbm1CLFNBQVF3bUIsb0JBQW9CLEdBQUdBO0lBQy9CeG1CLFNBQVFtUCw0QkFBNEIsR0FBR0E7SUFDdkNuUCxTQUFRaWxCLGNBQWMsR0FBR0E7SUFDekJqbEIsU0FBUXNWLHdCQUF3QixHQUFHQTtJQUNuQ3RWLFNBQVF1Tyx5QkFBeUIsR0FBR0E7SUFDcEN2TyxTQUFRNmdCLCtCQUErQixHQUFHQTtJQUMxQzdnQixTQUFRNkksMkJBQTJCLEdBQUdBO0lBQ3RDN0ksU0FBUW1uQixlQUFlLEdBQUdBO0lBQzFCbm5CLFNBQVFncEIsZ0NBQWdDLEdBQUdBO0lBQzNDaHBCLFNBQVFrWCxjQUFjLEdBQUdBO0lBQ3pCbFgsU0FBUXNZLCtCQUErQixHQUFHQTtJQUMxQ3RZLFNBQVFpWSwyQkFBMkIsR0FBR0E7SUFFdEM3TixPQUFPSSxjQUFjLENBQUN4SyxVQUFTLGNBQWM7UUFBRWdDLE9BQU87SUFBSztBQUUvRCxJQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL21vbmRheUFzc2lzdGFudC8uL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLmVzMjAxOC5qcz9mNzNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogd2ViLXN0cmVhbXMtcG9seWZpbGwgdjMuMi4xXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuV2ViU3RyZWFtc1BvbHlmaWxsID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5zeW1ib2xcIiAvPlxuICAgIGNvbnN0IFN5bWJvbFBvbHlmaWxsID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/XG4gICAgICAgIFN5bWJvbCA6XG4gICAgICAgIGRlc2NyaXB0aW9uID0+IGBTeW1ib2woJHtkZXNjcmlwdGlvbn0pYDtcblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZ2xvYmFscyA9IGdldEdsb2JhbHMoKTtcblxuICAgIGZ1bmN0aW9uIHR5cGVJc09iamVjdCh4KSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBjb25zdCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24gPSBub29wO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2VSZXNvbHZlID0gUHJvbWlzZS5yZXNvbHZlLmJpbmQob3JpZ2luYWxQcm9taXNlKTtcbiAgICBjb25zdCBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG4gICAgZnVuY3Rpb24gbmV3UHJvbWlzZShleGVjdXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2VSZXNvbHZlZFdpdGgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBUaGVyZSBkb2Vzbid0IGFwcGVhciB0byBiZSBhbnkgd2F5IHRvIGNvcnJlY3RseSBlbXVsYXRlIHRoZSBiZWhhdmlvdXIgZnJvbSBKYXZhU2NyaXB0LCBzbyB0aGlzIGlzIGp1c3QgYW5cbiAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVRoZW4uY2FsbChwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwb25GdWxmaWxsbWVudChwcm9taXNlLCBvbkZ1bGZpbGxlZCkge1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgb25SZWplY3RlZCkge1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlLCB1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpIHtcbiAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgcXVldWVNaWNyb3Rhc2sgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9IGdsb2JhbHMgJiYgZ2xvYmFscy5xdWV1ZU1pY3JvdGFzaztcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIChmbikgPT4gUGVyZm9ybVByb21pc2VUaGVuKHJlc29sdmVkUHJvbWlzZSwgZm4pO1xuICAgIH0pKCk7XG4gICAgZnVuY3Rpb24gcmVmbGVjdENhbGwoRiwgViwgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIEYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKEYsIFYsIGFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbChGLCBWLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWZsZWN0Q2FsbChGLCBWLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcmlnaW5hbCBmcm9tIENocm9taXVtXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy8rLzBhZWU0NDM0YTRkYmE0MmE0MmFiYWVhOWJmYmMwY2QxOTZhNjNiYzEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9zdHJlYW1zL1NpbXBsZVF1ZXVlLmpzXG4gICAgY29uc3QgUVVFVUVfTUFYX0FSUkFZX1NJWkUgPSAxNjM4NDtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgcXVldWUgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogQXZvaWRzIHNjYWxhYmlsaXR5IGlzc3VlcyB3aXRoIHVzaW5nIGEgcGFja2VkIGFycmF5IGRpcmVjdGx5IGJ5IHVzaW5nXG4gICAgICogbXVsdGlwbGUgYXJyYXlzIGluIGEgbGlua2VkIGxpc3QgYW5kIGtlZXBpbmcgdGhlIGFycmF5IHNpemUgYm91bmRlZC5cbiAgICAgKi9cbiAgICBjbGFzcyBTaW1wbGVRdWV1ZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICAgICAgLy8gX2Zyb250IGFuZCBfYmFjayBhcmUgYWx3YXlzIGRlZmluZWQuXG4gICAgICAgICAgICB0aGlzLl9mcm9udCA9IHtcbiAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICAvLyBUaGUgY3Vyc29yIGlzIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBBcnJheS5zaGlmdCgpLlxuICAgICAgICAgICAgLy8gSXQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBmcm9udCBlbGVtZW50IG9mIHRoZSBhcnJheSBpbnNpZGUgdGhlXG4gICAgICAgICAgICAvLyBmcm9udC1tb3N0IG5vZGUuIEl0IGlzIGFsd2F5cyBpbiB0aGUgcmFuZ2UgWzAsIFFVRVVFX01BWF9BUlJBWV9TSVpFKS5cbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUsIHNpemUgPT09IGVsZW1lbnRzLmxlbmd0aCAtIGN1cnNvci5cbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgZXhjZXB0aW9uIHNhZmV0eSwgdGhpcyBtZXRob2QgaXMgc3RydWN0dXJlZCBpbiBvcmRlcjpcbiAgICAgICAgLy8gMS4gUmVhZCBzdGF0ZVxuICAgICAgICAvLyAyLiBDYWxjdWxhdGUgcmVxdWlyZWQgc3RhdGUgbXV0YXRpb25zXG4gICAgICAgIC8vIDMuIFBlcmZvcm0gc3RhdGUgbXV0YXRpb25zXG4gICAgICAgIHB1c2goZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQmFjayA9IHRoaXMuX2JhY2s7XG4gICAgICAgICAgICBsZXQgbmV3QmFjayA9IG9sZEJhY2s7XG4gICAgICAgICAgICBpZiAob2xkQmFjay5fZWxlbWVudHMubGVuZ3RoID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgICAgICAgICAgICBuZXdCYWNrID0ge1xuICAgICAgICAgICAgICAgICAgICBfZWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB1c2goKSBpcyB0aGUgbXV0YXRpb24gbW9zdCBsaWtlbHkgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBpdFxuICAgICAgICAgICAgLy8gZ29lcyBmaXJzdC5cbiAgICAgICAgICAgIG9sZEJhY2suX2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobmV3QmFjayAhPT0gb2xkQmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2sgPSBuZXdCYWNrO1xuICAgICAgICAgICAgICAgIG9sZEJhY2suX25leHQgPSBuZXdCYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKyt0aGlzLl9zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpa2UgcHVzaCgpLCBzaGlmdCgpIGZvbGxvd3MgdGhlIHJlYWQgLT4gY2FsY3VsYXRlIC0+IG11dGF0ZSBwYXR0ZXJuIGZvclxuICAgICAgICAvLyBleGNlcHRpb24gc2FmZXR5LlxuICAgICAgICBzaGlmdCgpIHsgLy8gbXVzdCBub3QgYmUgY2FsbGVkIG9uIGFuIGVtcHR5IHF1ZXVlXG4gICAgICAgICAgICBjb25zdCBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgbGV0IG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICAgICAgICAgICBjb25zdCBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICBsZXQgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gb2xkRnJvbnQuX2VsZW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG4gICAgICAgICAgICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgICAgIG5ld0Zyb250ID0gb2xkRnJvbnQuX25leHQ7XG4gICAgICAgICAgICAgICAgbmV3Q3Vyc29yID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG11dGF0aW9ucyBiZWZvcmUgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcbiAgICAgICAgICAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVybWl0IHNoaWZ0ZWQgZWxlbWVudCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgICAgIGVsZW1lbnRzW29sZEN1cnNvcl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdHJpY2t5IHRoaW5nIGFib3V0IGZvckVhY2goKSBpcyB0aGF0IGl0IGNhbiBiZSBjYWxsZWRcbiAgICAgICAgLy8gcmUtZW50cmFudGx5LiBUaGUgcXVldWUgbWF5IGJlIG11dGF0ZWQgaW5zaWRlIHRoZSBjYWxsYmFjay4gSXQgaXMgZWFzeSB0b1xuICAgICAgICAvLyBzZWUgdGhhdCBwdXNoKCkgd2l0aGluIHRoZSBjYWxsYmFjayBoYXMgbm8gbmVnYXRpdmUgZWZmZWN0cyBzaW5jZSB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBxdWV1ZSBpcyBjaGVja2VkIGZvciBvbiBldmVyeSBpdGVyYXRpb24uIElmIHNoaWZ0KCkgaXMgY2FsbGVkXG4gICAgICAgIC8vIHJlcGVhdGVkbHkgd2l0aGluIHRoZSBjYWxsYmFjayB0aGVuIHRoZSBuZXh0IGl0ZXJhdGlvbiBtYXkgcmV0dXJuIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiByZW1vdmVkLiBJbiB0aGlzIGNhc2UgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgIC8vIHdpdGggdW5kZWZpbmVkIHZhbHVlcyB1bnRpbCB3ZSBlaXRoZXIgXCJjYXRjaCB1cFwiIHdpdGggZWxlbWVudHMgdGhhdCBzdGlsbFxuICAgICAgICAvLyBleGlzdCBvciByZWFjaCB0aGUgYmFjayBvZiB0aGUgcXVldWUuXG4gICAgICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5fY3Vyc29yO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgd2hpbGUgKGkgIT09IGVsZW1lbnRzLmxlbmd0aCB8fCBub2RlLl9uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLl9uZXh0O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IG5vZGUuX2VsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVsZW1lbnQgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBpZiBzaGlmdCgpIHdhcyBjYWxsZWQgbm93LFxuICAgICAgICAvLyB3aXRob3V0IG1vZGlmeWluZyB0aGUgcXVldWUuXG4gICAgICAgIHBlZWsoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUocmVhZGVyLCBzdHJlYW0pIHtcbiAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXG4gICAgLy8gY2hlY2suXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpIHtcbiAgICAgICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIG5ldyBUeXBlRXJyb3IoYFJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCkpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSByZWFkZXJzLlxuICAgIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcikge1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHJlYWRlci5fY2xvc2VkUHJvbWlzZSk7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKSB7XG4gICAgICAgIGlmIChyZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgQWJvcnRTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Fib3J0U3RlcHNdXScpO1xuICAgIGNvbnN0IEVycm9yU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tFcnJvclN0ZXBzXV0nKTtcbiAgICBjb25zdCBDYW5jZWxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0NhbmNlbFN0ZXBzXV0nKTtcbiAgICBjb25zdCBQdWxsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tQdWxsU3RlcHNdXScpO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LmNvcmVcIiAvPlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0Zpbml0ZSNQb2x5ZmlsbFxuICAgIGNvbnN0IE51bWJlcklzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoeCk7XG4gICAgfTtcblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3RydW5jI1BvbHlmaWxsXG4gICAgY29uc3QgTWF0aFRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwodikgOiBNYXRoLmZsb29yKHYpO1xuICAgIH07XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtZGljdGlvbmFyaWVzXG4gICAgZnVuY3Rpb24gaXNEaWN0aW9uYXJ5KHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0RGljdGlvbmFyeShvYmosIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmICFpc0RpY3Rpb25hcnkob2JqKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1jYWxsYmFjay1mdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtb2JqZWN0XG4gICAgZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KHgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoeCwgcG9zaXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICR7cG9zaXRpb259IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEZpZWxkKHgsIGZpZWxkLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZmllbGR9IGlzIHJlcXVpcmVkIGluICcke2NvbnRleHR9Jy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5yZXN0cmljdGVkLWRvdWJsZVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnNvck5lZ2F0aXZlWmVybyh4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSAwID8gMCA6IHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVnZXJQYXJ0KHgpIHtcbiAgICAgICAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoVHJ1bmMoeCkpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtdW5zaWduZWQtbG9uZy1sb25nXG4gICAgZnVuY3Rpb24gY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQm91bmQgPSAwO1xuICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGxldCB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcbiAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlcklzRmluaXRlKHgpIHx8IHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gVXNlIEJpZ0ludCBpZiBzdXBwb3J0ZWQ/XG4gICAgICAgIC8vIGxldCB4QmlnSW50ID0gQmlnSW50KGludGVnZXJQYXJ0KHgpKTtcbiAgICAgICAgLy8geEJpZ0ludCA9IEJpZ0ludC5hc1VpbnROKDY0LCB4QmlnSW50KTtcbiAgICAgICAgLy8gcmV0dXJuIE51bWJlcih4QmlnSW50KTtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0UmVhZGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0oeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICB9XG4gICAgLy8gUmVhZGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCkge1xuICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZWFkUmVxdWVzdC5fY2xvc2VTdGVwcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgcmVhZGVyIHZlbmRlZCBieSBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicpO1xuICAgICAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsXG4gICAgICAgICAqIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3IgdGhlIHJlYWRlcidzIGxvY2sgaXMgcmVsZWFzZWQgYmVmb3JlIHRoZSBzdHJlYW0gZmluaXNoZXMgY2xvc2luZy5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgUmVhZGFibGVTdHJlYW0uY2FuY2VsIHwgc3RyZWFtLmNhbmNlbChyZWFzb24pfS5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbChyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBhbGxvd3MgYWNjZXNzIHRvIHRoZSBuZXh0IGNodW5rIGZyb20gdGhlIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiBlID0+IHJlamVjdFByb21pc2UoZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxlYXNlcyB0aGUgcmVhZGVyJ3MgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICogZnJvbSBub3cgb247IG90aGVyd2lzZSwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcmVhZGVyJ3MgbG9jayBjYW5ub3QgYmUgcmVsZWFzZWQgd2hpbGUgaXQgc3RpbGwgaGFzIGEgcGVuZGluZyByZWFkIHJlcXVlc3QsIGkuZS4sIGlmIGEgcHJvbWlzZSByZXR1cm5lZCBieVxuICAgICAgICAgKiB0aGUgcmVhZGVyJ3Mge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5yZWFkIHwgcmVhZCgpfSBtZXRob2QgaGFzIG5vdCB5ZXQgYmVlbiBzZXR0bGVkLiBBdHRlbXB0aW5nIHRvXG4gICAgICAgICAqIGRvIHNvIHdpbGwgdGhyb3cgYSBgVHlwZUVycm9yYCBhbmQgbGVhdmUgdGhlIHJlYWRlciBsb2NrZWQgdG8gdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHJlbGVhc2VMb2NrKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkUmVxdWVzdHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbiAgICBjb25zdCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCkgeyB9KS5wcm90b3R5cGUpO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwge1xuICAgICAgICBjb25zdHJ1Y3RvcihyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgdGhpcy5fcHJldmVudENhbmNlbCA9IHByZXZlbnRDYW5jZWw7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGVwcyA9ICgpID0+IHRoaXMuX25leHRTdGVwcygpO1xuICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIHJldHVyblN0ZXBzLCByZXR1cm5TdGVwcykgOlxuICAgICAgICAgICAgICAgIHJldHVyblN0ZXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX25leHRTdGVwcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdpdGVyYXRlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYnkgb25lIG1pY3JvdGFzaywgb3RoZXJ3aXNlIHdlIHN0b3AgcHVsbGluZyB0b28gZWFybHkgd2hpY2ggYnJlYWtzIGEgdGVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgSXMgdGhpcyBhIGJ1ZyBpbiB0aGUgc3BlY2lmaWNhdGlvbiwgb3IgaW4gdGhlIHRlc3Q/XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBfcmV0dXJuU3RlcHModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgICAgICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdmaW5pc2ggaXRlcmF0aW5nJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCAoKSA9PiAoeyB2YWx1ZSwgZG9uZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbignbmV4dCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5uZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXR1cm4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXN5bmNJdGVyYXRvckltcGwucmV0dXJuKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgY29uc3QgaW1wbCA9IG5ldyBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsKHJlYWRlciwgcHJldmVudENhbmNlbCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2FzeW5jSXRlcmF0b3JJbXBsJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFN1c3BpY2lvdXNUeXBlT2ZHdWFyZFxuICAgICAgICAgICAgcmV0dXJuIHguX2FzeW5jSXRlcmF0b3JJbXBsIGluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JgKTtcbiAgICB9XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOI1BvbHlmaWxsXG4gICAgY29uc3QgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgICByZXR1cm4geCAhPT0geDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ3JlYXRlQXJyYXlGcm9tTGlzdChlbGVtZW50cykge1xuICAgICAgICAvLyBXZSB1c2UgYXJyYXlzIHRvIHJlcHJlc2VudCBsaXN0cywgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBuby1vcC5cbiAgICAgICAgLy8gRG8gYSBzbGljZSB0aG91Z2gganVzdCBpbiBjYXNlIHdlIGhhcHBlbiB0byBkZXBlbmQgb24gdGhlIHVuaXF1ZS1uZXNzLlxuICAgICAgICByZXR1cm4gZWxlbWVudHMuc2xpY2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29weURhdGFCbG9ja0J5dGVzKGRlc3QsIGRlc3RPZmZzZXQsIHNyYywgc3JjT2Zmc2V0LCBuKSB7XG4gICAgICAgIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4gICAgZnVuY3Rpb24gVHJhbnNmZXJBcnJheUJ1ZmZlcihPKSB7XG4gICAgICAgIHJldHVybiBPO1xuICAgIH1cbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGZ1bmN0aW9uIElzRGV0YWNoZWRCdWZmZXIoTykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFycmF5QnVmZmVyU2xpY2UoYnVmZmVyLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2VcbiAgICAgICAgaWYgKGJ1ZmZlci5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBiZWdpbjtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHNsaWNlLCAwLCBidWZmZXIsIGJlZ2luLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ2xvbmVBc1VpbnQ4QXJyYXkoTykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBBcnJheUJ1ZmZlclNsaWNlKE8uYnVmZmVyLCBPLmJ5dGVPZmZzZXQsIE8uYnl0ZU9mZnNldCArIE8uYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERlcXVldWVWYWx1ZShjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG4gICAgICAgIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgICAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhaXIudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRhaW5lciwgdmFsdWUsIHNpemUpIHtcbiAgICAgICAgaWYgKCFJc05vbk5lZ2F0aXZlTnVtYmVyKHNpemUpIHx8IHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWUucHVzaCh7IHZhbHVlLCBzaXplIH0pO1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG4gICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNldFF1ZXVlKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcHVsbC1pbnRvIHJlcXVlc3QgaW4gYSB7QGxpbmsgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2aWV3IGZvciB3cml0aW5nIGluIHRvLCBvciBgbnVsbGAgaWYgdGhlIEJZT0IgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJlc3BvbmRlZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGdldCB2aWV3KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZpZXcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3O1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbmQoYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChieXRlc1dyaXR0ZW4sIDEsICdyZXNwb25kJyk7XG4gICAgICAgICAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3LmJ1ZmZlcikpIDtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbmRXaXRoTmV3Vmlldyh2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHZpZXcsIDEsICdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgICAgICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSkgO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVzcG9uZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0JyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBieXRlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEJZT0IgcHVsbCByZXF1ZXN0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGJ5b2JSZXF1ZXN0KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2J5b2JSZXF1ZXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICAgICAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIGJ5dGUgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cbiAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWUoY2h1bmspIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xuICAgICAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcbiAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4odGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGVudHJ5LmJ1ZmZlciwgZW50cnkuYnl0ZU9mZnNldCwgZW50cnkuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2NodW5rU3RlcHModmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGJ1ZmZlckUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNpemU6IDEsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogVWludDhBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyVHlwZTogJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKCFzaG91bGRQdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG4gICAgICAgIC8vIFRPRE86IFRlc3QgY29udHJvbGxlciBhcmd1bWVudFxuICAgICAgICBjb25zdCBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgICAgICAgdXBvblByb21pc2UocHVsbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlLnB1c2goeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplICs9IGJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgY29uc3QgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuICAgICAgICBjb25zdCBtYXhCeXRlc1RvQ29weSA9IE1hdGgubWluKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gICAgICAgIGNvbnN0IG1heEJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgbWF4Qnl0ZXNUb0NvcHk7XG4gICAgICAgIGNvbnN0IG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gbWF4Qnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcbiAgICAgICAgbGV0IHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcbiAgICAgICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgICAgIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG4gICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gY29udHJvbGxlci5fcXVldWU7XG4gICAgICAgIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZE9mUXVldWUgPSBxdWV1ZS5wZWVrKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGVzdFN0YXJ0ID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgICAgICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcbiAgICAgICAgICAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBieXRlc1RvQ29weTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgc2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fdmlldyA9IG51bGw7XG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKSB7XG4gICAgICAgIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhjb250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgbGV0IGVsZW1lbnRTaXplID0gMTtcbiAgICAgICAgaWYgKHZpZXcuY29uc3RydWN0b3IgIT09IERhdGFWaWV3KSB7XG4gICAgICAgICAgICBlbGVtZW50U2l6ZSA9IHZpZXcuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3RvciA9IHZpZXcuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICAgICAgICAvLyB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgICAvLyAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBidWZmZXJCeXRlTGVuZ3RoOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGJ5dGVPZmZzZXQ6IHZpZXcuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICAgICAgZWxlbWVudFNpemUsXG4gICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IGN0b3IsXG4gICAgICAgICAgICByZWFkZXJUeXBlOiAnYnlvYidcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAvLyBObyBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCgpIGNhbGwgc2luY2U6XG4gICAgICAgICAgICAvLyAtIE5vIGNoYW5nZSBoYXBwZW5zIG9uIGRlc2lyZWRTaXplXG4gICAgICAgICAgICAvLyAtIFRoZSBzb3VyY2UgaGFzIGFscmVhZHkgYmVlbiBub3RpZmllZCBvZiB0aGF0IHRoZXJlJ3MgYXQgbGVhc3QgMSBwZW5kaW5nIHJlYWQodmlldylcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhlbXB0eVZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jaHVua1N0ZXBzKGZpbGxlZFZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzQllPQlJlYWRlcihzdHJlYW0pKSB7XG4gICAgICAgICAgICB3aGlsZSAoUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IHJlbWFpbmRlclNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgJSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG4gICAgICAgIGlmIChyZW1haW5kZXJTaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBBcnJheUJ1ZmZlclNsaWNlKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGVuZCAtIHJlbWFpbmRlclNpemUsIGVuZCk7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCByZW1haW5kZXIsIDAsIHJlbWFpbmRlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgLT0gcmVtYWluZGVyU2l6ZTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbikge1xuICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBmaXJzdERlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCB8fCBzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gY2h1bmsuYnVmZmVyO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gY2h1bmsuYnl0ZU9mZnNldDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVycmVkQnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKSkgO1xuICAgICAgICAgICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSkge1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IElkZWFsbHkgaW4gdGhpcyBicmFuY2ggZGV0YWNoaW5nIHNob3VsZCBoYXBwZW4gb25seSBpZiB0aGUgYnVmZmVyIGlzIG5vdCBjb25zdW1lZCBmdWxseS5cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwgJiYgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdERlc2NyaXB0b3IuYnVmZmVyLCBmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCwgZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgY29udHJvbGxlciwgdmlldyk7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IGJ5b2JSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9ieW9iUmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGlmIChieXRlc1dyaXR0ZW4gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmQoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmlld1xcJ3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kV2l0aE5ld1ZpZXcoKSBvbiBhIHJlYWRhYmxlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZU9mZnNldCArIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAhPT0gdmlldy5ieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBkb2VzIG5vdCBtYXRjaCBieW9iUmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnVmZmVyQnl0ZUxlbmd0aCAhPT0gdmlldy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICsgdmlldy5ieXRlTGVuZ3RoID4gZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGlzIGxhcmdlciB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0J5dGVMZW5ndGggPSB2aWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgIGZpcnN0RGVzY3JpcHRvci5idWZmZXIgPSBUcmFuc2ZlckFycmF5QnVmZmVyKHZpZXcuYnVmZmVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCB2aWV3Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHB1bGxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdCeXRlU291cmNlLCBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdCeXRlU291cmNlLnB1bGwoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdCeXRlU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhdXRvQWxsb2NhdGVDaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgICAgIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChyZXF1ZXN0LCBjb250cm9sbGVyLCB2aWV3KSB7XG4gICAgICAgIHJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgcmVxdWVzdC5fdmlldyA9IHZpZXc7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LlxuICAgIGZ1bmN0aW9uIGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0YCk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyYCk7XG4gICAgfVxuXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgfVxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgQllPQiByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyk7XG4gICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgZm9yIGEgc3RyZWFtIG5vdCBjb25zdHJ1Y3RlZCB3aXRoIGEgYnl0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuICAgICAgICAgICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgICAgICAgKiB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byByZWFkcyBieXRlcyBpbnRvIHZpZXcsIGFuZCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHJlYWRpbmcgYSBjaHVuayBjYXVzZXMgdGhlIHF1ZXVlIHRvIGJlY29tZSBlbXB0eSwgbW9yZSBkYXRhIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHVuZGVybHlpbmcgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZCh2aWV3KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSA7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVsZWFzZUxvY2soKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkSW50b1JlcXVlc3RzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZChyZWFkZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIuXG4gICAgZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgZGVmYXVsdEhXTSkge1xuICAgICAgICBjb25zdCB7IGhpZ2hXYXRlck1hcmsgfSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEhXTTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVySXNOYU4oaGlnaFdhdGVyTWFyaykgfHwgaGlnaFdhdGVyTWFyayA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaFdhdGVyTWFyaztcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpIHtcbiAgICAgICAgY29uc3QgeyBzaXplIH0gPSBzdHJhdGVneTtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oaWdoV2F0ZXJNYXJrO1xuICAgICAgICBjb25zdCBzaXplID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LnNpemU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUoc2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnc2l6ZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNodW5rID0+IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoZm4oY2h1bmspKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1Npbmsob3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuICAgICAgICBjb25zdCBjbG9zZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jbG9zZTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgY29uc3Qgd3JpdGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogYWJvcnQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxcbiAgICAgICAgICAgIGNsb3NlOiBjbG9zZSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soY2xvc2UsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB3cml0ZTogd3JpdGUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKHJlYXNvbikgPT4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY29udHJvbGxlcikgPT4gcmVmbGVjdENhbGwoZm4sIG9yaWdpbmFsLCBbY29udHJvbGxlcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0V3JpdGFibGVTdHJlYW0oeCwgY29udGV4dCkge1xuICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUuYWJvcnRlZCA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gQWJvcnRTaWduYWwucHJvdG90eXBlLmFib3J0ZWQgdGhyb3dzIGlmIGl0cyBicmFuZCBjaGVjayBmYWlsc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN1cHBvcnRzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBuZXcgQWJvcnRDb250cm9sbGVyLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKCkge1xuICAgICAgICBpZiAoc3VwcG9ydHNBYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHdyaXRhYmxlIHN0cmVhbSByZXByZXNlbnRzIGEgZGVzdGluYXRpb24gZm9yIGRhdGEsIGludG8gd2hpY2ggeW91IGNhbiB3cml0ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTaW5rID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcbiAgICAgICAgICAgIGlmIChyYXdVbmRlcmx5aW5nU2luayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmF3VW5kZXJseWluZ1NpbmsgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU2luayA9IGNvbnZlcnRVbmRlcmx5aW5nU2luayhyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHVuZGVybHlpbmdTaW5rLnR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICAgICAgICBjb25zdCBoaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHRoaXMsIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgd3JpdGFibGUgc3RyZWFtIGlzIGxvY2tlZCB0byBhIHdyaXRlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBsb2NrZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2xvY2tlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFib3J0cyB0aGUgc3RyZWFtLCBzaWduYWxpbmcgdGhhdCB0aGUgcHJvZHVjZXIgY2FuIG5vIGxvbmdlciBzdWNjZXNzZnVsbHkgd3JpdGUgdG8gdGhlIHN0cmVhbSBhbmQgaXQgaXMgdG8gYmVcbiAgICAgICAgICogaW1tZWRpYXRlbHkgbW92ZWQgdG8gYW4gZXJyb3JlZCBzdGF0ZSwgd2l0aCBhbnkgcXVldWVkLXVwIHdyaXRlcyBkaXNjYXJkZWQuIFRoaXMgd2lsbCBhbHNvIGV4ZWN1dGUgYW55IGFib3J0XG4gICAgICAgICAqIG1lY2hhbmlzbSBvZiB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgaWYgdGhlIHN0cmVhbSBzaHV0cyBkb3duIHN1Y2Nlc3NmdWxseSwgb3IgcmVqZWN0IGlmIHRoZSB1bmRlcmx5aW5nIHNpbmsgc2lnbmFsZWRcbiAgICAgICAgICogdGhhdCB0aGVyZSB3YXMgYW4gZXJyb3IgZG9pbmcgc28uIEFkZGl0aW9uYWxseSwgaXQgd2lsbCByZWplY3Qgd2l0aCBhIGBUeXBlRXJyb3JgICh3aXRob3V0IGF0dGVtcHRpbmcgdG8gY2FuY2VsXG4gICAgICAgICAqIHRoZSBzdHJlYW0pIGlmIHRoZSBzdHJlYW0gaXMgY3VycmVudGx5IGxvY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGFib3J0IGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbS4gVGhlIHVuZGVybHlpbmcgc2luayB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nIGFueSBwcmV2aW91c2x5LXdyaXR0ZW4gY2h1bmtzLCBiZWZvcmUgaW52b2tpbmcgaXRzXG4gICAgICAgICAqIGNsb3NlIGJlaGF2aW9yLiBEdXJpbmcgdGhpcyB0aW1lIGFueSBmdXJ0aGVyIGF0dGVtcHRzIHRvIHdyaXRlIHdpbGwgZmFpbCAod2l0aG91dCBlcnJvcmluZyB0aGUgc3RyZWFtKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCBpZiBhbGwgcmVtYWluaW5nIGNodW5rcyBhcmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gYW5kIHRoZSBzdHJlYW1cbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5IGNsb3Nlcywgb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZCBkdXJpbmcgdGhpcyBwcm9jZXNzLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGhcbiAgICAgICAgICogYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbCB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignY2xvc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1DbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgfCB3cml0ZXJ9IGFuZCBsb2NrcyB0aGUgc3RyZWFtIHRvIHRoZSBuZXcgd3JpdGVyLiBXaGlsZSB0aGUgc3RyZWFtXG4gICAgICAgICAqIGlzIGxvY2tlZCwgbm8gb3RoZXIgd3JpdGVyIGNhbiBiZSBhY3F1aXJlZCB1bnRpbCB0aGlzIG9uZSBpcyByZWxlYXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBjcmVhdGluZyBhYnN0cmFjdGlvbnMgdGhhdCBkZXNpcmUgdGhlIGFiaWxpdHkgdG8gd3JpdGUgdG8gYSBzdHJlYW1cbiAgICAgICAgICogd2l0aG91dCBpbnRlcnJ1cHRpb24gb3IgaW50ZXJsZWF2aW5nLiBCeSBnZXR0aW5nIGEgd3JpdGVyIGZvciB0aGUgc3RyZWFtLCB5b3UgY2FuIGVuc3VyZSBub2JvZHkgZWxzZSBjYW4gd3JpdGUgYXRcbiAgICAgICAgICogdGhlIHNhbWUgdGltZSwgd2hpY2ggd291bGQgY2F1c2UgdGhlIHJlc3VsdGluZyB3cml0dGVuIGRhdGEgdG8gYmUgdW5wcmVkaWN0YWJsZSBhbmQgcHJvYmFibHkgdXNlbGVzcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldFdyaXRlcigpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignZ2V0V3JpdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGdldFdyaXRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xuICAgIH1cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrID0gMSwgc2l6ZUFsZ29yaXRobSA9ICgpID0+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG4gICAgICAgIC8vIFRoZSBlcnJvciB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgYnkgbmV3IG1ldGhvZCBjYWxscyBvbmNlIHRoZSBzdGF0ZSBiZWNvbWVzIGVycm9yZWQuIE9ubHkgc2V0IHdoZW4gW1tzdGF0ZV1dIGlzXG4gICAgICAgIC8vICdlcnJvcmluZycgb3IgJ2Vycm9yZWQnLiBNYXkgYmUgc2V0IHRvIGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdG8gdW5kZWZpbmVkIGZpcnN0IGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjb250cm9sbGVyIGNoZWNrcyB0aGlzXG4gICAgICAgIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGlzIHF1ZXVlIGlzIHBsYWNlZCBoZXJlIGluc3RlYWQgb2YgdGhlIHdyaXRlciBjbGFzcyBpbiBvcmRlciB0byBhbGxvdyBmb3IgcGFzc2luZyBhIHdyaXRlciB0byB0aGUgbmV4dCBkYXRhXG4gICAgICAgIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxuICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgLy8gV3JpdGUgcmVxdWVzdHMgYXJlIHJlbW92ZWQgZnJvbSBfd3JpdGVSZXF1ZXN0cyB3aGVuIHdyaXRlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHNcbiAgICAgICAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5jbG9zZSgpLiBTdG9yZWQgaGVyZSBiZWNhdXNlIGl0IG1heSBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlclxuICAgICAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENsb3NlIHJlcXVlc3QgaXMgcmVtb3ZlZCBmcm9tIF9jbG9zZVJlcXVlc3Qgd2hlbiBjbG9zZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzIGl0XG4gICAgICAgIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmFib3J0KCkuIFRoaXMgbWF5IGFsc28gYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXIgaGFzIGRldGFjaGVkLlxuICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBiYWNrcHJlc3N1cmUgc2lnbmFsIHNldCBieSB0aGUgY29udHJvbGxlci5cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ193cml0YWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX3dyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgKF9hID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgbmFycm93cyB0aGUgdHlwZSBvZiBgc3RyZWFtLl9zdGF0ZWAgZG93biB0byAnd3JpdGFibGUnIHwgJ2Vycm9yaW5nJyxcbiAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gV2lkZW4gdGhlIHR5cGUgYWdhaW4gYnkgY2FzdGluZyB0byBXcml0YWJsZVN0cmVhbVN0YXRlLlxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIHdhc0FscmVhZHlFcnJvcmluZyA9IHRydWU7XG4gICAgICAgICAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cbiAgICAgICAgICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Byb21pc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgICAgX3JlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIGlmICghd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLy8gV3JpdGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLnB1c2god3JpdGVSZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkgJiYgY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Vycm9yU3RlcHNdKCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgIHdyaXRlUmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydFJlcXVlc3QgPSBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3Q7XG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgIH0sIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXJyb3Igd2FzIHRvbyBsYXRlIHRvIGRvIGFueXRoaW5nLCBzbyBpdCBpcyBpZ25vcmVkLlxuICAgICAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIE5ldmVyIGV4ZWN1dGUgc2luayBhYm9ydCgpIGFmdGVyIHNpbmsgY2xvc2UoKS5cbiAgICAgICAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiAgICB9XG4gICAgLy8gVE9ETyhyaWNlYSk6IEZpeCBhbHBoYWJldGljYWwgb3JkZXIuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAoYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0KHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGRlZmF1bHQgd3JpdGVyIHZlbmRlZCBieSBhIHtAbGluayBXcml0YWJsZVN0cmVhbX0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicpO1xuICAgICAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh0aGlzLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIHN0cmVhbeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICAgICAgICogQSBwcm9kdWNlciBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSByaWdodCBhbW91bnQgb2YgZGF0YSB0byB3cml0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gKGR1ZSB0byBlaXRoZXIgYmVpbmcgZXJyb3JlZCwgb3IgaGF2aW5nIGFuIGFib3J0XG4gICAgICAgICAqIHF1ZXVlZCB1cCkuIEl0IHdpbGwgcmV0dXJuIHplcm8gaWYgdGhlIHN0cmVhbSBpcyBjbG9zZWQuIEFuZCB0aGUgZ2V0dGVyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGludm9rZWQgd2hlblxuICAgICAgICAgKiB0aGUgd3JpdGVy4oCZcyBsb2NrIGlzIHJlbGVhc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlIHRyYW5zaXRpb25zXG4gICAgICAgICAqIGZyb20gbm9uLXBvc2l0aXZlIHRvIHBvc2l0aXZlLCBzaWduYWxpbmcgdGhhdCBpdCBpcyBubyBsb25nZXIgYXBwbHlpbmcgYmFja3ByZXNzdXJlLiBPbmNlIHRoZSBkZXNpcmVkIHNpemUgZGlwc1xuICAgICAgICAgKiBiYWNrIHRvIHplcm8gb3IgYmVsb3csIHRoZSBnZXR0ZXIgd2lsbCByZXR1cm4gYSBuZXcgcHJvbWlzZSB0aGF0IHN0YXlzIHBlbmRpbmcgdW50aWwgdGhlIG5leHQgdHJhbnNpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIHN0cmVhbSBiZWNvbWVzIGVycm9yZWQgb3IgYWJvcnRlZCwgb3IgdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZWNvbWVcbiAgICAgICAgICogcmVqZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWR5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmFib3J0IHwgc3RyZWFtLmFib3J0KHJlYXNvbil9LlxuICAgICAgICAgKi9cbiAgICAgICAgYWJvcnQocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVhZGVyIGlzIGFjdGl2ZSwgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgV3JpdGFibGVTdHJlYW0uY2xvc2UgfCBzdHJlYW0uY2xvc2UoKX0uXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVsZWFzZXMgdGhlIHdyaXRlcuKAmXMgbG9jayBvbiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uIEFmdGVyIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIGlzIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgICAgICAqIElmIHRoZSBhc3NvY2lhdGVkIHN0cmVhbSBpcyBlcnJvcmVkIHdoZW4gdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgZXJyb3JlZCBpbiB0aGUgc2FtZSB3YXkgZnJvbVxuICAgICAgICAgKiBub3cgb247IG90aGVyd2lzZSwgdGhlIHdyaXRlciB3aWxsIGFwcGVhciBjbG9zZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgbG9jayBjYW4gc3RpbGwgYmUgcmVsZWFzZWQgZXZlbiBpZiBzb21lIG9uZ29pbmcgd3JpdGVzIGhhdmUgbm90IHlldCBmaW5pc2hlZCAoaS5lLiBldmVuIGlmIHRoZVxuICAgICAgICAgKiBwcm9taXNlcyByZXR1cm5lZCBmcm9tIHByZXZpb3VzIGNhbGxzIHRvIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIud3JpdGUgfCB3cml0ZSgpfSBoYXZlIG5vdCB5ZXQgc2V0dGxlZCkuXG4gICAgICAgICAqIEl04oCZcyBub3QgbmVjZXNzYXJ5IHRvIGhvbGQgdGhlIGxvY2sgb24gdGhlIHdyaXRlciBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSB3cml0ZTsgdGhlIGxvY2sgaW5zdGVhZCBzaW1wbHkgcHJldmVudHNcbiAgICAgICAgICogb3RoZXIgcHJvZHVjZXJzIGZyb20gd3JpdGluZyBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAoc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwge1xuICAgICAgICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB3cml0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfb3duZXJXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplKHdyaXRlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IHJlbGVhc2VkRXJyb3IgPSBuZXcgVHlwZUVycm9yKGBXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuICAgICAgICAvLyBUaGUgc3RhdGUgdHJhbnNpdGlvbnMgdG8gXCJlcnJvcmVkXCIgYmVmb3JlIHRoZSBzaW5rIGFib3J0KCkgbWV0aG9kIHJ1bnMsIGJ1dCB0aGUgd3JpdGVyLmNsb3NlZCBwcm9taXNlIGlzIG5vdFxuICAgICAgICAvLyByZWplY3RlZCB1bnRpbCBhZnRlcndhcmRzLiBUaGlzIG1lYW5zIHRoYXQgc2ltcGx5IHRlc3Rpbmcgc3RhdGUgd2lsbCBub3Qgd29yay5cbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG4gICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICBpZiAoc3RyZWFtICE9PSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgY2xvc2luZyBvciBjbG9zZWQgYW5kIGNhbm5vdCBiZSB3cml0dGVuIHRvJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NlU2VudGluZWwgPSB7fTtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVhc29uIHdoaWNoIHdhcyBwYXNzZWQgdG8gYFdyaXRhYmxlU3RyZWFtLmFib3J0KHJlYXNvbilgIHdoZW4gdGhlIHN0cmVhbSB3YXMgYWJvcnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjaWZpY2F0aW9uLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL3B1bGwvMTE3Ny5cbiAgICAgICAgICogIFVzZSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5zaWduYWx9J3MgYHJlYXNvbmAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBhYm9ydFJlYXNvbigpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Fib3J0UmVhc29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnRSZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGBBYm9ydFNpZ25hbGAgdGhhdCBjYW4gYmUgdXNlZCB0byBhYm9ydCB0aGUgcGVuZGluZyB3cml0ZSBvciBjbG9zZSBvcGVyYXRpb24gd2hlbiB0aGUgc3RyZWFtIGlzIGFib3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignc2lnbmFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBPbGRlciBicm93c2VycyBvciBvbGRlciBOb2RlIHZlcnNpb25zIG1heSBub3Qgc3VwcG9ydCBgQWJvcnRDb250cm9sbGVyYCBvciBgQWJvcnRTaWduYWxgLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYnVuZGxlIGFuZCBzaGlwIGFuIGBBYm9ydENvbnRyb2xsZXJgIHBvbHlmaWxsIHRvZ2V0aGVyIHdpdGggb3VyIHBvbHlmaWxsLFxuICAgICAgICAgICAgICAgIC8vIHNvIGluc3RlYWQgd2Ugb25seSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgYHNpZ25hbGAgaWYgd2UgZmluZCBhIGdsb2JhbCBgQWJvcnRDb250cm9sbGVyYCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5zaWduYWwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCB3cml0YWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyByYXJlbHkgdXNlZCwgc2luY2UgdXN1YWxseSBpdCBzdWZmaWNlcyB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIGZyb20gb25lIG9mIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgICAqIHNpbmsncyBtZXRob2RzLiBIb3dldmVyLCBpdCBjYW4gYmUgdXNlZnVsIGZvciBzdWRkZW5seSBzaHV0dGluZyBkb3duIGEgc3RyZWFtIGluIHJlc3BvbnNlIHRvIGFuIGV2ZW50IG91dHNpZGUgdGhlXG4gICAgICAgICAqIG5vcm1hbCBsaWZlY3ljbGUgb2YgaW50ZXJhY3Rpb25zIHdpdGggdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICAgICAgICovXG4gICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3RyZWFtIGlzIGNsb3NlZCwgZXJyb3JlZCBvciB3aWxsIGJlIHNvb24uIFRoZSBzaW5rIGNhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBpZiBpdCBnZXRzIGFuIGVycm9yIGhlcmUsIHNvXG4gICAgICAgICAgICAgICAgLy8ganVzdCB0cmVhdCBpdCBhcyBhIG5vLW9wLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtBYm9ydFN0ZXBzXShyZWFzb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtFcnJvclN0ZXBzXSgpIHtcbiAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgYWJvcnRSZWFzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGltcGxlbWVudGluZyBpbnRlcmZhY2UgcmVxdWlyZWQgYnkgdGhlIFdyaXRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkV3JpdGFibGVTdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IHRoZSBzbG90cyBzbyB0aGF0IHRoZSBhc3NlcnQgZG9lc24ndCBmaXJlLiBJbiB0aGUgc3BlYyB0aGUgc2xvdHMgYWxyZWFkeSBleGlzdCBpbXBsaWNpdGx5LlxuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0UmVhc29uID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9hYm9ydENvbnRyb2xsZXIgPSBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gd3JpdGVBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gY2xvc2VBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0QWxnb3JpdGhtID0gYWJvcnRBbGdvcml0aG07XG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KTtcbiAgICAgICAgdXBvblByb21pc2Uoc3RhcnRQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayhzdHJlYW0sIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgd3JpdGVBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIGxldCBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVBbGdvcml0aG0gPSBjaHVuayA9PiB1bmRlcmx5aW5nU2luay53cml0ZShjaHVuaywgY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTaW5rLmNsb3NlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb3NlQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NpbmsuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgfVxuICAgIC8vIENsZWFyQWxnb3JpdGhtcyBtYXkgYmUgY2FsbGVkIHR3aWNlLiBFcnJvcmluZyB0aGUgc2FtZSBzdHJlYW0gaW4gbXVsdGlwbGUgd2F5cyB3aWxsIG9mdGVuIHJlc3VsdCBpbiByZWR1bmRhbnQgY2FsbHMuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2xvc2VTZW50aW5lbCwgMCk7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZW5xdWV1ZUUpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVucXVldWVFKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBQZWVrUXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjbG9zZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZXJyb3IpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgICAgICAgRGVxdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBzaW5rQ2xvc2VQcm9taXNlID0gY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0oKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgdXBvblByb21pc2Uoc2lua0Nsb3NlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSk7XG4gICAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgICAgICAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgdXBvblByb21pc2Uoc2lua1dyaXRlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuICAgICAgICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG4gICAgfVxuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tXCIgLz5cbiAgICBjb25zdCBOYXRpdmVET01FeGNlcHRpb24gPSB0eXBlb2YgRE9NRXhjZXB0aW9uICE9PSAndW5kZWZpbmVkJyA/IERPTUV4Y2VwdGlvbiA6IHVuZGVmaW5lZDtcblxuICAgIC8vLyA8cmVmZXJlbmNlIHR5cGVzPVwibm9kZVwiIC8+XG4gICAgZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IGN0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gICAgICAgIGNvbnN0IGN0b3IgPSBmdW5jdGlvbiBET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gY3RvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuICAgIGNvbnN0IERPTUV4Y2VwdGlvbiQxID0gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihOYXRpdmVET01FeGNlcHRpb24pID8gTmF0aXZlRE9NRXhjZXB0aW9uIDogY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKTtcblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoZGVzdCk7XG4gICAgICAgIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNodXR0aW5nRG93biA9IGZhbHNlO1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3BlYydzIHJlcXVpcmVtZW50IHRoYXQgd2Ugd2FpdCBmb3Igb25nb2luZyB3cml0ZXMgZHVyaW5nIHNodXRkb3duLlxuICAgICAgICBsZXQgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWJvcnRBbGdvcml0aG07XG4gICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydEFsZ29yaXRobSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uJDEoJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBhY3Rpb24oKSkpLCB0cnVlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2luZyByZWFkZXIgYW5kIHdyaXRlciwgcmVhZCBhbGwgY2h1bmtzIGZyb20gdGhpcyBhbmQgd3JpdGUgdGhlbSB0byBkZXN0XG4gICAgICAgICAgICAvLyAtIEJhY2twcmVzc3VyZSBtdXN0IGJlIGVuZm9yY2VkXG4gICAgICAgICAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVMb29wKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBgUGVyZm9ybVByb21pc2VUaGVuYCBpbnN0ZWFkIG9mIGB1cG9uUHJvbWlzZWAgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdW5uZWNlc3NhcnkgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwaXBlU3RlcCgpLCBuZXh0LCByZWplY3RMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVTdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4od3JpdGVyLl9yZWFkeVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlYWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVSZWFkKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICAgICAgICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0Q2xvc2VkID0gbmV3IFR5cGVFcnJvcigndGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWQpLCB0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSB7XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhhdCB0b28uXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQ3VycmVudFdyaXRlID0gY3VycmVudFdyaXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oY3VycmVudFdyaXRlLCAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvblJlamVjdGlvbihwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzQ2xvc2VkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbiwgb3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb1RoZVJlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9UaGVSZXN0KCkge1xuICAgICAgICAgICAgICAgICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSwgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaHV0ZG93bihpc0Vycm9yLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaHV0dGluZ0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJyAmJiAhV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpLCAoKSA9PiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBzdHJlYW19J3Mgc3RhdGUgYW5kIGludGVybmFsIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVzaXJlZCBzaXplIHRvIGZpbGwgdGhlIGNvbnRyb2xsZWQgc3RyZWFtJ3MgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzXG4gICAgICAgICAqIG92ZXItZnVsbC4gQW4gdW5kZXJseWluZyBzb3VyY2Ugb3VnaHQgdG8gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGV0ZXJtaW5lIHdoZW4gYW5kIGhvdyB0byBhcHBseSBiYWNrcHJlc3N1cmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZGVzaXJlZFNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHJlYWRhYmxlIHN0cmVhbS4gQ29uc3VtZXJzIHdpbGwgc3RpbGwgYmUgYWJsZSB0byByZWFkIGFueSBwcmV2aW91c2x5LWVucXVldWVkIGNodW5rcyBmcm9tXG4gICAgICAgICAqIHRoZSBzdHJlYW0sIGJ1dCBvbmNlIHRob3NlIGFyZSByZWFkLCB0aGUgc3RyZWFtIHdpbGwgYmVjb21lIGNsb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtDYW5jZWxTdGVwc10ocmVhc29uKSB7XG4gICAgICAgICAgICBSZXNldFF1ZXVlKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFtQdWxsU3RlcHNdKHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKCFzaG91bGRQdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjaHVua1NpemU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaHVua1NpemVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZW5xdWV1ZUU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHVzZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIFRyYW5zZm9ybVN0cmVhbS5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwdWxsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFydEFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NvdXJjZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhZEFnYWluID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhc29uMTtcbiAgICAgICAgbGV0IHJlYXNvbjI7XG4gICAgICAgIGxldCBicmFuY2gxO1xuICAgICAgICBsZXQgYnJhbmNoMjtcbiAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsxID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBhY2Nlc3MgdGhlIGNsb25pbmcgY29kZSByaWdodCBub3cgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFkZCBvbmUgdGhlbiB3ZSdsbCBuZWVkIGFuIGltcGxlbWVudGF0aW9uIGZvciBzZXJpYWxpemFibGUgb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICghY2FuY2VsZWQyICYmIGNsb25lRm9yQnJhbmNoMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjaHVuazIgPSBTdHJ1Y3R1cmVkRGVzZXJpYWxpemUoU3RydWN0dXJlZFNlcmlhbGl6ZShjaHVuazIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcbiAgICAgICAgdXBvblJlamVjdGlvbihyZWFkZXIuX2Nsb3NlZFByb21pc2UsIChyKSA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgfHwgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1UZWUoc3RyZWFtKSB7XG4gICAgICAgIGxldCByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgIGxldCByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbmNlbGVkMiA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhc29uMTtcbiAgICAgICAgbGV0IHJlYXNvbjI7XG4gICAgICAgIGxldCBicmFuY2gxO1xuICAgICAgICBsZXQgYnJhbmNoMjtcbiAgICAgICAgbGV0IHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRSZWFkZXJFcnJvcih0aGlzUmVhZGVyKSB7XG4gICAgICAgICAgICB1cG9uUmVqZWN0aW9uKHRoaXNSZWFkZXIuX2Nsb3NlZFByb21pc2UsIHIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzUmVhZGVyICE9PSByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCkge1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMSA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEgJiYgIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rMiA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNsb25lRSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsV2l0aEJZT0JSZWFkZXIodmlldywgZm9yQnJhbmNoMikge1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnlvYkJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gyIDogYnJhbmNoMTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQnJhbmNoID0gZm9yQnJhbmNoMiA/IGJyYW5jaDEgOiBicmFuY2gyO1xuICAgICAgICAgICAgY29uc3QgcmVhZEludG9SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBieW9iQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQyIDogY2FuY2VsZWQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2xvbmVkQ2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkQ2h1bmsgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY2xvbmVFKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVkQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2FuY2VsZWQgPSBmb3JCcmFuY2gyID8gY2FuY2VsZWQxIDogY2FuY2VsZWQyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2Uob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCAmJiBvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCB8fCAhb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHJlYWRlciwgdmlldywgcmVhZEludG9SZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsMUFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVhZEFnYWluRm9yQnJhbmNoMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYnlvYlJlcXVlc3QgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0QllPQlJlcXVlc3QoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgIGlmIChieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoRGVmYXVsdFJlYWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVsbFdpdGhCWU9CUmVhZGVyKGJ5b2JSZXF1ZXN0Ll92aWV3LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHB1bGwyQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlYXNvbjEgPSByZWFzb247XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICAgICAgICAgICByZWFzb24yID0gcmVhc29uO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGwxQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgICAgICAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDJBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Uoc291cmNlLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkoc291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jYW5jZWw7XG4gICAgICAgIGNvbnN0IHB1bGwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucHVsbDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YCksXG4gICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgICAgICAgICBwdWxsOiBwdWxsID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB0eXBlOiB0eXBlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3R5cGUnIHRoYXRgKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHR5cGUgPSBgJHt0eXBlfWA7XG4gICAgICAgIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke3R5cGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1UeXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRlck9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtb2RlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiBtb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ21vZGUnIHRoYXRgKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgbW9kZSA9IGAke21vZGV9YDtcbiAgICAgICAgaWYgKG1vZGUgIT09ICdieW9iJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtjb250ZXh0fSAnJHttb2RlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRJdGVyYXRvck9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG4gICAgICAgIHJldHVybiB7IHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCkgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UGlwZU9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBwcmV2ZW50QWJvcnQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudEFib3J0O1xuICAgICAgICBjb25zdCBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG4gICAgICAgIGNvbnN0IHByZXZlbnRDbG9zZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50Q2xvc2U7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJldmVudEFib3J0OiBCb29sZWFuKHByZXZlbnRBYm9ydCksXG4gICAgICAgICAgICBwcmV2ZW50Q2FuY2VsOiBCb29sZWFuKHByZXZlbnRDYW5jZWwpLFxuICAgICAgICAgICAgcHJldmVudENsb3NlOiBCb29sZWFuKHByZXZlbnRDbG9zZSksXG4gICAgICAgICAgICBzaWduYWxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhbiBBYm9ydFNpZ25hbC5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihwYWlyLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkocGFpciwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlID0gcGFpciA9PT0gbnVsbCB8fCBwYWlyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYWlyLnJlYWRhYmxlO1xuICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHJlYWRhYmxlLCAncmVhZGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgICAgICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0ocmVhZGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlID0gcGFpciA9PT0gbnVsbCB8fCBwYWlyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYWlyLndyaXRhYmxlO1xuICAgICAgICBhc3NlcnRSZXF1aXJlZEZpZWxkKHdyaXRhYmxlLCAnd3JpdGFibGUnLCAnUmVhZGFibGVXcml0YWJsZVBhaXInKTtcbiAgICAgICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0od3JpdGFibGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCk7XG4gICAgICAgIHJldHVybiB7IHJlYWRhYmxlLCB3cml0YWJsZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcmVhZGFibGUgc3RyZWFtIHJlcHJlc2VudHMgYSBzb3VyY2Ugb2YgZGF0YSwgZnJvbSB3aGljaCB5b3UgY2FuIHJlYWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU291cmNlID0ge30sIHJhd1N0cmF0ZWd5ID0ge30pIHtcbiAgICAgICAgICAgIGlmIChyYXdVbmRlcmx5aW5nU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCB1bmRlcmx5aW5nU291cmNlID0gY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlKHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSh0aGlzKTtcbiAgICAgICAgICAgIGlmICh1bmRlcmx5aW5nU291cmNlLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ3kuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgc3RyYXRlZ3kgZm9yIGEgYnl0ZSBzdHJlYW0gY2Fubm90IGhhdmUgYSBzaXplIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMCk7XG4gICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG4gICAgICAgICAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSByZWFkYWJsZSBzdHJlYW0gaXMgbG9ja2VkIHRvIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB8IHJlYWRlcn0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgbG9ja2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdsb2NrZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBzdHJlYW0sIHNpZ25hbGluZyBhIGxvc3Mgb2YgaW50ZXJlc3QgaW4gdGhlIHN0cmVhbSBieSBhIGNvbnN1bWVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc3VwcGxpZWQgYHJlYXNvbmAgYXJndW1lbnQgd2lsbCBiZSBnaXZlbiB0byB0aGUgdW5kZXJseWluZyBzb3VyY2UncyB7QGxpbmsgVW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgfCBjYW5jZWwoKX1cbiAgICAgICAgICogbWV0aG9kLCB3aGljaCBtaWdodCBvciBtaWdodCBub3QgdXNlIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYW5jZWwgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHJlYWRlcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGdldFJlYWRlcihyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2dldFJlYWRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRSZWFkZXJPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcGlwZVRocm91Z2gocmF3VHJhbnNmb3JtLCByYXdPcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQocmF3VHJhbnNmb3JtLCAxLCAncGlwZVRocm91Z2gnKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihyYXdUcmFuc2Zvcm0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0cmFuc2Zvcm0ud3JpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgdHJhbnNmb3JtLndyaXRhYmxlLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0ucmVhZGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgcGlwZVRvKGRlc3RpbmF0aW9uLCByYXdPcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRvJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChgUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbydzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBXcml0YWJsZVN0cmVhbWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gY29udmVydFBpcGVPcHRpb25zKHJhd09wdGlvbnMsICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5wcmV2ZW50Q2xvc2UsIG9wdGlvbnMucHJldmVudEFib3J0LCBvcHRpb25zLnByZXZlbnRDYW5jZWwsIG9wdGlvbnMuc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGVlcyB0aGlzIHJlYWRhYmxlIHN0cmVhbSwgcmV0dXJuaW5nIGEgdHdvLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgdHdvIHJlc3VsdGluZyBicmFuY2hlcyBhc1xuICAgICAgICAgKiBuZXcge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBpbnN0YW5jZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRlZWluZyBhIHN0cmVhbSB3aWxsIGxvY2sgaXQsIHByZXZlbnRpbmcgYW55IG90aGVyIGNvbnN1bWVyIGZyb20gYWNxdWlyaW5nIGEgcmVhZGVyLlxuICAgICAgICAgKiBUbyBjYW5jZWwgdGhlIHN0cmVhbSwgY2FuY2VsIGJvdGggb2YgdGhlIHJlc3VsdGluZyBicmFuY2hlczsgYSBjb21wb3NpdGUgY2FuY2VsbGF0aW9uIHJlYXNvbiB3aWxsIHRoZW4gYmVcbiAgICAgICAgICogcHJvcGFnYXRlZCB0byB0aGUgc3RyZWFtJ3MgdW5kZXJseWluZyBzb3VyY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY2h1bmtzIHNlZW4gaW4gZWFjaCBicmFuY2ggd2lsbCBiZSB0aGUgc2FtZSBvYmplY3QuIElmIHRoZSBjaHVua3MgYXJlIG5vdCBpbW11dGFibGUsXG4gICAgICAgICAqIHRoaXMgY291bGQgYWxsb3cgaW50ZXJmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBicmFuY2hlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRlZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgndGVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBicmFuY2hlcyA9IFJlYWRhYmxlU3RyZWFtVGVlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUFycmF5RnJvbUxpc3QoYnJhbmNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyhyYXdPcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3ZhbHVlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRJdGVyYXRvck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcywgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZ2V0UmVhZGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcGlwZVRocm91Z2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBwaXBlVG86IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB0ZWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW0nLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IsIHtcbiAgICAgICAgICAgIHZhbHVlOiBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudmFsdWVzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcbiAgICAgICAgc3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9yZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciAhPT0gdW5kZWZpbmVkICYmIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUNhbmNlbFByb21pc2UgPSBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltDYW5jZWxTdGVwc10ocmVhc29uKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKHNvdXJjZUNhbmNlbFByb21pc2UsIG5vb3ApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIGUpO1xuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChyZWFkUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaChyZWFkSW50b1JlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChpbml0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZChoaWdoV2F0ZXJNYXJrLCAnaGlnaFdhdGVyTWFyaycsICdRdWV1aW5nU3RyYXRlZ3lJbml0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24gPSAoY2h1bmspID0+IHtcbiAgICAgICAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ25hbWUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ3NpemUnLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyBub24tY29uZmlndXJhYmxlIGluIG9sZGVyIGJyb3dzZXJzLCBzbyBpZ25vcmUgaWYgdGhpcyB0aHJvd3MuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWUjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcXVldWluZyBzdHJhdGVneSB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGVhY2ggY2h1bmsuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IHJldHVybmluZyB0aGUgdmFsdWUgb2YgaXRzIGBieXRlTGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVMZW5ndGhTaXplRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5JyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kuXG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3koeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2l6ZSBmdW5jdGlvbiBtdXN0IG5vdCBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG5vciBiZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgY291bnRTaXplRnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvdW50U2l6ZUZ1bmN0aW9uLCAnbmFtZScsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnc2l6ZScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vbi1jb25maWd1cmFibGUgaW4gb2xkZXIgYnJvd3NlcnMsIHNvIGlnbm9yZSBpZiB0aGlzIHRocm93cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBxdWV1aW5nIHN0cmF0ZWd5IHRoYXQgY291bnRzIHRoZSBudW1iZXIgb2YgY2h1bmtzLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5IHtcbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChvcHRpb25zLCAxLCAnQ291bnRRdWV1aW5nU3RyYXRlZ3knKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChvcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcbiAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignaGlnaFdhdGVyTWFyaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSBhbHdheXMgcmV0dXJuaW5nIDEuXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB0b3RhbCBxdWV1ZSBzaXplIGlzIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiBjaHVua3MgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudFNpemVGdW5jdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnQ291bnRRdWV1aW5nU3RyYXRlZ3knLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgQ291bnRRdWV1aW5nU3RyYXRlZ3kuXG4gICAgZnVuY3Rpb24gY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBDb3VudFF1ZXVpbmdTdHJhdGVneWApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBDb3VudFF1ZXVpbmdTdHJhdGVneTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXIob3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShvcmlnaW5hbCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGZsdXNoID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmZsdXNoO1xuICAgICAgICBjb25zdCByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucmVhZGFibGVUeXBlO1xuICAgICAgICBjb25zdCBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRhYmxlVHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZmx1c2gsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLFxuICAgICAgICAgICAgcmVhZGFibGVUeXBlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuICAgICAgICAgICAgd3JpdGFibGVUeXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG4gICAgfVxuXG4gICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtXG4gICAgLyoqXG4gICAgICogQSB0cmFuc2Zvcm0gc3RyZWFtIGNvbnNpc3RzIG9mIGEgcGFpciBvZiBzdHJlYW1zOiBhIHtAbGluayBXcml0YWJsZVN0cmVhbSB8IHdyaXRhYmxlIHN0cmVhbX0sXG4gICAgICoga25vd24gYXMgaXRzIHdyaXRhYmxlIHNpZGUsIGFuZCBhIHtAbGluayBSZWFkYWJsZVN0cmVhbSB8IHJlYWRhYmxlIHN0cmVhbX0sIGtub3duIGFzIGl0cyByZWFkYWJsZSBzaWRlLlxuICAgICAqIEluIGEgbWFubmVyIHNwZWNpZmljIHRvIHRoZSB0cmFuc2Zvcm0gc3RyZWFtIGluIHF1ZXN0aW9uLCB3cml0ZXMgdG8gdGhlIHdyaXRhYmxlIHNpZGUgcmVzdWx0IGluIG5ldyBkYXRhIGJlaW5nXG4gICAgICogbWFkZSBhdmFpbGFibGUgZm9yIHJlYWRpbmcgZnJvbSB0aGUgcmVhZGFibGUgc2lkZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihyYXdUcmFuc2Zvcm1lciA9IHt9LCByYXdXcml0YWJsZVN0cmF0ZWd5ID0ge30sIHJhd1JlYWRhYmxlU3RyYXRlZ3kgPSB7fSkge1xuICAgICAgICAgICAgaWYgKHJhd1RyYW5zZm9ybWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByYXdUcmFuc2Zvcm1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdXcml0YWJsZVN0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3UmVhZGFibGVTdHJhdGVneSwgJ1RoaXJkIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBjb252ZXJ0VHJhbnNmb3JtZXIocmF3VHJhbnNmb3JtZXIsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5yZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJlYWRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci53cml0YWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHJlYWRhYmxlU3RyYXRlZ3ksIDApO1xuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0ocmVhZGFibGVTdHJhdGVneSk7XG4gICAgICAgICAgICBjb25zdCB3cml0YWJsZUhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayh3cml0YWJsZVN0cmF0ZWd5LCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU2l6ZUFsZ29yaXRobSA9IEV4dHJhY3RTaXplQWxnb3JpdGhtKHdyaXRhYmxlU3RyYXRlZ3kpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0UHJvbWlzZV9yZXNvbHZlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBzdGFydFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0odGhpcywgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pO1xuICAgICAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcih0aGlzLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtZXIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHRyYW5zZm9ybWVyLnN0YXJ0KHRoaXMuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHJlYWRhYmxlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSB0cmFuc2Zvcm0gc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHdyaXRhYmxlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICByZWFkYWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHdyaXRhYmxlOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW0nLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSwgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pIHtcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlQWxnb3JpdGhtKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhYm9ydEFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9zZUFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl93cml0YWJsZSA9IENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgLy8gVGhlIFtbYmFja3ByZXNzdXJlXV0gc2xvdCBpcyBzZXQgdG8gdW5kZWZpbmVkIHNvIHRoYXQgaXQgY2FuIGJlIGluaXRpYWxpc2VkIGJ5IFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZS5cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgYm90aCBzaWRlcyBhcmUgYWxyZWFkeSBlcnJvcmVkLlxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3Ioc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBlKTtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSkge1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChzdHJlYW0uX3dyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgdGhhdCBwdWxsKCkgd2FzIGNhbGxlZCB0byBwZXJtaXQgYW55IHBlbmRpbmcgd3JpdGUoKSBjYWxscyB0byBjb21wbGV0ZS4gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKClcbiAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBjYWxsZWQgZnJvbSBlbnF1ZXVlKCkgb3IgcHVsbCgpIG9uY2UgdGhlIFJlYWRhYmxlU3RyZWFtIGlzIGVycm9yZWQsIHNvIHRoaXMgd2lsbCB3aWxsIGJlIHRoZSBmaW5hbCB0aW1lXG4gICAgICAgICAgICAvLyBfYmFja3ByZXNzdXJlIGlzIHNldC5cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgLy8gUGFzc2VzIGFsc28gd2hlbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgICAgICAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiAgICB9XG4gICAgLy8gQ2xhc3MgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgY29udHJvbCBvZiB0aGUge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSBhbmQge0BsaW5rIFdyaXRhYmxlU3RyZWFtfSBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgVHJhbnNmb3JtU3RyZWFtfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgcmVhZGFibGUgc2lkZeKAmXMgaW50ZXJuYWwgcXVldWUuIEl0IGNhbiBiZSBuZWdhdGl2ZSwgaWYgdGhlIHF1ZXVlIGlzIG92ZXItZnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvcnMgYm90aCB0aGUgcmVhZGFibGUgc2lkZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIGNvbnRyb2xsZWQgdHJhbnNmb3JtIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmVcbiAgICAgICAgICogaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuIEFueSBjaHVua3MgcXVldWVkIGZvciB0cmFuc2Zvcm1hdGlvbiB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGVycm9yKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIHJlYWRhYmxlIHNpZGUgYW5kIGVycm9ycyB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRoZVxuICAgICAgICAgKiB0cmFuc2Zvcm1lciBvbmx5IG5lZWRzIHRvIGNvbnN1bWUgYSBwb3J0aW9uIG9mIHRoZSBjaHVua3Mgd3JpdHRlbiB0byB0aGUgd3JpdGFibGUgc2lkZS5cbiAgICAgICAgICovXG4gICAgICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbigndGVybWluYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgdGVybWluYXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUcmFuc2Zvcm0gU3RyZWFtIERlZmF1bHQgQ29udHJvbGxlciBBYnN0cmFjdCBPcGVyYXRpb25zXG4gICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIoc3RyZWFtLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtID0gKGNodW5rKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoICh0cmFuc2Zvcm1SZXN1bHRFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodHJhbnNmb3JtUmVzdWx0RSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1BbGdvcml0aG0gPSBjaHVuayA9PiB0cmFuc2Zvcm1lci50cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcbiAgICAgICAgLy8gYWNjZXB0IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSgpIGNhbGxzLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbiAgICAgICAgICAgIHRocm93IHN0cmVhbS5fcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIHIpO1xuICAgICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gd3JpdGFibGUuX3N0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgLy8gYWJvcnQoKSBpcyBub3QgY2FsbGVkIHN5bmNocm9ub3VzbHksIHNvIGl0IGlzIHBvc3NpYmxlIGZvciBhYm9ydCgpIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gaXMgYWxyZWFkeVxuICAgICAgICAvLyBlcnJvcmVkLlxuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKSB7XG4gICAgICAgIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cbiAgICAgICAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBjb25zdCBmbHVzaFByb21pc2UgPSBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSgpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZCBvbiBzdWNjZXNzLlxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoZmx1c2hQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByKTtcbiAgICAgICAgICAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuICAgICAgICAvLyBJbnZhcmlhbnQuIEVuZm9yY2VkIGJ5IHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBzdGFydCgpIGFuZCBwdWxsKCkuXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgICAgICAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXG4gICAgICAgIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBUcmFuc2Zvcm1TdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbWApO1xuICAgIH1cblxuICAgIGV4cG9ydHMuQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5Db3VudFF1ZXVpbmdTdHJhdGVneSA9IENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgIGV4cG9ydHMuUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCA9IFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3Q7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcbiAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbSA9IFRyYW5zZm9ybVN0cmVhbTtcbiAgICBleHBvcnRzLlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbSA9IFdyaXRhYmxlU3RyZWFtO1xuICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9ueWZpbGwuZXMyMDE4LmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJXZWJTdHJlYW1zUG9seWZpbGwiLCJTeW1ib2xQb2x5ZmlsbCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZGVzY3JpcHRpb24iLCJub29wIiwidW5kZWZpbmVkIiwiZ2V0R2xvYmFscyIsIndpbmRvdyIsImdsb2JhbHMiLCJ0eXBlSXNPYmplY3QiLCJ4IiwicmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uIiwib3JpZ2luYWxQcm9taXNlIiwiUHJvbWlzZSIsIm9yaWdpbmFsUHJvbWlzZVRoZW4iLCJwcm90b3R5cGUiLCJ0aGVuIiwib3JpZ2luYWxQcm9taXNlUmVzb2x2ZSIsInJlc29sdmUiLCJiaW5kIiwib3JpZ2luYWxQcm9taXNlUmVqZWN0IiwicmVqZWN0IiwibmV3UHJvbWlzZSIsImV4ZWN1dG9yIiwicHJvbWlzZVJlc29sdmVkV2l0aCIsInZhbHVlIiwicHJvbWlzZVJlamVjdGVkV2l0aCIsInJlYXNvbiIsIlBlcmZvcm1Qcm9taXNlVGhlbiIsInByb21pc2UiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJjYWxsIiwidXBvblByb21pc2UiLCJ1cG9uRnVsZmlsbG1lbnQiLCJ1cG9uUmVqZWN0aW9uIiwidHJhbnNmb3JtUHJvbWlzZVdpdGgiLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwic2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsUXVldWVNaWNyb3Rhc2siLCJyZXNvbHZlZFByb21pc2UiLCJmbiIsInJlZmxlY3RDYWxsIiwiRiIsIlYiLCJhcmdzIiwiVHlwZUVycm9yIiwiRnVuY3Rpb24iLCJhcHBseSIsInByb21pc2VDYWxsIiwiUVVFVUVfTUFYX0FSUkFZX1NJWkUiLCJTaW1wbGVRdWV1ZSIsImNvbnN0cnVjdG9yIiwiX2N1cnNvciIsIl9zaXplIiwiX2Zyb250IiwiX2VsZW1lbnRzIiwiX25leHQiLCJfYmFjayIsImxlbmd0aCIsInB1c2giLCJlbGVtZW50Iiwib2xkQmFjayIsIm5ld0JhY2siLCJzaGlmdCIsIm9sZEZyb250IiwibmV3RnJvbnQiLCJvbGRDdXJzb3IiLCJuZXdDdXJzb3IiLCJlbGVtZW50cyIsImZvckVhY2giLCJjYWxsYmFjayIsImkiLCJub2RlIiwicGVlayIsImZyb250IiwiY3Vyc29yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSIsInJlYWRlciIsInN0cmVhbSIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiX3N0b3JlZEVycm9yIiwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsIiwiUmVhZGFibGVTdHJlYW1DYW5jZWwiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsInJlYWRlckxvY2tFeGNlcHRpb24iLCJuYW1lIiwiX2Nsb3NlZFByb21pc2UiLCJfY2xvc2VkUHJvbWlzZV9yZXNvbHZlIiwiX2Nsb3NlZFByb21pc2VfcmVqZWN0IiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlIiwiQWJvcnRTdGVwcyIsIkVycm9yU3RlcHMiLCJDYW5jZWxTdGVwcyIsIlB1bGxTdGVwcyIsIk51bWJlcklzRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJNYXRoVHJ1bmMiLCJNYXRoIiwidHJ1bmMiLCJ2IiwiY2VpbCIsImZsb29yIiwiaXNEaWN0aW9uYXJ5IiwiYXNzZXJ0RGljdGlvbmFyeSIsIm9iaiIsImNvbnRleHQiLCJhc3NlcnRGdW5jdGlvbiIsImlzT2JqZWN0IiwiYXNzZXJ0T2JqZWN0IiwiYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCIsInBvc2l0aW9uIiwiYXNzZXJ0UmVxdWlyZWRGaWVsZCIsImZpZWxkIiwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZSIsImNlbnNvck5lZ2F0aXZlWmVybyIsImludGVnZXJQYXJ0IiwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXNzZXJ0UmVhZGFibGVTdHJlYW0iLCJJc1JlYWRhYmxlU3RyZWFtIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3QiLCJyZWFkUmVxdWVzdCIsIl9yZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdCIsImNodW5rIiwiZG9uZSIsIl9jbG9zZVN0ZXBzIiwiX2NodW5rU3RlcHMiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyIsIlJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCIsImNsb3NlZCIsImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uIiwiY2FuY2VsIiwicmVhZCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsIl9lcnJvclN0ZXBzIiwiZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQiLCJyZWxlYXNlTG9jayIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwidG9TdHJpbmdUYWciLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JJbXBsIiwicHJldmVudENhbmNlbCIsIl9vbmdvaW5nUHJvbWlzZSIsIl9pc0ZpbmlzaGVkIiwiX3ByZXZlbnRDYW5jZWwiLCJuZXh0IiwibmV4dFN0ZXBzIiwiX25leHRTdGVwcyIsInJldHVybiIsInJldHVyblN0ZXBzIiwiX3JldHVyblN0ZXBzIiwicmVzdWx0IiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbiIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsInNldFByb3RvdHlwZU9mIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsImltcGwiLCJjcmVhdGUiLCJfYSIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJDcmVhdGVBcnJheUZyb21MaXN0Iiwic2xpY2UiLCJDb3B5RGF0YUJsb2NrQnl0ZXMiLCJkZXN0IiwiZGVzdE9mZnNldCIsInNyYyIsInNyY09mZnNldCIsIm4iLCJVaW50OEFycmF5Iiwic2V0IiwiVHJhbnNmZXJBcnJheUJ1ZmZlciIsIk8iLCJJc0RldGFjaGVkQnVmZmVyIiwiQXJyYXlCdWZmZXJTbGljZSIsImJ1ZmZlciIsImJlZ2luIiwiZW5kIiwiQXJyYXlCdWZmZXIiLCJJc05vbk5lZ2F0aXZlTnVtYmVyIiwiQ2xvbmVBc1VpbnQ4QXJyYXkiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkRlcXVldWVWYWx1ZSIsImNvbnRhaW5lciIsInBhaXIiLCJfcXVldWUiLCJfcXVldWVUb3RhbFNpemUiLCJzaXplIiwiRW5xdWV1ZVZhbHVlV2l0aFNpemUiLCJJbmZpbml0eSIsIlJhbmdlRXJyb3IiLCJQZWVrUXVldWVWYWx1ZSIsIlJlc2V0UXVldWUiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0IiwidmlldyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsImJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbiIsIl92aWV3IiwicmVzcG9uZCIsImJ5dGVzV3JpdHRlbiIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kIiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieW9iUmVxdWVzdCIsIklzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCIsImRlc2lyZWRTaXplIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJzdGF0ZSIsIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlIiwiZW5xdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlIiwiZXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zIiwiX2NhbmNlbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJlbnRyeSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckUiLCJwdWxsSW50b0Rlc2NyaXB0b3IiLCJidWZmZXJCeXRlTGVuZ3RoIiwiYnl0ZXNGaWxsZWQiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsInJlYWRlclR5cGUiLCJfcGVuZGluZ1B1bGxJbnRvcyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkIiwiY29udHJvbGxlciIsInNob3VsZFB1bGwiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJwdWxsUHJvbWlzZSIsIl9wdWxsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IiLCJmaWxsZWRWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlIiwiY3VycmVudEFsaWduZWRCeXRlcyIsIm1heEJ5dGVzVG9Db3B5IiwibWluIiwibWF4Qnl0ZXNGaWxsZWQiLCJtYXhBbGlnbmVkQnl0ZXMiLCJ0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIiwicmVhZHkiLCJxdWV1ZSIsImhlYWRPZlF1ZXVlIiwiYnl0ZXNUb0NvcHkiLCJkZXN0U3RhcnQiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUNsb3NlIiwiX2J5b2JSZXF1ZXN0IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byIsInJlYWRJbnRvUmVxdWVzdCIsIkRhdGFWaWV3IiwiQllURVNfUEVSX0VMRU1FTlQiLCJjdG9yIiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3QiLCJlbXB0eVZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUiLCJmaXJzdERlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZSIsInJlbWFpbmRlclNpemUiLCJyZW1haW5kZXIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsIiwiZGVzY3JpcHRvciIsIl9zdGFydGVkIiwiZmlyc3RQZW5kaW5nUHVsbEludG8iLCJ0cmFuc2ZlcnJlZEJ1ZmZlciIsInRyYW5zZmVycmVkVmlldyIsIlJlYWRhYmxlU3RyZWFtRXJyb3IiLCJTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJfc3RyYXRlZ3lIV00iLCJ2aWV3Qnl0ZUxlbmd0aCIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsInN0YXJ0QWxnb3JpdGhtIiwicHVsbEFsZ29yaXRobSIsImNhbmNlbEFsZ29yaXRobSIsImhpZ2hXYXRlck1hcmsiLCJzdGFydFJlc3VsdCIsInIiLCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSIsInVuZGVybHlpbmdCeXRlU291cmNlIiwic3RhcnQiLCJwdWxsIiwicmVxdWVzdCIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJfcmVhZEludG9SZXF1ZXN0cyIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkIiwiRXh0cmFjdEhpZ2hXYXRlck1hcmsiLCJzdHJhdGVneSIsImRlZmF1bHRIV00iLCJFeHRyYWN0U2l6ZUFsZ29yaXRobSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kiLCJpbml0IiwiY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmsiLCJvcmlnaW5hbCIsImFib3J0IiwidHlwZSIsIndyaXRlIiwiY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayIsImFzc2VydFdyaXRhYmxlU3RyZWFtIiwiSXNXcml0YWJsZVN0cmVhbSIsImlzQWJvcnRTaWduYWwiLCJhYm9ydGVkIiwic3VwcG9ydHNBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJjcmVhdGVBYm9ydENvbnRyb2xsZXIiLCJXcml0YWJsZVN0cmVhbSIsInJhd1VuZGVybHlpbmdTaW5rIiwicmF3U3RyYXRlZ3kiLCJ1bmRlcmx5aW5nU2luayIsIkluaXRpYWxpemVXcml0YWJsZVN0cmVhbSIsInNpemVBbGdvcml0aG0iLCJTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsiLCJsb2NrZWQiLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJJc1dyaXRhYmxlU3RyZWFtTG9ja2VkIiwiV3JpdGFibGVTdHJlYW1BYm9ydCIsIldyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0IiwiV3JpdGFibGVTdHJlYW1DbG9zZSIsImdldFdyaXRlciIsIkFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJDcmVhdGVXcml0YWJsZVN0cmVhbSIsIndyaXRlQWxnb3JpdGhtIiwiY2xvc2VBbGdvcml0aG0iLCJhYm9ydEFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJfd3JpdGVyIiwiX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciIsIl93cml0ZVJlcXVlc3RzIiwiX2luRmxpZ2h0V3JpdGVSZXF1ZXN0IiwiX2Nsb3NlUmVxdWVzdCIsIl9pbkZsaWdodENsb3NlUmVxdWVzdCIsIl9wZW5kaW5nQWJvcnRSZXF1ZXN0IiwiX2JhY2twcmVzc3VyZSIsIl9hYm9ydFJlYXNvbiIsIl9hYm9ydENvbnRyb2xsZXIiLCJfcHJvbWlzZSIsIndhc0FscmVhZHlFcnJvcmluZyIsIl9yZXNvbHZlIiwiX3JlamVjdCIsIl9yZWFzb24iLCJfd2FzQWxyZWFkeUVycm9yaW5nIiwiV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nIiwiY2xvc2VSZXF1ZXN0Iiwid3JpdGVyIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UiLCJXcml0YWJsZVN0cmVhbUFkZFdyaXRlUmVxdWVzdCIsIndyaXRlUmVxdWVzdCIsIldyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24iLCJXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQiLCJXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0Iiwic3RvcmVkRXJyb3IiLCJXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkIiwiYWJvcnRSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlIiwiV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yIiwiV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0IiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3QiLCJXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZSIsImJhY2twcmVzc3VyZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCIsIl9vd25lcldyaXRhYmxlU3RyZWFtIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsIklzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIiwiZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbiIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplIiwiX3JlYWR5UHJvbWlzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0IiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkIiwiX2Nsb3NlZFByb21pc2VTdGF0ZSIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwiX3JlYWR5UHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJyZWxlYXNlZEVycm9yIiwiY2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZSIsImNsb3NlU2VudGluZWwiLCJhYm9ydFJlYXNvbiIsIklzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyIiwic2lnbmFsIiwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsIl9hYm9ydEFsZ29yaXRobSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJfc3RyYXRlZ3lTaXplQWxnb3JpdGhtIiwiX3dyaXRlQWxnb3JpdGhtIiwiX2Nsb3NlQWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZSIsInN0YXJ0UHJvbWlzZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZCIsImNodW5rU2l6ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZCIsImVucXVldWVFIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUiLCJzaW5rQ2xvc2VQcm9taXNlIiwic2lua1dyaXRlUHJvbWlzZSIsIl9yZWFkeVByb21pc2VfcmVzb2x2ZSIsIl9yZWFkeVByb21pc2VfcmVqZWN0IiwiTmF0aXZlRE9NRXhjZXB0aW9uIiwiRE9NRXhjZXB0aW9uIiwiaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvciIsImNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsIiwibWVzc2FnZSIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJ3cml0YWJsZSIsIkRPTUV4Y2VwdGlvbiQxIiwiUmVhZGFibGVTdHJlYW1QaXBlVG8iLCJzb3VyY2UiLCJwcmV2ZW50Q2xvc2UiLCJwcmV2ZW50QWJvcnQiLCJzaHV0dGluZ0Rvd24iLCJjdXJyZW50V3JpdGUiLCJhY3Rpb25zIiwic2h1dGRvd25XaXRoQWN0aW9uIiwiYWxsIiwibWFwIiwiYWN0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBpcGVMb29wIiwicmVzb2x2ZUxvb3AiLCJyZWplY3RMb29wIiwicGlwZVN0ZXAiLCJyZXNvbHZlUmVhZCIsInJlamVjdFJlYWQiLCJpc09yQmVjb21lc0Vycm9yZWQiLCJzaHV0ZG93biIsImlzT3JCZWNvbWVzQ2xvc2VkIiwiZGVzdENsb3NlZCIsIndhaXRGb3JXcml0ZXNUb0ZpbmlzaCIsIm9sZEN1cnJlbnRXcml0ZSIsIm9yaWdpbmFsSXNFcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJkb1RoZVJlc3QiLCJmaW5hbGl6ZSIsIm5ld0Vycm9yIiwiaXNFcnJvciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UiLCJ1bmRlcmx5aW5nU291cmNlIiwiUmVhZGFibGVTdHJlYW1UZWUiLCJjbG9uZUZvckJyYW5jaDIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1UZWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUiLCJyZWFkaW5nIiwicmVhZEFnYWluIiwiY2FuY2VsZWQxIiwiY2FuY2VsZWQyIiwicmVhc29uMSIsInJlYXNvbjIiLCJicmFuY2gxIiwiYnJhbmNoMiIsInJlc29sdmVDYW5jZWxQcm9taXNlIiwiY2FuY2VsUHJvbWlzZSIsImNodW5rMSIsImNodW5rMiIsImNhbmNlbDFBbGdvcml0aG0iLCJjb21wb3NpdGVSZWFzb24iLCJjYW5jZWxSZXN1bHQiLCJjYW5jZWwyQWxnb3JpdGhtIiwiQ3JlYXRlUmVhZGFibGVTdHJlYW0iLCJyZWFkQWdhaW5Gb3JCcmFuY2gxIiwicmVhZEFnYWluRm9yQnJhbmNoMiIsImZvcndhcmRSZWFkZXJFcnJvciIsInRoaXNSZWFkZXIiLCJwdWxsV2l0aERlZmF1bHRSZWFkZXIiLCJjbG9uZUUiLCJwdWxsMUFsZ29yaXRobSIsInB1bGwyQWxnb3JpdGhtIiwicHVsbFdpdGhCWU9CUmVhZGVyIiwiZm9yQnJhbmNoMiIsImJ5b2JCcmFuY2giLCJvdGhlckJyYW5jaCIsImJ5b2JDYW5jZWxlZCIsIm90aGVyQ2FuY2VsZWQiLCJjbG9uZWRDaHVuayIsIkNyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbSIsImNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZSIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayIsImNvbnZlcnRSZWFkYWJsZVN0cmVhbVR5cGUiLCJjb252ZXJ0UmVhZGVyT3B0aW9ucyIsIm9wdGlvbnMiLCJtb2RlIiwiY29udmVydFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZSIsImNvbnZlcnRJdGVyYXRvck9wdGlvbnMiLCJCb29sZWFuIiwiY29udmVydFBpcGVPcHRpb25zIiwiYXNzZXJ0QWJvcnRTaWduYWwiLCJjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIiLCJyZWFkYWJsZSIsIlJlYWRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NvdXJjZSIsIkluaXRpYWxpemVSZWFkYWJsZVN0cmVhbSIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSIsImdldFJlYWRlciIsInJhd09wdGlvbnMiLCJwaXBlVGhyb3VnaCIsInJhd1RyYW5zZm9ybSIsInRyYW5zZm9ybSIsInBpcGVUbyIsImRlc3RpbmF0aW9uIiwidGVlIiwiYnJhbmNoZXMiLCJ2YWx1ZXMiLCJhc3luY0l0ZXJhdG9yIiwic291cmNlQ2FuY2VsUHJvbWlzZSIsImNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0IiwiYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiIsIkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kiLCJieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvdW50U2l6ZUZ1bmN0aW9uIiwiQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNDb3VudFF1ZXVpbmdTdHJhdGVneSIsImNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbiIsImNvbnZlcnRUcmFuc2Zvcm1lciIsImZsdXNoIiwicmVhZGFibGVUeXBlIiwid3JpdGFibGVUeXBlIiwiY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayIsIlRyYW5zZm9ybVN0cmVhbSIsInJhd1RyYW5zZm9ybWVyIiwicmF3V3JpdGFibGVTdHJhdGVneSIsInJhd1JlYWRhYmxlU3RyYXRlZ3kiLCJ3cml0YWJsZVN0cmF0ZWd5IiwicmVhZGFibGVTdHJhdGVneSIsInRyYW5zZm9ybWVyIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwicmVhZGFibGVTaXplQWxnb3JpdGhtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwid3JpdGFibGVTaXplQWxnb3JpdGhtIiwic3RhcnRQcm9taXNlX3Jlc29sdmUiLCJJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lciIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW0iLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uIiwiX3JlYWRhYmxlIiwiX3dyaXRhYmxlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlIiwiVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlIiwiVHJhbnNmb3JtU3RyZWFtRXJyb3IiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsImRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsInJlYWRhYmxlQ29udHJvbGxlciIsIl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsInRlcm1pbmF0ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsInRyYW5zZm9ybUFsZ29yaXRobSIsImZsdXNoQWxnb3JpdGhtIiwiX3RyYW5zZm9ybUFsZ29yaXRobSIsIl9mbHVzaEFsZ29yaXRobSIsInRyYW5zZm9ybVJlc3VsdEUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Qcm9taXNlIiwiYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSIsImZsdXNoUHJvbWlzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\n");

/***/ })

};
;